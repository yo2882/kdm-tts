-- Bundled by luabundle {"version":"1.7.0"}
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '"' .. name .. '"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(require)
__bundle_register("__root", function(require, _LOADED, __bundle_register, __bundle_modules)
KDM_VERSION = "1.4.6"

GLOBAL_OBJECT = self

local Armor = require("Kdm/Armor")
local Archive = require("Kdm/Archive")
local BattleUi = require("Kdm/BattleUi")
local Campaign = require("Kdm/Campaign")
local Console = require("Kdm/Console")
local Deck = require("Kdm/Deck")
local Expansion = require("Kdm/Expansion")
local GlobalUi = require("Kdm/GlobalUi")
local Hunt = require("Kdm/Hunt")
local Location = require("Kdm/Location")
local Log = require("Kdm/Log")
local log = Log.ForModule("G")
local MessageBox = require("Kdm/MessageBox")
local MilestoneBoard = require("Kdm/MilestoneBoard")
local Monster = require("Kdm/Monster")
local NamedObject = require("Kdm/NamedObject")
local Player = require("Kdm/Player")
local Rules = require("Kdm/Rules")
local Settlement = require("Kdm/Settlement")
local Showdown = require("Kdm/Showdown")
local Survivor = require("Kdm/Survivor")
local Terrain = require("Kdm/Terrain")
local Timeline = require("Kdm/Timeline")
local Ui = require("Kdm/Ui")
local Weapon = require("Kdm/Weapon")

---------------------------------------------------------------------------------------------------

function onSave()
    local saveState = {
        Campaign = Campaign.Save(),
        Expansion = Expansion.Save(),
        Monster = Monster.Save(),
        Player = Player.Save(),
        Survivor = Survivor.Save(),
        Timeline = Timeline.Save(),
        BattleUi = BattleUi.Save(),
    }

    return JSON.encode(saveState)
end

---------------------------------------------------------------------------------------------------

function onLoad(saveJson)
    local saveState = JSON.decode(saveJson) or {}
    initialized = false

    -- Init() = everything before the UI is first rendered (includes UI setup)
    --
    Console.Init()
    Expansion.Init(saveState.Expansion or {})
    --
    Log.Init(e)
    log:Printf("Me√Ø's Kingdom Death: Monster Mod v%s", KDM_VERSION)
    log:Printf("This mod is a fork of Misterslack's and Farbod's mods. Check'em out!")
    --
    Armor.Init(e)
    NamedObject.Init(e)
    Terrain.Init(e)
    Ui.Init(e)
    Weapon.Init(e)
    --
    Archive.Init(e)
    Location.Init(e)
    --
    Deck.Init()
    Hunt.Init()
    Monster.Init(saveState.Monster or {})
    Rules.Init()
    Settlement.Init()
    --
    Survivor.Init(saveState.Survivor or {})
    --
    Player.Init(saveState.Player or {})
    --
    Showdown.Init()
    BattleUi.Init()
    --
    GlobalUi.Init()
    Timeline.Init(saveState.Timeline or {})
    --
    Campaign.Init(saveState.Campaign or {})
    --
    MilestoneBoard.Init()
    -- mad sketchy that initialization order for MessageBox doesn't match include order, but this must be *after* all 2d UIs since we want this to display *over*
    -- all other 2d UIs, and 2d UI display order is solely based on the order of the XML elements (last is on top of everything else)
    MessageBox.Init()

    Ui.Get2d():ApplyToObject()

    -- PostInit() = register event handlers and code that depends on the UI elements actually being instantiated
    Wait.frames(function()
        Log.PostInit()
        Monster.PostInit()
        Survivor.PostInit()
        Player.PostInit()
        Timeline.PostInit()
        BattleUi.PostInit()
        initialized = true
    end, 20)
end

---------------------------------------------------------------------------------------------------

function getPlayerInfo(ordinal)
    log(ordinal)
    if initialized then
        local players = Player.Players()
        local player = players[ordinal]
        return {
            name = player.survivorSheet:Survivor().name,
            color = player.markerObject.getColorTint(),
        }
    end
    return nil
end
end)
__bundle_register("Kdm/Weapon", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Expansion = require("Kdm/Expansion")

---------------------------------------------------------------------------------------------------

local Weapon = {}
Weapon.__index = Weapon

---------------------------------------------------------------------------------------------------

function Weapon.Init(saveState)
    Weapon.weapons = {}
    for _, expansion in ipairs(Expansion.All()) do
        for name, stats in pairs(expansion.weaponStats or {}) do
            if Weapon.weapons[name] then
                assert(false, string.format("Weapon %s was already registered by expansion %s", name, Weapon.weapons[name].expansion))
            end
            Weapon.weapons[name] = Weapon.Create(name, expansion.name, stats)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Weapon.Get(name)
    return Weapon.weapons[name]
end

---------------------------------------------------------------------------------------------------

Weapon.statCheckFuncs = {
    accuracy = Check.Num,
    deadly = Check.Num,
    devastating = Check.Num,
    earlyIron = Check,
    paired = Check,
    savage = Check,
    sharp = Check,
    slow = Check,
    speed = Check.Num,
    strength = Check.Num,
}

function Weapon.Create(name, expansion, stats)
    assert(Check.Str(name))
    assert(Check.Str(expansion))

    local weapon = {
        name = name,
        expansion = expansion,
    }
    setmetatable(weapon, Weapon)

    for stat, value in pairs(stats) do
        local checkFunc = Weapon.statCheckFuncs[stat]
        assert(Check(checkFunc, "Unrecognized stat %s for weapon %s", stat, name))
        assert(checkFunc(value, "Stat %s had unexpected value %s", stat, tostring(value)))
        weapon[stat] = value
    end

    assert(Check.Num(weapon.speed, "Weapon %s missing speed", name))
    assert(Check.Num(weapon.accuracy, "Weapon %s missing accuracy", name))
    assert(Check.Num(weapon.strength, "Weapon %s missing strength", name))

    return weapon
end

---------------------------------------------------------------------------------------------------

function Weapon:__tostring()
    return string.format("%s (%d/%d/%d)", self.name, self.speed, self.accuracy, self.strength)
end

---------------------------------------------------------------------------------------------------

return {
    Init = Weapon.Init,
    Get = Weapon.Get,
}

end)
__bundle_register("Kdm/Expansion", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")

---------------------------------------------------------------------------------------------------

local Core = require("Kdm/Expansion/Core")
local CommunityEdition = require("Kdm/Expansion/CommunityEdition")
local DragonKing = require("Kdm/Expansion/DragonKing")
local DungBeetleKnight = require("Kdm/Expansion/DungBeetleKnight")
local FlowerKnight = require("Kdm/Expansion/FlowerKnight")
local Gorm = require("Kdm/Expansion/Gorm")
local LionGod = require("Kdm/Expansion/LionGod")
local LionKnight = require("Kdm/Expansion/LionKnight")
local LonelyTree = require("Kdm/Expansion/LonelyTree")
local Manhunter = require("Kdm/Expansion/Manhunter")
local Slenderman = require("Kdm/Expansion/Slenderman")
local Spidicules = require("Kdm/Expansion/Spidicules")
local Sunstalker = require("Kdm/Expansion/Sunstalker")
local CcgHomebrew = require("Kdm/Expansion/CcgHomebrew")
local ForsakerSisters = require("Kdm/Expansion/ForsakerSisters")
local StormKnight = require("Kdm/Expansion/StormKnight")
local KingsCoin = require("Kdm/Expansion/KingsCoin")
local DrifterKnight = require("Kdm/Expansion/DrifterKnight")
local AllisonTheTwilightKnight = require("Kdm/Expansion/AllisonTheTwilightKnight")
local TracksOfDeath = require("Kdm/Expansion/TracksOfDeath")
local HarvesterWorm = require("Kdm/Expansion/HarvesterWorm")
local CinderFestival = require("Kdm/Expansion/CinderFestival")

---------------------------------------------------------------------------------------------------

local Expansion = {}

---------------------------------------------------------------------------------------------------

function Expansion.Init(saveState)
    Expansion.allExpansions = {
        Core,
        CommunityEdition,
        DragonKing,
        DungBeetleKnight,
        FlowerKnight,
        Gorm,
        LionGod,
        LionKnight,
        LonelyTree,
        Manhunter,
        Slenderman,
        Spidicules,
        Sunstalker,
        --CcgHomebrew,
        ForsakerSisters,
        StormKnight,
        KingsCoin,
        DrifterKnight,
        AllisonTheTwilightKnight,
        TracksOfDeath,
        HarvesterWorm,
        CinderFestival,
    }

    Expansion.expansionsByName = {}
    for _, expansion in ipairs(Expansion.allExpansions) do
        Expansion.expansionsByName[expansion.name] = expansion
    end

    Expansion.unlockedMode = saveState.unlockedMode

    Expansion.enabledByExpansionName = {}
    for _, name in ipairs(saveState.enabledExpansions or {}) do
        local expansion = Expansion.expansionsByName[name]
        assert(Check(expansion, "Expansion save state had unknown expansion %s", name))
        Expansion.enabledByExpansionName[name] = true
    end
    Expansion.enabledByExpansionName["Core"] = true
end

---------------------------------------------------------------------------------------------------

function Expansion.Save()
    local enabledExpansions = {}
    for name, enabled in pairs(Expansion.enabledByExpansionName) do
        if enabled then
            table.insert(enabledExpansions, name)
        end
    end

    return {
        enabledExpansions = enabledExpansions,
        unlockedMode = Expansion.unlockedMode,
    }
end

---------------------------------------------------------------------------------------------------

function Expansion.All()
    return Expansion.allExpansions
end

---------------------------------------------------------------------------------------------------

function Expansion.SetEnabled(enabledByExpansionName)
    Expansion.enabledByExpansionName = {}
    assert(Check.Table(enabledByExpansionName))
    for expansionName, enabled in pairs(enabledByExpansionName) do
        assert(Check.Str(expansionName))
        assert(Check.BooleanOrNil(enabled))
        Expansion.enabledByExpansionName[expansionName] = enabled
    end
    Expansion.enabledByExpansionName["Core"] = true
end

---------------------------------------------------------------------------------------------------

function Expansion.IsEnabled(expansionName)
    assert(Check.Str(expansionName))
    return Expansion.enabledByExpansionName[expansionName]
end

---------------------------------------------------------------------------------------------------

function Expansion.SetUnlockedMode(unlockedMode)
    Expansion.unlockedMode = unlockedMode
end

---------------------------------------------------------------------------------------------------

function Expansion.IsUnlockedMode()
    return Expansion.unlockedMode
end

---------------------------------------------------------------------------------------------------

return {
    Init = Expansion.Init,
    Save = Expansion.Save,
    All = Expansion.All,
    SetEnabled = Expansion.SetEnabled,
    IsEnabled = Expansion.IsEnabled,
    SetUnlockedMode = Expansion.SetUnlockedMode,
    IsUnlockedMode = Expansion.IsUnlockedMode,
}

end)
__bundle_register("Kdm/Expansion/CinderFestival", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Cinder Festival",

    archiveOverrides = {
        newArchive = "Community Edition Archive",
        oldArchive = "Core Archive",
        entries = {
            { "Core Rules", "Rulebook" },
        },
    },

    components = {
        ["Terrain"]                 = "Cinder Festival Terrain",
        ["Terrain Tiles"]           = "Cinder Festival Terrain Tiles",
        ["Strange Resources"]       = "Cinder Festival Strange Resources",
        ["Settlement Events"]       = "Cinder Festival Settlement Events",
        ["Bookmarks"]               = "Monster Patte",
        ["Settlement Locations"]    = "Cinder Festival Settlement Locations",
        ["Innovations"]             = "Cinder Festival Innovations",
        ["Disorders"]               = "Cinder Festival Disorders",
        ["Abilities"]               = "Cinder Festival Abilities",
        ["Fighting Arts"]           = "Take Cover",
        ["Secret Fighting Arts"]    = "Cinder Festival Secret Fighting Arts",
        ["Rare Gear"]               = "Cinder Festival Rare Gear",
    },

    settlementEvents = {
        "Vivid Dreams",
        "The Unblemished Man",
        "They Await the King",
    },

    timelineEvents = {
        { year = 7, type = "RulebookEvent", name = "Phoenix Feather (CF)" },
        { year = 21, name = "Dream Walker", type = "RulebookEvent" },
        { year = 22, name = "Scorched Trail", type = "RulebookEvent" },
        { year = 25, name = "Floating Embers", type = "RulebookEvent" },
        { year = 26, name = "The Twilight Knight", type = "RulebookEvent" },
        { year = 27, name = "The Cursed Steed", type = "RulebookEvent" },
        { year = 29, name = "The Cinder Festival", type = "RulebookEvent" },
        { year = 30, name = "The Path Forward", type = "RulebookEvent" },
    },

    terrain = {
        ["2 Boulders"]            = { terrainTile = "Boulder", count = 2 },
        ["6 Beaten Paths"]        = { terrainTile = "Beaten Path", count = 6 },
        ["2 Lantern Pedestials"]  = { terrainTile = "Lantern Pedestial", count = 2 },
        ["6 Rocky Paths"]         = { terrainTile = "Rocky Path", count = 6 },
        ["2 Briar Patch"]         = { terrainTile = "Briar Patch", count = 2 },
        ["Downed Tree"]           = { terrainTile = "Downed Tree", count = 1 },
        ["2 Time Puddles"]        = { terrainTile = "Time Puddles", count = 2 },
        ["Stone Stair"]           = { terrainTile = "Stone Stair", count = 1 },
    },

    terrainTileSizes = {
        ["Vermin Swarm"]                        = { x = 1, y = 1 },
        ["Time Puddle"]                         = { x = 1, y = 1 },
        ["Hooded Knight"]                       = { x = 1, y = 1 },
        ["Rocky Path"]                          = { x = 1, y = 1 },
        ["Beaten Path"]                         = { x = 1, y = 1 },
        ["Lantern Pedestal"]                    = { x = 1, y = 1 },
        ["Watcher Polyp"]                       = { x = 1, y = 1 },
        ["Mad Spectre"]                         = { x = 1, y = 1 },

        ["Stairwell"]                           = { x = 1, y = 2 },
        ["Bookshelf / Smoldering Shelf"]        = { x = 1, y = 2 },

        ["King's Man"]                          = { x = 2, y = 2 },
        ["Twilight Knight"]                     = { x = 2, y = 2 },
        ["King"]                                = { x = 2, y = 2 },
        ["Half-Eaten Monster"]                  = { x = 2, y = 2 },
        ["Boulder"]                             = { x = 2, y = 2 },
        ["Cursed Gregalope"]                    = { x = 2, y = 2 },
        ["Briar Patch"]                         = { x = 2, y = 2 },
        ["Scribe's Desk"]                       = { x = 2, y = 2 },
        ["Watcher Corpse"]                      = { x = 2, y = 2 },
        ["Charnal Crow"]                        = { x = 2, y = 2 },
        ["Dream Wake"]                          = { x = 2, y = 2 },
        ["Grand Master"]                        = { x = 2, y = 2 },

        ["Exhausted Lantern Horde"]             = { x = 3, y = 3 },
        ["Cyclone of Existence"]                = { x = 3, y = 3 },

        ["Stone Stair"]                         = { x = 2, y = 4 },
        ["Downed Tree"]                         = { x = 2, y = 4 },
    },

    armorStats = {
        ["Rainbow Cloak"]               = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Lucid Twilight Cloak"]        = { head = 3, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Refined Lantern Greaves"]     = { head = 0, arms = 0, body = 0, waist = 0, legs = 6 },
        ["Refined Lantern Cuirass"]     = { head = 0, arms = 0, body = 6, waist = 0, legs = 0 },
        ["Refined Lantern Helm"]        = { head = 6, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Refined Lantern Gauntlets"]   = { head = 0, arms = 6, body = 0, waist = 0, legs = 0 },
        ["Refined Lantern Mail"]        = { head = 0, arms = 0, body = 0, waist = 6, legs = 0 },
        ["Regal Cape"]                  = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Gambler's Mask"]              = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Ancient Hero's Cowl"]         = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Refined Lantern Cuirass"]     = { head = 0, arms = 0, body = 6, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Flawless Steel Pike"]     = { speed = 2, accuracy = 5, strength = 7, sharp = true, },
        ["Flawless Steel Sword"]    = { speed = 3, accuracy = 5, strength = 7, sharp = true, deadly = 2, },
        ["Flawless Steel Axe"]      = { speed = 2, accuracy = 4, strength = 8, sharp = true, savage = 1, },
        ["Arquebus"]                = { speed = 1, accuracy = 6, strength = 10, devastating = 1, slow = true, },
        ["Empyreal Dagger"]         = { speed = 3, accuracy = 5, strength = 0, paired = true, deadly = 2, },
        ["Empyreal Arrow"]          = { speed = 1, accuracy = 6, strength = 5, slow = true, },
        ["Godslayer"]               = { speed = 2, accuracy = 6, strength = 18, slow = true, sharp = true, devastating = 2, },
        ["Hand Cannon"]             = { speed = 1, accuracy = 7, strength = 9, savage = 1, slow = true, },
        ["Gilded Thundermaul"]      = { speed = 2, accuracy = 6, strength = 10, },
        ["Relic Shield"]            = { speed = 1, accuracy = 6, strength = 7, },
        ["Blood Katana"]            = { speed = 3, accuracy = 4, strength = 6, sharp = true },
        ["Dragoon King"]            = { speed = 2, accuracy = 7, strength = 13, devastating = 1, },
    },

    rulebooks = {
        {
            name = "Cinder Festival Rules",
            pages = {
                ["Cinder Festival Table of Content"] = {
                    keywords = { "Table of Content" },
                    state = 1,
                },
                ["Wandering Watcher Hunt Events 1-4"] = {
                    keywords = { "Wandering" , "Watcher" , "Hunt", "Events" },
                    state = 4,
                },
                ["Wandering Watcher Hunt Events 5-10"] = {
                    keywords = { "Wandering" , "Watcher" , "Hunt", "Events" },
                    state = 5,
                },
                ["Ruined Library"] = {
                    keywords = { "Ruined" , "Library" },
                    state = 6,
                },
                ["Phoenix Feather (CF)"] = {
                    keywords = { "Phoenix" , "Feather" },
                    state = 7,
                    timelineEvent = true,
                },
                ["Dream Walker"] = {
                    keywords = { "Dream" , "Walker" },
                    state = 8,
                    timelineEvent = true,
                },
                ["Scorched Trail"] = {
                    keywords = { "Scorched" , "Trail" },
                    state = 9,
                    timelineEvent = true,
                },
                ["The Twilight Knight"] = {
                    keywords = { "Twilight" , "Knight" },
                    state = 10,
                    timelineEvent = true,
                },
                ["Floating Embers"] = {
                    keywords = { "Floating" , "Embers" },
                    state = 11,
                    timelineEvent = true,
                },
                ["The Cursed Steed"] = {
                    keywords = { "The" , "Cursed" , "Steed" },
                    state = 11,
                    timelineEvent = true,
                },
                ["The Cinder Festival"] = {
                    keywords = { "The" , "Cinder" , "Festival" },
                    state = 12,
                    timelineEvent = true,
                },
                ["Bizarre Bazaar"] = {
                    keywords = { "Bizarre" , "Bazaar" },
                    state = 13,
                },
                ["Roaring Back"] = {
                    keywords = { "Roaring" , "Back" },
                    state = 14,
                },
                ["Showdown: Mounted King's Man"] = {
                    keywords = { "Showdown:" , "Mounted" , "King's" , "Man" },
                    state = 15,
                    showdown = true,
                },
                ["Haunted Quill"] = {
                    keywords = { "Haunted" , "Quill" },
                    state = 16,
                },
                ["The Path Forward"] = {
                    keywords = { "The" , "Path" , "Forward" },
                    state = 16,
                    timelineEvent = true,
                },
                ["Showdown: Gold Smoke Knight"] = {
                    keywords = { "Showdown:" , "Gold" , "Smoke" , "Knight" },
                    state = 17,
                    showdown = true,
                },
                ["Showdown: Wandering Watcher"] = {
                    keywords = { "Showdown:" , "Wandering" , "Watcher" },
                    state = 18,
                    showdown = true,
                },
                ["Honor The Fallen"] = {
                    keywords = { "Honor" , "The" , "Fallen" },
                    state = 19,
                },
                ["Fuming Forge"] = {
                    keywords = { "Fuming" , "Forge" },
                    state = 19,
                },
                ["Rage Against"] = {
                    keywords = { "Rage" , "Against" },
                    state = 20,
                },
                ["Shattered Dreams"] = {
                    keywords = { "Shattered" , "Dreams" },
                    state = 21,
                },
                ["What Dreams May Come"] = {
                    keywords = { "What" , "Dreams" , "May" , "Come" },
                    state = 22,
                },
                ["Those Who Wander"] = {
                    keywords = { "Those" , "Who" , "Wander" },
                    state = 23,
                },
                ["Followed"] = {
                    keywords = { "Followed" },
                    state = 23,
                    timelineEvent = true,
                },
                ["Showdown: The Twilight Order"] = {
                    keywords = { "Showdown:" , "The" , "Twilight" , "Order" },
                    state = 24,
                    showdown = true,
                },
                ["Showdown: Ethereal Dreamer"] = {
                    keywords = { "Showdown:" , "Ethereal" , "Dreamer" },
                    state = 25,
                    showdown = true,
                },
                ["The Way of The Master"] = {
                    keywords = { "The" , "Way" , "of" , "The" , "Master" },
                    state = 26,
                },
                ["Dream Odyssey"] = {
                    keywords = { "Dream" , "Odyssey" },
                    state = 26,
                },
                ["Dreamwave"] = {
                    keywords = { "Dreamwave" },
                    state = 27,
                    timelineEvent = true,
                },
                ["Regal Horrors"] = {
                    keywords = { "Regal" , "Horrors" },
                    state = 28,
                    timelineEvent = true,
                },
                ["Phoney King"] = {
                    keywords = { "Phoney" , "King" },
                    state = 29,
                },
                ["Library of Corpses"] = {
                    keywords = { "Library" , "of" , "Corpses" },
                    state = 30,
                },
                ["Legendary Showdown: King's Court"] = {
                    keywords = { "Legendary" , "Showdown:" , "King's" , "Court" },
                    state = 31,
                    showdown = true,
                },
                ["Epilogue"] = {
                    keywords = { "Epilogue" },
                    state = 32,
                },
                ["Brain Drain"] = {
                    keywords = { "Brain" , "Drain" },
                    state = 33,
                },
                ["Desperate Search"] = {
                    keywords = { "Desperate" , "Search" },
                    state = 34,
                },
                ["Legendary Showdown: Golden Eyed King Reborn"] = {
                    keywords = { "Legendary" , "Showdown:" , "Golden" , "Eyed" , "King" , "Reborn" },
                    state = 35,
                    showdown = true,
                },
                ["Legendary Showdown: Mangled Throne"] = {
                    keywords = { "Legendary" , "Showdown:" , "Mangled" , "Throne" },
                    state = 36,
                    showdown = true,
                },
                ["Time and Place"] = {
                    keywords = { "Time" , "and" , "Place" },
                    state = 37,
                },
                ["Restoration"] = {
                    keywords = { "Restoration" },
                    state = 38,
                },
                ["Showdown: The Traveler"] = {
                    keywords = { "Showdown:" , "The" , "Traveler" },
                    state = 39,
                    showdown = true,
                },
                ["Time to Die"] = {
                    keywords = { "Time" , "to" , "Die" },
                    state = 40,
                },
                ["Glossary"] = {
                    keywords = { "Glossary" },
                    state = 41,
                },
            }
        },
    },

    guidNames = { ["8d16e3"] = "Cinder Festival Archive" },

    archiveEntries = {
        archive = "Cinder Festival Archive",
        entries = {
            { "Cinder Festival Abilities", "Abilities" },
            { "Take Cover", "Fighting Arts" },
            { "Cinder Festival Secret Fighting Arts", "Secret Fighting Arts" },
            { "Cinder Festival Disorders", "Disorders" },
            { "Cinder Festival Strange Resources", "Strange Resources" },

            { "Cinder Festival Terrain", "Terrain" },
            { "Cinder Festival Special Terrain", "Terrain" },
            { "Cinder Festival Terrain Tiles", "Terrain Tiles" },
            { "Monster Patte", "Bookmarks"},

            { "Cinder Festival Settlement Events", "Settlement Events" },

            { "Cinder Festival Innovations", "Innovations" },

            { "Cinder Festival Settlement Locations", "Settlement Locations" },

            { "Cinder Festival Rare Gear", "Gear" },

            { "Ethereal Dreamer", "Monster Figurine" },

            { "Order Member", "Monster Figurine" },

            { "Traveler", "Monster Figurine" },

            { "Mangled Throne", "Monster Figurine" },
            { "Mangled Throne Info", "AI" },
            { "Mangled Throne Basic Action", "AI" },
            { "Mangled Throne Basic AI", "AI" },
            { "Mangled Throne Advanced AI", "AI" },
            { "Mangled Throne Legendary AI", "AI" },
            { "Mangled Throne Special AI", "AI" },
            { "Mangled Throne Hit Locations", "Hit Locations" },

            { "Golden Eyed King Reborn", "Monster Figurine" },
            { "Golden Eyed King Reborn Info", "AI" },
            { "Golden Eyed King Reborn Basic Action", "AI" },
            { "Golden Eyed King Reborn Basic AI", "AI" },
            { "Golden Eyed King Reborn Advanced AI", "AI" },
            { "Golden Eyed King Reborn Legendary AI", "AI" },
            { "Golden Eyed King Reborn Special AI", "AI" },
            { "Golden Eyed King Reborn Hit Locations", "Hit Locations" },
            { "Golden Eyed King Reborn Resources", "Monster Resources" },

            { "King's Court", "Monster Figurine" },
            { "King's Court Info", "AI" },
            { "King's Court Basic Action", "AI" },
            { "King's Court Basic AI", "AI" },
            { "King's Court Advanced AI", "AI" },
            { "King's Court Legendary AI", "AI" },
            { "King's Court Special AI", "AI" },
            { "King's Court Hit Locations", "Hit Locations" },

            { "Ethereal Dreamer", "Monster Figurine" },
            { "Ethereal Dreamer Info", "AI" },
            { "Ethereal Dreamer Basic Action", "AI" },
            { "Ethereal Dreamer Basic AI", "AI" },
            { "Ethereal Dreamer Legendary AI", "AI" }, -- watcher polyps deck
            { "Ethereal Dreamer Special AI", "AI" },
            { "Ethereal Dreamer Hit Locations", "Hit Locations" },

            { "Gold Smoke Knight (CF)", "Monster Figurine" },
            { "Gold Smoke Knight (CF) Info", "AI" },
            { "Gold Smoke Knight (CF) Basic Action", "AI" },
            { "Gold Smoke Knight (CF) Basic AI", "AI" },
            { "Gold Smoke Knight (CF) Advanced AI", "AI" },
            { "Gold Smoke Knight (CF) Legendary AI", "AI" },
            { "Gold Smoke Knight (CF) Special AI", "AI" },
            { "Gold Smoke Knight (CF) Hit Locations", "Hit Locations" },
            { "Gold Smoke Knight (CF) Resources", "Monster Resources" },

            { "Twilight Order", "Monster Figurine" },
            { "Twilight Order Info", "AI" },
            { "Twilight Order Basic Action", "AI" },
            { "Twilight Order Basic AI", "AI" },
            { "Twilight Order Legendary AI", "AI" }, -- challenge deck
            { "Twilight Order Special AI", "AI" },
            { "Twilight Order Hit Locations", "Hit Locations" },

            { "Traveler", "Monster Figurine" },
            { "Traveler Info", "AI" },
            { "Traveler Basic Action", "AI" },
            { "Traveler Basic AI", "AI" },
            { "Traveler Special AI", "AI" },
            { "Traveler Hit Locations", "Hit Locations" },

            { "Mounted King's Man", "Monster Figurine" },
            { "Mounted King's Man Info", "AI" },
            { "Mounted King's Man Basic Action", "AI" },
            { "Mounted King's Man Special AI", "AI" },
            { "Cursed Gregalope Hit Locations", "Hit Locations" },

            { "Wandering Watcher", "Monster Figurine" },
            { "Wandering Watcher Info", "AI" },
            { "Wandering Watcher Basic Action", "AI" },
            { "Wandering Watcher Legendary Action", "AI" },
            { "Wandering Watcher Special AI", "AI" },

        },
    },
    
    monsters = {
        {
            name = "Mangled Throne",
            size = { x = 3, y = 3 },
            rules = { "Cinder Festival Rules", 36 },
            resourcesDeck = false,
            position = "(11, 8)",
            playerPositions = { "(9, 13)", "(10, 14)", "(11, 14)", "(12, 14)" },
            playerRotations = {{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "2 Tall Grass",
                    positions = { "(4.5, 1.5)", "(17.5, 1.5)", "(4.5, 14.5)", "(17.5, 14.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Charnal Crow",
                    positions = { "(1.5, 1.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Downed Tree",
                    positions = { "(3.5, 4.5)" },
                    rotations = { { x = 0, y = 90, z = 0 } },
                },
                {
                    terrain = "2 Boulders",
                    positions = { "(4, 1)", "(3, 2)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "2 Briar Patch",
                    positions = { "(4.5, 12.5)", "(9.5, 5.5)", "(13.5, 9.5)", "(17.5, 3.5)" },
                    rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 0, z = 0 } },
                },
            },
            specialTerrain = {
                {
                    terrain = "4 Vermin Swarm",
                    terrainTile = "Vermin Swarm",
                    positions = { "(2, 4)", "(1, 14)", "(7, 1)", "(20, 2)", "(6, 11)", "(11, 11)", "(13, 6)", "(19, 14)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, },
                
                },
                {
                    terrain = "Charnal Crow",
                    terrainTile = "Charnal Crow",
                    positions = { "(1.5, 1.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                 },
            },
            miscObject = { name = "Lonely Fruit", type = "Terrain Tiles" },
            levels = {
                {
                    name = "Mangled Throne",
                    level = 5,
                    showdown = {
                        starting = {
                            special = { "Bear Fruit", "Impenetrable Trunk", "Moving Ground", "Maulberry Fruit", "Feast", "Charged Storm" },
                        },
                        basic = 8,
                        advanced = 5,
                        legendary = 2,
                        life = 25,
                        toughness = 25,
                        speed = 2,
                        damage = 3,
                        accurary = 2,
                        luck = 2,
                    },
                },
            },
        },
        {
            name = "Golden Eyed King Reborn",
            size = { x = 3, y = 3 },
            rules = { "Cinder Festival Rules", 35 },
            position = "(12, 9)",
            playerPositions = { "(10, 15)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "Nightmare Tree",
                    positions = { "(12, 9)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "2 Briar Patch",
                    positions = { "(9.5, 6.5)", "(14.5, 6.5)", "(9.5, 11.5)", "(14.5, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 0, z = 0 } },
                },
                {
                    terrain = "2 Time Puddles",
                    positions = { "(8, 9)", "(14, 9)", "(13, 6)", "(11, 12)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Golden Eyed King Reborn",
                    level = 5,
                    showdown = {
                        rules = { "Cinder Festival Rules", 35 },
                        survivorStatus = { "Dreaded Decade", "Dreaded Decade", "Dreaded Decade", "Dreaded Decade" },
                        starting = {
                            legendary = { "Top of the Food Chain" },
                            special = { "Materialize", "Spiral Age", "Zeal", "Prime of Life" },
                            misc = { "Indomitable", "Berserker", "Weak Spot", "Golden Eyes" },
                        },
                        customBasic = { "Bored", "Instant Wing Strike", "Peck", "Peck", "Pustule Cannons" },
                        customAdvanced = { "The Difference Between Us", "Gouge & Feast", "Ripple", "Wing Punch" },
                        miscHitLocations = { "Forever Young", "Ignite", "Fell Swoop", "Grub Forage" },
                        removeHitLocations = { "Glorious Arm Pit", "Soft Lower Gut" },
                        life = 25,
                        movement = 10,
                        toughness = 25,
                        speed = 2,
                        damage = 3,
                        evasion = 2,
                        luck = 1000,
                        unfixedTerrain = { "Ore Vein", "Bug Patch" },
                    },
                },
            },
        },
        {
            name = "King's Court",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Cinder Festival Rules", 31 },
            resourcesDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            specialTerrain = {
                {
                    terrain = "Scribe's Desk",
                    terrainTile = "Scribe's Desk",
                    positions = { "(11.5, 1.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "King",
                    terrainTile = "King",
                    positions = { "(11.5, 5.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "4 King's Men",
                    terrainTile = "King's Man",
                    positions = { "(1.5, 8.5)", "(21.5, 8.5)", "(4.5, 13.5)", "(18.5, 13.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "King's Court",
                    level = 4,
                    showdown = {
                        survivorStatus = { "Polarized Aura", "Polarized Aura", "Polarized Aura", "Polarized Aura" },
                        starting = {
                            special = { "Red Lens", "Green Lens", "Blue Lens", "Ghost Step", "Impossible Eyes", "Regal Order", "Dry Quill", "Untold Secrets" },
                            misc = { "Indomitable" },
                        },
                        removeHitLocations = { "Glided Codpiece" },
                        basic = 10,
                        advanced = 2,
                        movement = 6,
                        toughness = 30,
                        speed = 3,
                        damage = 6,
                        accurary = 2,
                    },
                },
            },
        },
        {
            name = "Ethereal Dreamer",
            nemesis = true,
            size = { x = 4, y = 4 },
            rules = { "Cinder Festival Rules", 25 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(8, 3.5)", "(15, 3.5)", "(8, 13.5)", "(15, 13.5)", "(5, 8.5)", "(18, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            specialTerrain = {
                { terrain = "Dreamer's Tail" },
                { terrain = "Dream Board" },
                {
                    terrain = "Dream Wake",
                    terrainTile = "Dream Wake",
                    positions = { "(11.5, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "10 Watcher Polyps",
                    terrainTile = "Dream Wake",
                    positions = { "(9, 6)", "(14, 6)", "(9, 11)", "(14, 11)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "2 Hooded Knights",
                    terrainTile = "Hooded Knight",
                    positions = { "(6, 1)", "(17, 1)", "(6, 22)", "(17, 22)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Ethereal Dreamer",
                    level = 4,
                    showdown = {
                        survivorStatus = { "Polarized Aura", "Polarized Aura", "Polarized Aura", "Polarized Aura" },
                        starting = {
                            special = { "Surfaced", "Invulnerable", "Phantasmagoria", "Whalesong", "Wide Awake" },
                        },
                        life = 10,
                        basic = 12,
                        movement = 100,
                        toughness = 30,
                        luck = 3,
                    },
                },
            },
        },
        {
            name = "Gold Smoke Knight (CF)",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Cinder Festival Rules", 17 },
            position = "(11.5, 8.5)",
            playerPositions = { "(8, 5)", "(15, 5)", "(8, 12)", "(15, 12)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },

            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(8, 3.5)", "(15, 3.5)", "(8, 13.5)", "(15, 13.5)", "(5, 8.5)", "(18, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            
            specialTerrain = {
                {
                    terrain = "Exhausted Lantern Horde",
                    terrainTile = "Exhausted Lantern Horde",
                    positions = { "(2, 8)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Watcher Corpse",
                    terrainTile = "Watcher Corpse",
                    positions = { "(18.5, 3.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Gold Smoke Knight (CF)",
                    level = 1,
                    showdown = {
                        basic = 9,
                        advanced = 7,
                        legendary = 2,
                        movement = 8,
                        toughness = 27,
                        starting = {
                            special = { "Blacken", "Frustration", "Mauler", "Secondary Forge", "Fuming" },
                            misc = { "Indomitable" },
                        },
                    },
                },
            },
        },
        {
            name = "Twilight Order",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Cinder Festival Rules", 24 },
            resourcesDeck = false,
            position = "(11.5, 5.5)",
            playerPositions = { "(11, 12)", "(12, 12)", "(13, 12)", "(14, 12)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },

            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(11.5, 2)", "(11.5, 21)", "(6.5, 5)", "(16.5, 5)", "(6.5, 12)", "(16.5, 12)" },
                    rotations = { { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 } },
                },
                {
                    terrain = "Stone Stair",
                    positions = { "(9.5, 8.5)", "(13.5, 8.5)" },
                    rotations = { { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 } },
                },
            },
            specialTerrain = {
                {
                    terrain = "Grand Master",
                    terrainTile = "Grand Master",
                    positions = { "(11.5, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Nightmare Whale",
                    terrainTile = "Ethereal Dreamer",
                    positions = { "(2.5, 2.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Twilight Order",
                    level = 4,
                    showdown = {
                        basic = 13,
                        movement = 6,
                        toughness = 0,
                        life = 1000,
                        starting = {
                            special = { "Order Knight", "Order Guard", "Order Archivist", "Order Protector", "Rank and File", "Incapacitated" },
                            misc = { "Indomitable" },
                        },
                    },
                },
            },
        },
        {
            name = "Traveler",
            nemesis = true,
            size = { x = 1, y = 1 },
            rules = { "Cinder Festival Rules", 39 },
            resourcesDeck = false,
            position = "(12, 8)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            
            specialTerrain = {
                {
                    terrain = "Cyclone of Existence",
                    terrainTile = "Cyclone of Existence",
                    positions = { "(12, 8)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Twilight Order",
                    level = 4,
                    showdown = {
                        basic = 10,
                        movement = 10,
                        toughness = 26,
                        evasion = 2,
                        starting = {
                            special = { "Phoenix Feathers", "Feathered Cloak", "Way of the Phoenix", "Power Struggle" },
                            misc = { "Indomitable" },
                        },
                    },
                },
                {
                    name = "Twilight Order",
                    level = 5,
                    showdown = {
                        basic = 15,
                        movement = 10,
                        toughness = 26,
                        evasion = 2,
                        accuracy = 1,
                        starting = {
                            special = { "Phoenix Feathers", "Feathered Cloak", "Way of the Phoenix", "Power Struggle" },
                            misc = { "Indomitable" },
                        },
                    },
                },
                {
                    name = "Twilight Order",
                    level = 6,
                    showdown = {
                        basic = 15,
                        movement = 10,
                        toughness = 26,
                        evasion = 3,
                        accuracy = 2,
                        starting = {
                            special = { "Phoenix Feathers", "Feathered Cloak", "Way of the Phoenix", "Power Struggle" },
                            misc = { "Indomitable" },
                        },
                        removeHitLocations = { "Paradox!", "Paradox!", "Paradox!" },
                    },
                },
            },
        },
        {
            name = "Mounted King's Man",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Cinder Festival Rules", 15 },
            resourcesDeck = false,
            basicAiDeck = "King's Man (KC) Basic AI",
            advancedAiDeck = "King's Man (KC) Advanced AI",
            legendaryAiDeck = "Familiar Face",
            hitLocationsDeck = "King's Man (KC) Hit Locations",
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(10, 6.5)", "(11.5, 5)", "(13, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            specialTerrain = {
                {
                    terrain = "Cursed Gregalope",
                    terrainTile = "Cursed Gregalope",
                    positions = { "(11.5, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting", "Mounted", "Screaming Antelope Advanced AI", "Screaming Antelope Hit Locations", "Cursed Gregalope Hit Locations", "Cursed Steed", "Accursed Rhythm", "Stolen Lead", "Gobbled Up" },
                            misc = { "Indomitable" },
                        },
                        life = 13,
                        basic = 12,
                        advanced = 6,
                        legendary = 1,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 6,
                        toughness = 18,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            },
        },

        -- wandering watcher lost knowledge isn't finished
        {
            name = "Wandering Watcher",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Cinder Festival Rules", 18 },
            resourcesDeck = false,
            advancedAiDeck = false,
            legendaryAiDeck = false,
            
            basicAiDeck = "Watcher Basic AI",
            hitLocationsDeck = "Watcher Hit Locations",
            
            position = "(11.5, 2.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(4, 6.5)", "(4, 14.5)", "(9, 10.5)", "(14, 4.5)", "(19, 6.5)", "(19, 14.5)" },
                    rotations = { { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 } },
                },
                {
                    terrain = "2 Acanthus Plants",
                    positions = { "(3, 13)", "(3, 12)", "(4, 12)", "(19, 16)", "(20, 15)", "(20, 14)", "(20, 1)", "(19, 2)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Toppled Pillar",
                    positions = { "(7.5, 5)", "(15.5, 11)", },
                    rotations = { { x = 0, y = 270, z = 0 }, { x = 0, y = 270, z = 0 } },
                },
            },
            specialTerrain = {
                { terrain = "Stairwell" },
                { terrain = "Smoldering Shelf" },
                {
                    terrain = "Twilight Knight",
                    terrainTile = "Twilight Knight",
                    positions = { "(14.5, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Twilight Knight",
                    terrainTile = "Twilight Knight",
                    positions = { "(14.5, 8.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "10 Bookshelves",
                    terrainTile = "Bookshelf / Smoldering Shelf",
                    positions = { 
                        "(1.5, 2)", "(1.5, 4)", "(1.5, 6)", "(1.5, 8)", "(1.5, 10)",
                        "(5.5, 2)", "(5.5, 4)", "(5.5, 6)", "(5.5, 8)", "(5.5, 10)",
                        "(10.5, 1)", "(10.5, 4)", "(10.5, 7)", "(10.5, 10)", "(10.5, 13)",
                        "(12.5, 1)", "(12.5, 4)", "(12.5, 7)", "(12.5, 10)", "(12.5, 13)",
                        "(17.5, 2)", "(17.5, 4)", "(17.5, 6)", "(17.5, 8)", "(17.5, 10)",
                        "(21.5, 2)", "(21.5, 4)", "(21.5, 6)", "(21.5, 8)", "(21.5, 10)",
                    },
                    rotations = { 
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                        { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },
                    },
                },
            },
            levels = {
                {
                    name = "Wandering Watcher",
                    level = 4,
                    showdown = {
                        starting = {
                            special = { "Audience", "Lantern Vortex", "Vapor of Nothingness", "Unyielding", "Insatiable", "Lost Knowledge", "Twilight Knight Ally" },
                            misc = { "Indomitable" },
                        },
                        basic = 10,
                        legendary = 4,
                        life = 15,
                        movement = 0,
                        toughness = 27,
                        evasion = 2,
                        accuracy = 2,
                    },
                },
            },
        },

    },
}


end)
__bundle_register("Kdm/Expansion/HarvesterWorm", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Harvester Worm",

    guidNames = { ["951ad1"] = "Harvester Worm Archive" },

    components = {
        ["Fighting Arts"] = "Harvester Worm Fighting Arts",
        ["Secret Fighting Arts"] = "Harvester Worm Secret Fighting Arts",
        ["Disorders"] = "Harvester Worm Disorders",
        ["Strange Resources"] = "Harvester Worm Strange Resources",
        ["Settlement Events"] = "Harvester Worm Settlement Events",
        ["Innovations"] = "Harvester Worm Innovations",
        ["Settlement Locations"] = "Harvester Worm Settlement Locations",
        ["Abilities"] = "Harvester Worm Abilities",
        ["Bookmarks"] = "Harvester Worm Bookmarks",
        ["Terrain"] = "Harvester Worm Terrain",
        ["Terrain Tiles"] = { "Stone Statue", "Gardener Ball", "Gardener Worm", "Glowing Corpse" },

    },

    campaigns = {
        {
            name = "People of the Stone",
            years = 5,
            timeline = {
                { year = 1, type = "RulebookEvent", name = "Worm Feast" },
                { year = 1, type = "RulebookEvent", name = "First Day" },
                { year = 2, type = "RulebookEvent", name = "Endless Screams" },
                { year = 2, type = "RulebookEvent", name = "Stranger in the Dark" },
                { year = 3, type = "RulebookEvent", name = "Silken Skin" },
                { year = 4, type = "RulebookEvent", name = "Hacked Apart" },
                { year = 4, type = "ShowdownEvent", monster = "Butcher", level = "Level 1" },
                { year = 5, type = "RulebookEvent", name = "Dust to Dust" },
            },
            survivalActions = {
                { name = "Dodge", checked = true },
                { name = "Dive" },
                { name = "Dash" },
                { name = "Surge" },
                --{ name = "Endure" },
            },
            milestones = {
                { name = "First Birth", event = "Principle: New Life" },
                { name = "First Death", event = "Principle: Death" },
                { name = "15 Population", event = "Principle: Society" },
                { name = "5 Innovations", event = "Hooded Knight" },
            },
            objectsByLocation = {
                ["Innovation Deck"] = { tag = "Deck", name = "Innovation Deck", type = "Innovations", faceDown = true, cards = {
                    { name = "Ammonia - Language Consequence", type = "Innovations" },
                    { name = "Drums - Language Consequence", type = "Innovations" },
                    { name = "Hovel - Language Consequence", type = "Innovations" },
                    { name = "Inner Lantern - Language Consequence", type = "Innovations" },
                    { name = "Paint - Language Consequence", type = "Innovations" },
                    { name = "Symposium - Language Consequence", type = "Innovations" },
                } },
                ["Principle: Death"] = { tag = "Deck", name = "Principle: Death", type = "Innovations", faceDown = true, cards = {
                    { name = "Cannibalize - Death Principle", type = "Innovations" },
                    { name = "Graves - Death Principle", type = "Innovations" },
                } },
                ["Principle: New Life"] = { tag = "Deck", name = "Principle: New Life", type = "Innovations", faceDown = true, cards = {
                    { name = "Protect the Young - New Life Principle", type = "Innovations" },
                    { name = "Survival of the Fittest - New Life Principle", type = "Innovations" },
                } },
                ["Principle: Society"] = { tag = "Deck", name = "Principle: Society", type = "Innovations", faceDown = true, cards = {
                    { name = "Accept Darkness - Society Principle", type = "Innovations" },
                    { name = "Collective Toil - Society Principle", type = "Innovations" },
                } },
                ["Principle: Conviction"] = { tag = "Deck", name = "Principle: Conviction", type = "Innovations", faceDown = true, cards = {
                    { name = "Barbaric - Conviction Principle", type = "Innovations" },
                    { name = "Romantic - Conviction Principle", type = "Innovations" },
                } },
                ["Innovation 1"] = { tag = "Card", name = "Stone Touch", type = "Innovations" },
                ["Settlement Location 1"] = { tag = "Card", name = "Statue Garden", type = "Settlement Locations" },
            },
            references = {
                { name = "Age Reference", location = "Reference 1" },
                { name = "Intimacy (People of the Stone) Reference", location = "Reference 2" },
                { name = "Bold Reference", location = "Reference 3" },
                { name = "Insight Reference", location = "Reference 4" },
            },
            milestoneEvents = {
                ["huntXp"] = {
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 22 },  -- Retired
                },
                ["courage"] = {
                    { rules = "Core Rules", state = 56 },  -- Bold
                    { rules = "Core Rules", state = 83 },  -- See the Truth
                },
                ["understanding"] = {
                    { rules = "Core Rules", state = 65 },  -- Insight
                    { rules = "Core Rules", state = 90 },  -- White Secret
                },
                ["weaponProficiency"] = {
                    { rules = "Core Rules", state = 21 },  -- Specialist
                    { rules = "Core Rules", state = 21 },  -- Master
                },
            },
        },
        
    },

    settlementEvents = {
        "The Ground Hungers",
        "Settlement Caravan",
        "Harvested",
    },

    timelineEvents = {
        { year = 2, name = "Hollow Grave", type = "RulebookEvent" },
    },

    minions = {
        {
            name = "Wormlet Mob",
            movement = 10,
            size = { x = 2, y = 2 },
        },
        {
            name = "Painted Wormlets",
            movement = 11,
            size = { x = 2, y = 2 },
        },
    },

    terrain = {
        ["Stone Statue"]             = { terrainTile = "Stone Statue",   count = 1 },
        ["Gardener Ball"]            = { terrainTile = "Gardener Ball",  count = 1 },
        ["Gardener Worm (Terrain)"]  = { terrainTile = "Gardener Worm (Terrain)",  count = 1 },
        ["Glowing Corpse"]           = { terrainTile = "Glowing Corpse", count = 1 },
    },

    terrainTileSizes = {
        ["Stone Statue"]             = { x = 1, y = 2 },
        ["Gardener Ball"]            = { x = 2, y = 2 },
        ["Glowing Corpse"]           = { x = 2, y = 2 },
        ["Gardener Worm (Terrain)"]  = { x = 2, y = 2 },
    },


    settlementLocationGear = {
        ["Stone Distillery"] = "Stone Distillery Gear",
    },

    armorStats = {
        ["Stone Mask"]          = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Blindfold"]           = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Face Fists"]          = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Calcified Fists"]     = { head = 0, arms = 6, body = 0, waist = 0, legs = 0 }, 
        ["Tube Dress"]          = { head = 0, arms = 0, body = 2, waist = 2, legs = 0 },
        ["Stone Pauldrons"]     = { head = 0, arms = 0, body = 5, waist = 0, legs = 0 },
        ["Calcified Pauldrons"] = { head = 0, arms = 0, body = 15, waist = 0, legs = 0 }, 
        ["Concussion Shield"]   = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
    },

    weaponStats = {
        ["Concussion Shield"] = { speed = 1, accuracy = 6, strength = 3 },
        ["Founding Spear"]    = { speed = 2, accuracy = 6, strength = 2 },
        ["Mawhammer"]         = { speed = 2, accuracy = 5, strength = 8 },
        ["Ouroboros"]         = { speed = 2, accuracy = 4, strength = 8 },
        ["Face Fists"]        = { speed = 3, accuracy = 8, strength = 2, deadly = 1 },
        ["Calcified Fists"]   = { speed = 3, accuracy = 6, strength = 5, deadly = 1 },
        ["Noise Chain"]       = { speed = 3, accuracy = 7, strength = 2, paired = true },
        ["Gong Hammer"]       = { speed = 2, accuracy = 5, strength = 0, },
    },

    archiveEntries = {
        archive = "Harvester Worm Archive",
        entries = {
            { "Harvester Worm Rules", "Rulebook" }, 
            { "Intimacy (People of the Stone) Reference", "References" },

            { "Harvester Worm Fighting Arts", "Fighting Arts" },
            { "Harvester Worm Secret Fighting Arts", "Secret Fighting Arts" }, 
            { "Harvester Worm Disorders", "Disorders" },
            { "Harvester Worm Strange Resources", "Strange Resources" },
            { "Harvester Worm Abilities", "Abilities" },
            { "Harvester Worm Bookmarks", "Bookmarks"},
            { "Harvester Worm Terrain", "Terrain" },
            { "Stone Statue", "Terrain Tiles" },
            { "Gardener Ball", "Terrain Tiles" },
            { "Gardener Worm", "Terrain Tiles" },
            { "Glowing Corpse", "Terrain Tiles" },
            { "Harvester Worm Settlement Events", "Settlement Events" },
            { "Harvester Worm Innovations", "Innovations" },
            { "Harvester Worm Settlement Locations", "Settlement Locations" },
            { "Stone Distillery Gear", "Gear" },

            { "Harvester Worm", "Monster Figurine" },  

            { "Harvester Worm Hunt Events", "Monster Hunt Events" },

            { "Harvester Worm Info", "AI" },
            { "Harvester Worm Basic Action", "AI" },
            { "Harvester Worm Basic AI", "AI" },
            { "Harvester Worm Advanced AI", "AI" },
            { "Harvester Worm Legendary AI", "AI" },
            { "Harvester Worm Special AI", "AI" },
            { "Harvester Worm Hit Locations", "Hit Locations" },

            { "Gardener Worm", "Monster Figurine" }, 

            { "Gardener Worm Info", "AI" },
            { "Gardener Worm Basic Action", "AI" },
            { "Gardener Worm Basic AI", "AI" },
            { "Gardener Worm Advanced AI", "AI" },
            { "Gardener Worm Special AI", "AI" },
            { "Gardener Worm Hit Locations", "Hit Locations" },

            { "Wormlet Mob", "Minion Figurine" },
            { "Painted Wormlets", "Minion Figurine" },
        },
    },

    rulebooks = {
        {
            name = "Harvester Worm Rules",
            pages = {
                ["Harvester Worm Rules"] = {
                    keywords = { "Harvester", "Worm", "Rules" },
                    state = 1,
                },
                ["Hollow Grave"] = {
                    keywords = { "Hollow", "Grave" },
                    state = 4,
                    timelineEvent = true,
                },
                ["Hunting Grounds"] = {
                    keywords = { "Hunting", "Grounds" },
                    state = 6,
                    timelineEvent = true,
                },
                ["Nervous Ossification"] = {
                    keywords = { "Nervous", "Ossification" },
                    state = 6,
                },
                ["Fighting Over Scraps"] = {
                    keywords = { "Fighting", "Over", "Scraps" },
                    state = 7,
                    timelineEvent = true,
                },
                ["Easy Pickings"] = {
                    keywords = { "Easy", "Pickings" },
                    state = 7,
                    timelineEvent = true,
                },
                ["Belly Storage"] = {
                    keywords = { "Belly", "Storage" },
                    state = 8,
                },
                ["Party Tricks"] = {
                    keywords = { "Party", "Tricks" },
                    state = 8,
                },
                ["Showdown: Harvester Worm Level 1-2"] = {
                    keywords = { "Showdown:", "Harvester", "Worm", "Level", "1-2" },
                    state = 9,
                    showdown = true,
                },
                ["Aftermath (Harvester Worm)"] = {
                    keywords = { "Aftermath" },
                    state = 10,
                },
                ["Showdown: Harvester Worm Level 3"] = {
                    keywords = { "Showdown:", "Harvester", "Worm", "Level", "3" },
                    state = 10,
                    showdown = true,
                },
                ["Showdown: Gardener Worm"] = {
                    keywords = { "Showdown:", "Gardener", "Worm" },
                    state = 11,
                    showdown = true,
                },
                ["Legendary Monsters (Harvester Worm)"] = {               
                    keywords = { "Harvester", "Worm:", "Legendary", "Monsters" },
                    state = 12,
                },
                ["Worm Feast"] = {
                    keywords = { "Worm", "Feast" },
                    state = 13,
                    timelineEvent = true,
                },
                ["Intimacy (Harvester Worm)"] = {
                    keywords = { "Intimacy" },
                    state = 14,
                },
                ["Silken Skin"] = {
                    keywords = { "Silken", "Skin" },
                    state = 14,
                    timelineEvent = true,
                },
                ["Hacked Apart"] = {
                    keywords = { "Hacked", "Apart" },
                    state = 15,
                    timelineEvent = true,
                },
                ["Dust To Dust"] = {
                    keywords = { "Dust", "To", "Dust" },
                    state = 16,
                    timelineEvent = true,
                },
                ["Showdown: Homecoming"] = {
                    keywords = { "Showdown:", "Homecoming" },
                    state = 17,
                    showdown = true,
                },
                ["Glossary (Harvester Worm)"] = {
                    keywords = { "Glossary" },
                    state = 17,
                },
            },
        },
    },

    monsters = {
        {
            name = "Harvester Worm",
            nemesis = true,
            size = { x = 1, y = 1 },
            huntTrack = { "H", "H", "H", "H", "H", "O", "L", "M", "M", "M", "H" },
            position = "(12, 6)",
            resourcesDeck = false,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        rules = { "Harvester Worm Rules", 9 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        basic = 3,
                        advanced = 2,
                        movement = 12,
                        toughness = 13,
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Eruption", "Tenderize" }
                        },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(8.5, 11.5)", "(14.5, 5.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                            },
                        },
                        randomTerrain = 1,
                        playerPositions = { "(11, 8)", "(11, 9)", "(12, 8)", "(12, 9)" },

                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        rules = { "Harvester Worm Rules", 9 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        basic = 10,
                        advanced = 7,
                        movement = 12,
                        toughness = 14,
                        speed = 1,
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Eruption", "Tenderize" }
                        },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(1.5, 11.5)", "(7.5, 5.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                            },
                        },
                        randomTerrain = 1,
                        playerPositions = { "(4, 8)", "(4, 9)", "(5, 8)", "(5, 9)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },

                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        rules = { "Harvester Worm Rules", 10 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        basic = 5,
                        advanced = 8,
                        legendary = 9,
                        movement = 14,
                        toughness = 18,
                        speed = 2,
                        damage = 1,
                        luck = 1,
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Eruption", "Parasite Infusion" }
                        },
                        fixedTerrain = {
                            {
                                terrain = "Gardener Worm (Terrain)",
                                positions = { "(11.5, 8.5)" },
                                rotations = { { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Stone Statue",
                                positions = { "(18.5, 6)", "(18.5, 11)", "(17.5, 8)", "(17.5, 9)" },
                                rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Toppled Pillar",
                                positions = { "(15, 8.5)", "(18.5, 4)" },
                                rotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Dead Monster",
                                positions = { "(20.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(21.5, 4)", "(17.5, 13)", "(21.5, 13)" },
                                rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Survivor Corpse",
                                positions = { "(21, 7)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                        },
                        playerPositions = { "(5, 7)", "(5, 8)", "(5, 9)", "(5, 10)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },
                    },
                },
                {
                    name = "Blood Worm",
                    level = 4,
                    showdown = {
                        rules = { "Harvester Worm Rules", 12 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        movement = 10,
                        toughness = 21,
                        speed = 2,
                        evasion = 2,
                        life = 14,
                        customBasic = { "Concussion Combo", "Pain Train", "Megabite", "Seismic Belly Flop", "Thrash", },
                        customAdvanced = { "Clingy", "Fist and Tooth", "The Worm" },
                        starting = {
                            special = { "Split Body", "Tremorsense", "Double Eruption", "Vengeful Stone Heart (Blood Worm)", "Facial Foreskin (Blood Worm)" }
                        },
                        removeHitLocations = { "Patient Stone Heart", "Midpoint", "Intimate Stone Heart", "Stone Face", "Facial Foreskin", "Vengeful Stone Heart" },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(8.5, 11.5)", "(14.5, 5.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                            },
                        },
                        playerPositions = { "(11, 8)", "(11, 9)", "(12, 8)", "(12, 9)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },
                    },
                },
                {
                    name = "Dung Worm",
                    level = 5,
                    showdown = {
                        rules = { "Harvester Worm Rules", 12 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        movement = 14,
                        toughness = 22,
                        accuracy = 2,
                        luck = 2,
                        damage = 3,
                        life = 11,
                        customBasic = { "Home Run" },
                        miscAI = { "Backspin Shot (Dung Worm)", "Invisible Layup (Dung Worm)", "Ricochet Shot (Dung Worm)" },
                        customAdvanced = { "Food Fight", "Worm Whip" },
                        customLegendary = { "Abduct", "Free Food", "Garden Sweep", "Regurgitate", "Together Forever" },
                        miscHitLocations = { "Century Carapace (Dung Worm)", "Century Carapace (Dung Worm)", "Century Carapace (Dung Worm)", "Century Carapace (Dung Worm)", "Century Carapace (Dung Worm)", "Century Carapace (Dung Worm)", "Filthy Gut (Dung Worm)", "Side of Resin Ball (Dung Worm)", "Side of Resin Ball (Dung Worm)" },
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Eruption", "Parasite Infusion", "Prepared Tunnels", "Centiballer", "Heavy Load", "Separation Anxiety" },
                            misc = { "Berserker" },
                        },
                        removeHitLocations = { "Patient Stone Heart", "Midpoint", "Stone Scales", "Stone Scales", "Stone Scales", "Stone Scales", "Stone Scales" },
                        unfixedTerrain = { "Bug Patch", "Gardener Ball" },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(1.5, 11.5)", "(7.5, 5.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                            },
                        },
                        playerPositions = { "(4, 8)", "(4, 9)", "(5, 8)", "(5, 9)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },
                    },
                },
                {
                    name = "Regal Worm",
                    level = 6,
                    showdown = {
                        rules = { "Harvester Worm Rules", 12 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        survivorStatus2 = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        movement = 12,
                        toughness = 26,
                        accuracy = 4,
                        luck = 2,
                        damage = 2,
                        speed = 6,
                        life = 16,
                        customBasic = { "Megabite", "Thundering Silence", "Fist and Tooth" },
                        customAdvanced = { "Clingy", "Solvent Cannon", "Whispers of Dissent" },
                        customLegendary = { "Wormhole", "Synchronized Screaming", "Euphoric Grasp", "Regurgitate" },
                        miscHitLocations = { "Regal Gauntlet (Regal Worm)", "Regal Plume (Regal Worm)", "Regal Sabatons (Regal Worm)", "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Eruption", "Parasite Infusion", "Vapid Gaze", "Wormlet Mob Setup", "Wormlet Mob Action", "Young Wormlet Flesh" },
                            misc = { "Weak Spot", "King's Aura", "Silent Hymn" },
                        },
                        removeHitLocations = { "Eager Stone Heart", "Facial Foreskin", "Vengeful Stone Heart", "Nervous Spasm", "Nervous Spasm", "Nervous Spasm", "Nervous Spasm", "Nervous Spasm" },
                        unfixedTerrain = { "3 Stone Columns", "Ore Vein", "Ore Vein", "2 Acanthus Plants", "2 Acanthus Plants", "Giant Stone Face" },
                        fixedTerrain = {
                            {
                                terrain = "Gardener Worm (Terrain)",
                                positions = { "(11.5, 8.5)" },
                                rotations = { { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Stone Statue",
                                positions = { "(18.5, 6)", "(18.5, 11)", "(17.5, 8)", "(17.5, 9)" },
                                rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Toppled Pillar",
                                positions = { "(15, 8.5)", "(18.5, 4)" },
                                rotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Dead Monster",
                                positions = { "(20.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(21.5, 4)", "(17.5, 13)", "(21.5, 13)" },
                                rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 } },
                            },
                            {
                                terrain = "Survivor Corpse",
                                positions = { "(21, 7)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                        },
                        playerPositions = { "(5, 7)", "(5, 8)", "(5, 9)", "(5, 10)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },
                        miscObject = { name = "Wormlet Mob", type = "Minion Figurine" },
                    },
                },
                {
                    name = "Homecoming",
                    level = 2,
                    showdown = {
                        rules = { "Harvester Worm Rules", 17 },
                        survivorStatus = { "Noise", "Noise", "Noise", "Noise" },
                        basic = 8,
                        advanced = 5,
                        movement = 12,
                        toughness = 14,
                        starting = {
                            special = { "Wormy Body", "Tremorsense", "Tenderize", "Impatience", "Reinforcements", "Abandon Settlement", "Eruption" }
                        },
                        unfixedTerrain = { "Stone Statue" },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(6.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "Gardener Worm (Terrain)",
                                positions = { "(2.5, 8.5)" },
                                rotations = { { x = 0, y = 90, z = 0 } },
                            },
                        },
                        randomTerrain = 1,
                        playerPositions = { "(1, 7)", "(1, 8)", "(1, 9)", "(1, 10)" },
                        playerRotations = {{ x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 90, z = 0 } },

                    },
                },
            },

        },
        {
            name = "Gardener Worm",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Harvester Worm Rules", 11 },
            resourcesDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(9, 6)", "(14, 6)", "(9, 11)", "(14, 11)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            levels = {
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        starting = {
                            special = { "Pursuit" },
                        },
                        basic = 5,
                        advanced = 3,
                        movement = 3,
                        toughness = 14,
                        accuracy = -2,
                        luck = 5,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        starting = {
                            special = { "Pursuit" },
                        },
                        basic = 9,
                        advanced = 6,
                        movement = 3,
                        toughness = 18,
                        luck = 5,
                    },
                },
            },
        },
    },

    


}
end)
__bundle_register("Kdm/Expansion/TracksOfDeath", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Tracks Of Death",

    guidNames = { ["a9545d"] =  "Tracks Of Death Archive" },

    components = {
        ["Abilities"] = "Tracks Of Death Abilities",
        ["Strange Resources"] = "Tracks Of Death Strange Resources",
        ["Rare Gear"] = "Tracks Of Death Rare Gear",
    },

    weaponStats = {
        ["Mirror Dagger"]     = { speed = 2, accuracy = 6, strength = 2, sharp = true },
        ["Prophetic Jawbone"] = { speed = 2, accuracy = 6, strength = 4, savage = true },
    },

    archiveEntries = {
        archive = "Tracks Of Death Archive",
        entries = {
            { "Tracks Of Death Rules", "Rulebook" },
            { "Tracks Of Death Rare Gear", "Gear" },
            { "Tracks Of Death Strange Resources", "Strange Resources" },
            { "Tracks Of Death Abilities", "Abilities" },
        }
    },

    rulebooks = {
        {
            name = "Tracks Of Death Rules",
            pages = {
                ["Tracks Of Death Rules"] = {
                    keywords = { "Tracks", "Of", "Death", "Rules" },
                    state = 1,
                },
                ["Tracks Of Death: Hunt Event Tracker"] = {
                    keywords = { "Tracks", "Of", "Death:", "Hunt", "Event", "Tracker" },
                    state = 3,
                },
            },
        },
    },








































}
end)
__bundle_register("Kdm/Expansion/AllisonTheTwilightKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {

    name = "Allison",

    guidNames = { ["f5e5b1"] =  "Allison The Twilight Knight Archive" },

    components = {
        ["Abilities"] = "Allison The Twilight Knight Abilities",
        ["Armor Sets"] = "Bronze Armor",
        ["Settlement Locations"] = "Bronzesmith",
        ["Rare Gear"] = "Allison The Twilight Knight Rare Gear",
        ["Fighting Arts"] = "Quick Strike",
        ["Secret Fighting Arts"] = "Survivorship",
        ["Disorders"] = "Impetuous",
        ["Strange Resources"] = "Allison The Twilight Knight Strange Resources",
        ["Terrain"] = "Mineral Vein",
        ["Terrain Tiles"] = "Mineral Vein",
        ["Settlement Events"] = "Allison The Twilight Knight Settlement Events",
        ["Innovations"] = "Allison The Twilight Knight Innovations",
        ["Bookmarks"] = "Allison The Twilight Knight Bookmarks",
        ["Tactics"] = "Sneak Attack",
        ["Weapon Proficiencies"] = "Allison Twilight Sword Proficiency",
        ["Patterns"] = "Allison The Twilight Knight Patterns",
    },

    settlementEvents = {
        "Training Day",
        "Coming Of Age",
    },

    replaceNemesis = { nemesis = "Watcher", replacement = "Allison Watcher" },

    terrain = {
        ["Mineral Vein"] = { terrainTile = "Mineral Vein", count = 1 },
    },

    terrainTileSizes = {
        ["Mineral Vein"] = { x = 1, y = 1 },
    },

    armorStats = {
        ["Bronze Armor"]             = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Bronze Cuirass"]           = { head = 0, arms = 0, body = 3, waist = 3, legs = 0 },
        ["Bronze Gauntlets"]         = { head = 0, arms = 3, body = 0, waist = 0, legs = 0 },
        ["Bronze Greaves"]           = { head = 0, arms = 0, body = 0, waist = 0, legs = 3 },
        ["Awakened Twilight Cloak"]  = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Nerve Cuirass"]            = { head = 0, arms = 0, body = 6, waist = 0, legs = 0 },
        ["Relic Hood"]               = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Lantern Nerve Whip"]        = { speed = 2, accuracy = 6, strength = 9, deadly = 2 },
        ["Allison's Twilight Sword"]  = { speed = 1, accuracy = 9, strength = 9 },
        ["Bronze Sword"]              = { speed = 2, accuracy = 6, strength = 6, deadly = 2 },
    },

    settlementLocationGear = {
        ["Bronzesmith"] = "Bronzesmith Gear",
    },

    rulebooks = {
        {
            name = "Allison The Twilight Knight Rules",
            pages = {
                ["Allison The Twilight Knight Rules"] = {
                    keywords = { "Allison", "The", "Twilight", "Knight", "Rules" },
                    state = 1,
                },
                ["Allison Hooded Knight"] = {
                    keywords = { "Allison", "Hooded", "Knight" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Allison The Twilight Knight"] = {
                    keywords = { "Showndown:", "Allison", "The", "Twilight", "Knight" },
                    state = 4,
                    showdown = true,
                },
                ["The Duel"] = {
                    keywords = { "The", "Duel" },
                    state = 5,
                },
                ["The Order"] = {
                    keywords = { "The", "Order" },
                    state = 6,
                    timelineEvent = true,
                },
                ["Return Of The Order"] = {
                    keywords = { "Return", "Of", "The", "Order" },
                    state = 7,
                    timelineEvent = true,
                },
                ["Who Watches The Watcher"] = {
                    keywords = { "Who", "Watches", "The", "Watcher" },
                    state = 8,
                    timelineEvent = true,
                },
                ["Allison Showdown: Watcher"] = {
                    keywords = { "Allison", "Showdown:", "Watcher" },
                    state = 9,
                    showdown = true,
                },
            },
        },
    },

    archiveEntries = {
        archive = "Allison The Twilight Knight Archive",
        entries = {
            { "Allison The Twilight Knight Rules", "Rulebook" },
            { "Allison The Twilight Knight Rare Gear", "Gear" },
            { "Allison The Twilight Knight Strange Resources", "Strange Resources" },
            { "Allison Hit Locations", "Hit Locations" },
            { "Impetuous", "Disorders" },
            { "Allison The Twilight Knight Settlement Events", "Settlement Events" },
            { "Sneak Attack", "Tactics"},
            { "Allison Twilight Sword Proficiency", "Weapon Proficiencies" },
            { "Allison The Twilight Knight Abilities", "Abilities" },
            { "Quick Strike", "Fighting Arts" },
            { "Survivorship", "Secret Fighting Arts" },
            { "Allison The Twilight Knight Patterns", "Patterns" },

            { "Mineral Vein", "Terrain" },
            { "Mineral Vein", "Terrain Tiles" },

            { "Allison Special AI", "AI" },
            { "Allison Info", "AI" },
            { "Allison Basic Action", "AI" },
            { "Allison Basic AI", "AI" },
            { "Allison Advanced AI", "AI" },
            { "Allison Legendary AI", "AI" },
            { "Allison", "Monster Figurine" },

            { "Allison The Twilight Knight Innovations", "Innovations" },
            { "Allison The Twilight Knight Bookmarks", "Bookmarks"},
            { "Bronze Armor", "Armor Sets" },
            { "Bronzesmith Gear", "Gear" },
            { "Bronzesmith", "Settlement Locations" },

            { "Allison Watcher", "Monster Figurine" },
            { "Allison Watcher Info", "AI" },
            { "Allison Watcher Basic Action", "AI" },
            { "Allison Watcher Basic AI", "AI" },
            { "Allison Watcher Special AI", "AI" },
            { "Allison Watcher Hit Locations", "Hit Locations" },
        },
    },

    monsters = {
        {
            name = "Allison",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Allison The Twilight Knight Rules", 4 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(10, 6.5)", "(11.5, 5)", "(13, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Mineral Vein",
                    positions = { "(12, 4)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        basic = 8,
                        advanced = 4,
                        movement = 6,
                        toughness = 10,
                        starting = {
                            special = { "Will to Survive", "Deadly Invitation", "Out of Your League", "Armored Veteran" }
                        }

                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        basic = 8,
                        advanced = 5,
                        legendary = 1,
                        movement = 8,
                        toughness = 12,
                        speed = 1,
                        damage = 1,
                        accuracy = 1,
                        starting = {
                            special = { "Will to Survive", "Deadly Invitation", "Out of Your League", "Armored Veteran" }
                        }

                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        basic = 9,
                        advanced = 6,
                        legendary = 2,
                        movement = 9,
                        toughness = 13,
                        speed = 1,
                        damage = 1,
                        accuracy = 2,
                        luck = 1,
                        starting = {
                            special = { "Will to Survive", "Deadly Invitation", "Out of Your League", "Armored Veteran" },
                            misc = { "Indomitable" },
                        }

                    },
                },
                {
                    name = "Level 4",
                    level = 4,
                    showdown = {
                        basic = 10,
                        advanced = 8,
                        legendary = 2,
                        movement = 9,
                        toughness = 15,
                        speed = 2,
                        damage = 2,
                        accuracy = 3,
                        luck = 2,
                        starting = {
                            special = { "Will to Survive", "Deadly Invitation", "Out of Your League", "Armored Veteran", "Twilight of Nothingness" },
                            misc = { "Indomitable" },
                        }
                    },
                },
            },

        },
        {
            name = "Allison Watcher",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Allison The Twilight Knight Rules", 9 },
            resourcesDeck = false,
            advancedAiDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(7, 4)", "(16, 4)", "(7, 13)", "(16, 13)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Retinue", "Retinue", "Retinue", "Retinue" },
                        starting = {
                            special = { "Audience", "Lantern Vortex", "Vapor of Nothingness", "Horripilation", "Insatiable", "Unyielding" },
                            misc = { "Indomitable" },
                        },
                        basic = 12,
                        life = 25,
                        movement = 0,
                        toughness = 20,
                    },
                },
            },
        },
    },
}
end)
__bundle_register("Kdm/Expansion/DrifterKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Drifter Knight",

    guidNames = { ["03f444"] =  "Drifter Knight Archive" },

    components = {
        ["Fighting Arts"] = "Drifter Knight Fighting Arts",
        ["Secret Fighting Arts"] = "Drifting Dance",
        ["Terrain Tiles"] = {"Living Coral","Dead Coral","Tidal Pool"},
        ["Terrain"] = "Drifter Knight Terrain",
        ["Innovations"] = "Drifter Knight Innovations",
        ["Settlement Locations"] = "Jellyfish Apothecary", 
        ["Rare Gear"] = "Drifter Knight Rare Gear",
        ["Disorders"] = "Drifter Knight Disorders",
        ["Strange Resources"] = "Drifter Knight Strange Resources",
        ["Settlement Events"] = "Drifter Knight Settlement Events",
        ["Tactics"] = "Drifter Knight Tactics",

    },

    settlementEvents = {
        "Morbid Fog Bank",
        "Ghostly Carrion",
    },

    timelineEvents = {
        { year = 8, name = "A Parade Of Ghosts", type = "RulebookEvent"  },
    },

    terrain = {
        ["Living Coral"] = { terrainTile = "Living Coral", count = 3 },
        ["Dead Coral"]   = { terrainTile = "Dead Coral", count = 3 },
        ["Tidal Pool"]   = { terrainTile = "Tidal Pool", count = 1 },
    },

    terrainTileSizes = {
        ["Living Coral"] = { x = 1, y = 1 },
        ["Dead Coral"]   = { x = 1, y = 1 },
        ["Tidal Pool"]   = { x = 2, y = 2 },
    },

    settlementLocationGear = {
        ["Jellyfish Apothecary"] = "Jellyfish Apothecary Gear",
    },


    armorStats = {
        ["Drifting Aegis"]      = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Ghostly Sleeves"]     = { head = 0, arms = 3, body = 0, waist = 0, legs = 0 },
        ["Pearlescent Guards"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 3 },
    },

    weaponStats = {
        ["Naginata"]      = { speed = 2, accuracy = 6, strength = 6, deadly = 1 },
        ["Iron Parasol"]  = { speed = 1, accuracy = 6, strength = 5 },
    },

    rulebooks = {
        {
            name = "Drifter Knight Rules",
            pages = {
                ["Drifter Knight Rules"] = {
                    keywords = { "Drifter", "Knight", "Rules" },
                    state = 1,
                },
                ["A Parade Of Ghosts"] = {
                    keywords = { "A", "Parade", "Of", "Ghosts" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Show Me Your Motivation"] = {
                    keywords = { "Show", "Me", "Your", "Motivation" },
                    state = 4,
                },
                ["Showdown: Drifter Knight"] = {
                    keywords = { "Showdown:", "Drifter", "Knight" },
                    state = 5,
                    showdown = true,
                },

            },
        },
    },

    archiveEntries = {
        archive = "Drifter Knight Archive",
        entries = {
            { "Drifter Knight Rules", "Rulebook" },
            { "Drifter Knight Rare Gear", "Gear" },
            { "Drifter Knight", "Monster Figurine" },
            { "Drifter Knight Strange Resources", "Strange Resources" },
            { "Drifter Knight Hit Locations", "Hit Locations" },
            { "Drifter Knight Disorders", "Disorders" },
            { "Drifting Dance", "Secret Fighting Arts" },
            { "Drifter Knight Settlement Events", "Settlement Events" },
            { "Drifter Knight Tactics", "Tactics"},
            { "Drifter Knight Resources", "Monster Resources" },
            { "Jellyfish Apothecary", "Settlement Locations" },
            { "Jellyfish Apothecary Gear", "Gear" }, 
            { "Drifter Knight Fighting Arts", "Fighting Arts" },

            { "Drifter Knight Hunt Events", "Monster Hunt Events" },

            { "Drifter Knight Innovations", "Innovations" },

            { "Drifter Knight Terrain", "Terrain"},
            
            { "Dead Coral", "Terrain Tiles" },
            { "Living Coral", "Terrain Tiles" },
            { "Tidal Pool", "Terrain Tiles" },
            
            { "Drifter Knight Special AI", "AI" },
            { "Drifter Knight Info", "AI" }, 
            { "Drifter Knight Basic Action", "AI" },
            { "Drifter Knight Basic AI", "AI" },
            { "Drifter Knight Advanced AI", "AI" },
            { "Drifter Knight Legendary AI", "AI" },
        },
    },

    monsters = {
        {
            name = "Drifter Knight",
            size = { x = 2, y = 2 },
            rules = { "Drifter Knight Rules", 5 },
            huntTrack = { "H", "M", "H", "H", "M", "O", "M", "H", "M", "H", "H" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            specialTerrain = {
                {
                    terrainTile = "Tidal Pool",
                    position = "(11.5, 8.5)",
                    rotation = { x = 0, y = 0, z = 0 },
                },
            },
            fixedTerrain = {
                {
                    terrain = "Living Coral",
                    positions = { "(7, 9)", "(7, 8)", "(11, 4)", "(12, 4)", "(16, 8)", "(16, 9)" },
                    rotations = { { x = 0, y = 180, z = 180 }, { x = 0, y = 180, z = 180 }, { x = 0, y = 180, z = 180 }, { x = 0, y = 180, z = 180 }, { x = 0, y = 180, z = 180 }, { x = 0, y = 180, z = 180 } },
                },
            },
            unfixedTerrain = { "Dead Coral", "Tidal Pool" },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 5,
                    showdown = {
                        basic  = 7,
                        advanced = 4,
                        starting = {
                            special = { "Hook And Reel", "Aimless Drifting", "Blood Tide", "Shame", "Internal Toxicity" },
                        },
                        movement = 8,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic  = 10,
                        advanced = 5,
                        legendary = 1,
                        starting = {
                            special = { "Hook And Reel", "Aimless Drifting", "Blood Tide", "Shame", "Corrosive Venom", "Internal Toxicity" },
                        },
                        movement = 12,
                        toughness = 12,
                        damage = 1,
                        speed = 1,
                        accuracy = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 10,
                    showdown = {
                        basic  = 10,
                        advanced = 7,
                        legendary = 2,
                        starting = {
                            special = { "Hook And Reel", "Aimless Drifting", "Blood Tide", "Shame", "Corrosive Venom", "Indomitable", "Total Eclipse", "Internal Toxicity" },
                        },
                        movement = 14,
                        toughness = 14,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            }
        },
    },
    --things left to finish: Drifter Knight Info card
}





    



        
        
    
    
    
    
    


    
    























--}
end)
__bundle_register("Kdm/Expansion/KingsCoin", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "King's Coin",

    guidNames = { ["34781f"] =  "King's Coin Archive" },

    components = {
        ["Rare Gear"] = "King's Coin Rare Gear",
        ["Abilities"] = "Master Of The Curse",
        ["Strange Resources"] = "King's Coin Strange Resources",
        ["Disorders"] = "Miserly",
        ["Terrain"] = "King's Coin Terrain",
        ["Terrain Tiles"] = { "Shiny Somethings", "King's Merchant" },
        ["Settlement Events"] = "King's Merchant",
        ["Settlement Locations"] = "The Emporium",
        ["Hunt Events"] = "Fragrant Smog",
    },

    archiveOverrides = {
        newArchive = "King's Coin Archive",
        oldArchive = "Core Archive",
        entries = {
        --{ "King's Man Special AI", "AI" },
        { "The Hand Special AI", "AI" },
        --{ "King's Man Hit Locations", "Hit Locations" },
        --{ "Core Rare Gear", "Gear" },
        --{ "Core Rules", "Rulebook" },
        }
    },

    settlementEvents = {
        "King's Merchant",
    },

    terrain = {
        ["Shiny Somethings"] = { terrainTile = "Shiny Somethings", count = 1 },
        ["King's Merchant"] = { terrainTile = "King's Merchant", count = 1 },
    },

    terrainTileSizes = {
        ["Shiny Somethings"] = { x = 1, y = 1 },
        ["King's Merchant"] = { x = 3, y = 2 },
    },

    settlementLocationGear = {
        ["The Emporium"] = "King's Coin Gear",
    },

    armorStats = {
        ["Gilded Crown"]            = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Acid Stained Shield"]     = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Regal Helm (KC)"]         = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Regal Plackart (KC)"]     = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Regal Gauntlets (KC)"]    = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Regal Greaves (KC)"]      = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },
        ["Regal Faulds (KC)"]       = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
    },

    weaponStats = {
        ["Carving Knife"]            = { speed = 2, accuracy = 6, strength = 4 },
        ["Horned Shield"]            = { speed = 1, accuracy = 4, strength = 6 },
        ["Diversion Blade"]          = { speed = 2, accuracy = 7, strength = 5, savage = true },
        ["Spiderbite Daggers"]       = { speed = 4, accuracy = 7, strength = 4 },
        ["Shortbow"]                 = { speed = 2, accuracy = 6, strength = 8 },
        ["Stone Hammer"]             = { speed = 2, accuracy = 5, strength = 7 },
        ["Dagger Of Denial"]         = { speed = 2, accuracy = 6, strength = 5 },
        ["Exotic Saber"]             = { speed = 3, accuracy = 5, strength = 5, sharp = true },
        ["Acid Stained Shield"]      = { speed = 2, accuracy = 6, strength = 4, deadly = 1 },
    },

    archiveEntries = {
        archive = "King's Coin Archive",
        entries = {
            { "King's Coin Rules", "Rulebook" },
            { "Miserly", "Disorders" },
            { "Master Of The Curse", "Abilities" },
            { "King's Coin Strange Resources", "Strange Resources" },
            { "King's Coin Terrain", "Terrain" },
            { "King's Merchant", "Terrain Tiles" },
            { "Shiny Somethings", "Terrain Tiles" },
            { "King's Coin Rare Gear", "Gear" },
            { "King's Coin Gear", "Gear" },
            { "Fragrant Smog", "Hunt Events" },
            { "King's Merchant", "Settlement Events" },
            { "The Emporium", "Settlement Locations" },

            { "King's Man (KC) Hit Locations", "Hit Locations" },
            { "King's Man (KC) Special AI", "AI" },
            { "King's Man (KC) Advanced AI", "AI" },
            { "King's Man (KC) Basic AI", "AI" },
            { "King's Man (KC) Info", "AI" },
            { "King's Man (KC)", "Monster Figurine"},
            { "King's Man (KC) Basic Action", "AI" },


        },
    },

    monsters = {
        {
            name = "King's Man (KC)",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "King's Coin Rules", 2 },
            resourcesDeck = false,
            legendaryAiDeck = "Familiar Face",
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(10, 6.5)", "(11.5, 4)", "(13, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            unfixedTerrain = { "Shiny Somethings", "2 Cowering Survivors", "King's Merchant" },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting" },
                        },
                        basic = 10,
                        advanced = 2,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 5,
                        toughness = 12,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting", "Silent Hymn", "Ensemble" },
                        },
                        basic = 11,
                        advanced = 4,
                        legendary = 1,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 6,
                        toughness = 15,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting", "Silent Hymn", "Ensemble" },
                            misc = { "Indomitable" },
                        },
                        basic = 12,
                        advanced = 6,
                        legendary = 1,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 6,
                        toughness = 18,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            },
        },
    },

    rulebooks = {
        {
            name  = "King's Coin Rules",
            pages = {
                ["King's Coin Rules"] = {
                    keywords = { "King's","Coin","Rules" },
                    state = 1,
                },

                ["Showdown: King's Man (KC)"] = {
                    keywords = { "Showdown:","King's","Man","KC" },
                    state = 2,
                    showdown = true,
                },

                ["Highway Robbery"] = {
                    keywords = { "Highway","Robbery" },
                    state = 3,
                },
            },
        },
    }
}
end)
__bundle_register("Kdm/Expansion/StormKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Storm Knight",

    guidNames = { ["3ca3a1"] =  "Storm Knight Archive" },

    components = {
        ["Rare Gear"] = "Storm Knight Rare Gear",
        ["Strange Resources"] = "Metal Face",
        ["Disorders"] = "Storm Knight Disorders",
        ["Terrain"] = "Storm Knight Terrain",
        ["Terrain Tiles"] = { "Lightning Rod", "Forsaken Fog" },
        ["Secret Fighting Arts"] = "Storm Knight Secret Fighting Arts",
        ["Settlement Events"] = "Storm Knight Settlement Events",
        ["Tactics"] = "Storm Knight Tactics",
        ["Innovations"] = "Rain Cloud Pipe",
        ["Armor Sets"] = "Michishio Armor",
    },

    settlementEvents = {
        "Wandering Master",
        "Beats Of The Hammer",
    },

    removeTimelineEvent = { year = 11, name = "Regal Visit" },
    replaceNemesis = { nemesis = "The Hand", replacement = "Storm Knight" },
    timelineEvents = {
        { year = 11, name = "Looming Storm", type = "RulebookEvent" },
    },

    
    terrain = {
        ["2 Lightning Rods"] = { terrainTile = "Lightning Rod", count = 2 },
        ["Forsaken Fog"] = { terrainTile = "Forsaken Fog", count = 1 },
    },

    terrainTileSizes = {
        ["Lightning Rod"] = { x = 1, y = 1 },
        ["Forsaken Fog"] = { x = 2, y = 2 },
    },

    armorStats = {
        ["Michishio Armor"]  = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Storm Helmet"]     = { head = 5, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Storm Mantle"]     = { head = 0, arms = 1, body = 1, waist = 0, legs = 0 },
        ["Mist Raven Obi"]   = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
    },

    weaponStats = {
        ["Lightning Rod"]    = { speed = 2, accuracy = 6, strength = 6 },
        ["Inazuma"]          = { speed = 4, accuracy = 4, strength = 0 },
        ["Fulgurite Stone"]  = { speed = 2, accuracy = 7, strength = 1 },
        ["Bone Katana"]   = { speed = 3, accuracy = 6, strength = 3, deadly = 1 },
    },


    rulebooks = {
        {
            name = "Storm Knight Rules",
            pages = {
                ["Storm Knight Rules"] = {
                    keywords = {"Storm", "Knight", "Rules"},
                    state = 1,
                },
                ["Looming Storm"] = {
                    keywords = {"Looming", "Storm"},
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Storm Knight"] = {
                    keywords = {"Showndown:", "Storm", "Knight"},
                    state = 3,
                    showdown = true,
                },
                ["Aftermath"] = {
                    keywords = {"Aftermath"},
                    state = 4,
                },
                ["Ill-Fated Circumstance"] = {
                    keywords = {"Ill", "Fated", "Circumstance"},
                    state = 5,
                    timelineEvent = true,
                },
                ["Rise to the Challenge"] = {
                    keywords = {"Rise", "to", "the", "Challenge"},
                    state = 6,
                    timelineEvent = true,
                },
                ["Showdown: Storm Knight Level 3"] = {
                    keywords = {"Showdown:", "Storm", "Knight", "Level", "3"},
                    state = 7,
                    showdown = true,
                },
                ["Storm Break"] = {
                    keywords = { "Storm", "Break"},
                    state = 8,
                },
                ["Storm Dancer Rules"] = {
                    keywords = { "Storm", "Dancer", "Rules" },
                    state = 9,
                },
                ["Showdown: Storm Dancer"] = {
                    keywords = { "Showdown", "Storm", "Dancer" },
                    state = 10,
                    showdown = true,
                },
            },
        },
    },

    archiveEntries = {
        archive = "Storm Knight Archive",
        entries = {
            { "Storm Knight Rules", "Rulebook" },
            { "Storm Knight Rare Gear", "Gear" },
            { "Storm Knight", "Monster Figurine" },
            { "Metal Face", "Strange Resources" },
            { "Storm Knight Hit Locations", "Hit Locations" },
            { "Storm Knight Disorders", "Disorders" },
            { "Storm Knight Secret Fighting Arts", "Secret Fighting Arts" },
            { "Storm Knight Settlement Events", "Settlement Events" },
            { "Storm Knight Tactics", "Tactics"},

            { "Storm Knight Terrain", "Terrain"},
            { "Lightning Rod", "Terrain Tiles" },
            { "Forsaken Fog", "Terrain Tiles" },
            
            { "Storm Knight Special AI", "AI" },
            { "Storm Knight Info", "AI" },
            { "Storm Knight Basic Action", "AI" },
            { "Storm Knight Basic AI", "AI" },
            { "Storm Knight Advanced AI", "AI" },
            { "Storm Knight Legendary AI", "AI" },

            { "Storm Dancer Resources", "Monster Resources" },
            { "Storm Dancer Special AI", "AI" },
            { "Storm Dancer Info", "AI" },
            { "Storm Dancer Basic Action", "AI" },
            { "Storm Dancer Basic AI", "AI" },
            { "Storm Dancer Advanced AI", "AI" },
            { "Storm Dancer Legendary AI", "AI" },
            { "Storm Dancer Hit Locations", "Hit Locations" },
            { "Storm Dancer", "Monster Figurine" },
            { "Rain Cloud Pipe", "Innovations" },
            { "Michishio Armor", "Armor Sets" },
        },
    },

    monsters = {
        {
            name = "Storm Knight",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Storm Knight Rules", 3 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        basic = 8,
                        advanced = 2,
                        movement = 8,
                        toughness = 11,
                        starting = {
                            special = { "Charged", "Cloud Walk", "Static Shield", "Stormy Temper", "Electrical Current" }
                        },
                        fixedTerrain = {
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(7, 8.5)", "(11.5, 4)", "(16, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z= 0 } },
                            },
                        },

                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        basic = 11,
                        advanced = 4,
                        movement = 8,
                        toughness = 14,
                        speed = 1,
                        damage = 1,
                        accuracy = 1,
                        luck = 1,
                        starting = {
                            special = { "Charged", "Cloud Walk", "Static Shield", "Stormy Temper", "Electrical Current" }
                        },
                        fixedTerrain = {
                            {
                                terrain   = "Bug Patch",
                                positions = { "(12, 3)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain   = "2 Acanthus Plants",
                                positions = { "(6, 8)", "(17, 8)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain   = "3 Stone Columns",
                                positions = { "(7, 8.5)", "(11.5, 4)", "(16, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z= 0 } },
                            },
                            {
                                terrain  = "Forsaken Fog",
                                position = "(11.5, 8.5)",
                                rotation = { x = 0, y = 0, z = 0 },
                            },

                        },
                        
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        basic = 11,
                        advanced = 7,
                        legendary = 3,
                        movement = 10,
                        toughness = 16,
                        speed = 2,
                        damage = 2,
                        accuracy = 3,
                        luck = 2,
                        starting = {
                            special = { "Charged", "Three Faced", "Cloud Walk", "Static Shield", "Stormy Temper", "Electrical Current", "Storm Clouds" },
                        },
                        fixedTerrain = {

                            {
                                terrain = "Toppled Pillar",
                                positions = { "(7, 8.5)", "(16, 8.5)" },
                                rotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } },
                            },

                            {
                                terrain   = "2 Lightning Rods",
                                positions = { "(7, 6)", "(16, 6)" }, 
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },

                            },

                            {
                                terrain   = "2 Lightning Rods",
                                positions = { "(7, 11)", "(16, 11)" }, 
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },

                            },
            
                            {
                                terrain  = "Forsaken Fog",
                                position = "(11.5, 8.5)",
                                rotation = { x = 0, y = 0, z = 0 },
                            },
                        
                        },
                        
                    },
                },
            },
        },
        {
            name = "Storm Dancer",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Storm Knight Rules", 10 },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } },
            levels = {
                {
                    name = "Level 4",
                    level = 4,
                    showdown = {
                        basic = 7,
                        advanced = 7,
                        legendary = 4,
                        movement = 13,
                        toughness = 16,
                        speed = 4,
                        damage = 3,
                        evasion = 2,
                        accuracy = 3,
                        luck = 3,
                        starting = {
                            special = { "Charged", "Spirited Away", "Hook And Reel", "Stormy Temper", "Static Shawl", "Total Eclipse", "Internal Toxicity", "Corrosive Venom", "Noxious Waltz" }
                        },
                        fixedTerrain = {
                            {
                                terrain = "Hovel",
                                positions = { "(6.5, 6.5)", "(16.5, 6.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "2 Cowering Survivors",
                                positions = { "(6, 5)", "(17, 5)"},
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                            },
                            {
                                terrain  = "Forsaken Fog",
                                position = "(11.5, 8.5)",
                                rotation = { x = 0, y = 0, z = 0 },
                            },
                        },
                    },

                },
            }, 
      
        },
    },
    --Fix Storm Dancer Info card
}


    

end)
__bundle_register("Kdm/Expansion/ForsakerSisters", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Forsaker Sisters",

    guidNames = { ["271f3a"] =  "Forsaker Sisters Archive" },

    components = {
        ["Patterns"] = "Forsaker Sisters Patterns",
        ["Rare Gear"] = "Forsaker Sisters Rare Gear",
        ["Strange Resources"] = "Forsaker Sisters Strange Resources",
        ["Disorders"] = "Forsaker Sisters Disorders",
        ["Secret Fighting Arts"] = "Forsaker Sisters Secret Fighting Arts",
    },

    archiveOverrides = {
        newArchive = "Forsaker Sisters Archive",
        oldArchive = "Core Archive",
        entries = {
        { "Core Settlement Events", "Settlement Events" },
        }
    },

    removeTimelineEvent = { year = 6, name = "Armored Strangers" },
    replaceNemesis = { nemesis = "King's Man", replacement = "Forsaker Sisters" },
    timelineEvents = {
        { year = 6, name = "Air of Dominance", type = "RulebookEvent" },
    },

    weaponStats = {
        ["Pig Iron Blade"]    = { speed = 3, accuracy = 6, strength = 3 },
        ["Pig Iron Polearm"]  = { speed = 1, accuracy = 4, strength = 7 },
    },

    armorStats = {
        ["Forsaker Veil"]     = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    archiveEntries = {
        archive = "Forsaker Sisters Archive",
        entries = {
            { "Forsaker Sisters Rules", "Rulebook" },
            { "Forsaker Sisters Patterns", "Patterns" },
            { "Forsaker Sisters Rare Gear", "Gear" },
            { "Forsaker Sisters", "Monster Figurine" },
            { "Forsaker Sisters Strange Resources", "Strange Resources" },
            { "Forsaker Sisters Hit Locations", "Hit Locations" },
            { "Forsaker Sisters Disorders", "Disorders" },
            { "Forsaker Sisters Secret Fighting Arts", "Secret Fighting Arts" },

            { "Forsaker Sisters Special AI", "AI" },
            { "Forsaker Sisters Info", "AI" },
            { "Forsaker Sisters Basic Action", "AI" },
            { "Forsaker Sisters Basic AI", "AI" },
            { "Forsaker Sisters Advanced AI", "AI" },
            { "Forsaker Sisters Legendary AI", "AI" },
        }
    },

    rulebooks = {
        {
            name = "Forsaker Sisters Rules",
            pages = {
                ["Forsaker Sisters Rules"] = {
                    keywords = { "Forsaker", "Sisters", "Rules"},
                    state = 1,
                },
                ["Air of Dominance"] = {
                    keywords = { "Air", "of", "Dominance"},
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Forsaker Sisters"] = {
                    keywords = { "Showndown:", "Forsaker", "Sisters"},
                    state = 3,
                    showdown = true,
                },
                ["Darkest Desires"] = {
                    keywords = { "Darkest", "Desires"},
                    state = 4,
                },
                ["Childhood's End"] = {
                    keywords = { "Childhood's", "End"},
                    state = 5,
                },
            },
        },
    },

    monsters = {
        {
            name = "Forsaker Sisters",
            nemesis = true,
            size = { x = 1, y = 1 },
            rules = { "Forsaker Sisters Rules", 3 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            playerRotations = { { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "Hovel",
                    positions = { "(5.5, 6.5)", "(17.5, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                },
                {
                    terrain = "2 Cowering Survivors",
                    positions = { "(5, 5)", "(18, 5)"},
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }},
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        basic = 5,
                        advanced = 4,
                        movement = 7,
                        toughness = 10,
                        starting = {
                            special = {"Blood Relative", "Dreaded Trophies", "Revenge", "No Mercy For The Weak"}
                        }

                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        basic = 5,
                        advanced = 4,
                        legendary = 1,
                        movement = 7,
                        toughness = 14,
                        speed = 1,
                        damage = 1,
                        accuracy = 1,
                        evasion = 1,
                        starting = {
                            special = {"Blood Relative", "Dreaded Trophies", "Revenge", "No Mercy For The Weak", "Love Scorned"}
                        }

                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy" },
                        basic = 7,
                        advanced = 4,
                        legendary = 2,
                        movement = 9,
                        toughness = 17,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                        evasion = 2,
                        starting = {
                            special = {"Blood Relative", "Dreaded Trophies", "Revenge", "No Mercy For The Weak", "Love Scorned" },
                            misc = { "Indomitable" },
                        }

                    },
                },
            },
        },
    },
    --Pull out patern cards from this archive and create archive chest for all Pattern Gear Cards
}
end)
__bundle_register("Kdm/Expansion/CcgHomebrew", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "CCG Homebrew",

    guidNames = { ["4e869d"] =  "CCG Homebrew Archive" },

    components = {
        ["Abilities"] = "CCG Abilities",
        ["Armor Sets"] = "CCG Armor Sets",
        ["Settlement Locations"] = "CCG Settlement Locations",
        ["Vermin"] = "CCG Vermin",
        ["Hunt Events"] = "CCG Hunt Events",
        ["Rare Gear"] = "CCG Rare Gear",
        ["Settlement Events"] = "CCG Settlement Events",
        ["Innovations"] = "Gore Farming",
        ["Strange Resources"] = "Gore Silk",
        ["Bookmarks"] = "CCG Bookmarks",

        ["Secret Fighting Arts"] = "Black Guard Style",
    },

    settlementEvents = {
        "Cries in the Distance",
        "Night Raid",
        "Prisoners",
        "A Series of Unfortunate Events",
        "Savage Bone Eater",
        "Hunt Reprisal",
        "Rumor Mill",
        "Vivid Dreams",
        "Talking Faces",
        "Death of an Elder",
        "Gore Silk",
        "Fresh Tracks",
        "Structural Collapse",
        "Ceremony",
        "Sick Monster",
        "A Stranger's Sojourn",
        "The Unblemished Man",
        "The Potion Maker",
        "Strange Twins",
        "Sedition of a Settlement",
        "Curious Twilight Knight",
        "Messenger of the First Story",
        "Messenger of Courage",
        "Messenger of the Spiral Path",
        "Messenger of Humanity",
        "Sword Hunter", --Gets added to archive after "Sword in the Stone" hunt event manually
        "A Strange Spot",
    },

    timelineEvents = {
        { year = 1, name = "Bloodied Victors", type = "RulebookEvent" },
        { year = 3, name = "Fresh Meat", type = "RulebookEvent" },
    },

    settlementLocationGear = {
        ["Bone Lodge"] = "Bone Lodge Gear",
        ["Explorer's Shelter"] = "Explorer's Shelter Gear",
    },

    armorStats = {
        ["Acanthus Armor"]        = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
        ["Acanthus Cowl"]         = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Acanthus Vest"]         = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },
        ["Acanthus Tabis"]        = { head = 0, arms = 0, body = 0, waist = 0, legs = 1 },
        ["Acanthus Wraps"]        = { head = 0, arms = 1, body = 0, waist = 0, legs = 0 },
        ["Acanthus Cloak"]        = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },
        ["Acanthus Veil"]         = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Acanthus Sash"]         = { head = 0, arms = 0, body = 0, waist = 1, legs = 0 },
        
        -- Bone Lodge Armor Set
        ["Bone Armor"]            = { head = 0, arms = 0, body = 0, waist = 0, legs = 0, modifier = true },
        ["Bone Buckler"]          = { head = 0, arms = 1, body = 0, waist = 0, legs = 0 },
        ["Bone Mail"]             = { head = 0, arms = 0, body = 2, waist = 2, legs = 0 },
        ["Bone Greaves"]          = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },
        ["Bone Helmet"]           = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Bone Armguards"]        = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },

        ["Lantern Mantle"]         = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["CCG Centipede Claw"]     = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Big Bone Blade"]            = { speed = 1, accuracy = 5, strength = 4, deadly = 1 },
        ["Big Bone Blade (Broken)"]   = { speed = 1, accuracy = 5, strength = 3 },
        ["Bone Scythe"]               = { speed = 2, accuracy = 7, strength = 1 },
        ["Bone Hatchet"]              = { speed = 1, accuracy = 6, strength = 3, paired = true },
        ["Bone Spear"]                = { speed = 1, accuracy = 5, strength = 2 },
        ["Bone Buckler"]              = { speed = 1, accuracy = 6, strength = 1 },
        ["Scrap Knuckles"]            = { speed = 2, accuracy = 7, strength = 2 },
        ["Scrap Darts"]               = { speed = 2, accuracy = 7, strength = 4, savage = 1 },
        ["Skull Club"]                = { speed = 2, accuracy = 7, strength = 2 },

        ["Acanthus Shield"]           = { speed = 1, accuracy = 8, strength = 1 },
        ["Acanthus Bow"]              = { speed = 3, accuracy = 8, strength = 2 },
        ["Acanthus Maul"]             = { speed = 2, accuracy = 7, strength = 3 },
        ["Acanthus Whip"]             = { speed = 2, accuracy = 7, strength = 2 },

        ["CCG Centipede Claw"]        = { speed = 2, accuracy = 6, strength = 3, sharp = true },
    },

    archiveEntries = {
        archive = "CCG Homebrew Archive",
        entries = {
            { "CCG Rules", "Rulebook" },
            { "CCG Settlement Locations", "Settlement Locations" },
            { "Bone Lodge Gear", "Gear" },
            { "Explorer's Shelter Gear", "Gear" },
            { "CCG Rare Gear", "Gear" },
            { "CCG Abilities", "Abilities" },
            { "CCG Armor Sets", "Armor Sets" },
            { "CCG Vermin", "Vermin"},
            { "CCG Hunt Events", "Hunt Events" },

            { "CCG Settlement Events", "Settlement Events" },
            { "Gore Silk", "Strange Resources" },
            { "Gore Farming", "Innovations" },
            { "CCG Bookmarks", "Bookmarks" },

            { "Black Guard Style", "Secret Fighting Arts" },
        }
    },

    rulebooks = {
        {
            name = "CCG Rules",
            pages = {
                ["CCG Rules"] = {
                    keywords = { "CCG", "Rules" },
                    state = 1,
                },
                ["Bloodied Victors"] = {
                    keywords = { "Bloodied", "Victors" },
                    state = 2,
                    timelineEvent = true,
                },
                ["CCG Principle: Death"] = {
                    keywords = { "CCG", "Principle:", "Death" },
                    state = 3,
                },
                ["CCG Principle: Death CE"] = {
                    keywords = { "CCG", "Principle:", "Death", "CE" },
                    state = 4,
                },
                ["Overharvest"] = {
                    keywords = { "Overharvest" },
                    state = 5,
                },
                ["Fresh Meat"] = {
                    keywords = { "Fresh", "Meat" },
                    state = 6,
                    timelineEvent = true,
                },
                
            },
        },
    },
}
end)
__bundle_register("Kdm/Expansion/Sunstalker", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Sunstalker",

    components = {
        ["Abilities"] = "Sunstalker Abilities",
        ["Fighting Arts"] = "Sunstalker Fighting Arts",
        ["Secret Fighting Arts"] = "Sunstalker Secret Fighting Arts",
        ["Disorders"] = "Sunstalker Disorders",
        ["Weapon Proficiencies"] = "Katana Proficiency",
        ["Armor Sets"] = "Cycloid Scale Armor",
        ["Strange Resources"] = "Sunstalker Strange Resources",
        ["Terrain"] = "2 Salt Sculptures",
        ["Terrain Tiles"] = { "Salt Sculpture" },
        ["Innovations"] = "Sunstalker Innovations",
        ["Rare Gear"] = "Sunstalker Rare Gear",
        ["Settlement Locations"] = "Sunstalker Settlement Locations",
    },

    campaigns = {
        {
            name = "People of the Sun",
            years = 25,
            timeline = {
                { year = 1, type = "RulebookEvent", name = "The Pool and the Sun" },
                { year = 2, type = "RulebookEvent", name = "Endless Screams" },
                { year = 4, type = "RulebookEvent", name = "Sun Dipping" },
                { year = 5, type = "RulebookEvent", name = "The Great Sky Gift" },
                { year = 7, type = "RulebookEvent", name = "Phoenix Feather" },
                { year = 10, type = "RulebookEvent", name = "Birth of Color" },
                { year = 11, type = "RulebookEvent", name = "Principle: Conviction" },
                { year = 12, type = "RulebookEvent", name = "Sun Dipping" },
                { year = 13, type = "RulebookEvent", name = "The Great Sky Gift" },
                { year = 19, type = "RulebookEvent", name = "Sun Dipping" },
                { year = 20, type = "RulebookEvent", name = "Final Gift" },
                { year = 21, type = "ShowdownEvent", monster = "King's Man", level = "Level 2" },
                { year = 22, type = "ShowdownEvent", monster = "Butcher", level = "Level 3" },
                { year = 23, type = "ShowdownEvent", monster = "King's Man", level = "Level 3" },
                { year = 24, type = "ShowdownEvent", monster = "The Hand", level = "Level 3" },
                { year = 25, type = "RulebookEvent", name = "The Great Devourer" },
            },
            survivalActions = {
                { name = "Dodge", checked = true },
                { name = "Embolden", checked = false },
                { name = "Dash", checked = false },
                { name = "Overcharge", checked = false },
            },
            milestones = {
                { name = "First Death", event = "Principle: Death" },
                { name = "15 Population", event = "Principle: Society" },
                { name = "8 Innovations", event = "Edged Tonometry" },
            },
            objectsByLocation = {
                ["Innovation Deck"] = { tag = "Deck", name = "Innovation Deck", type = "Innovations", faceDown = true, cards = {
                    { name = "Ammonia - Language Consequence", type = "Innovations" },
                    { name = "Drums - Language Consequence", type = "Innovations" },
                    { name = "Hovel - Language Consequence", type = "Innovations" },
                    { name = "Hands of the Sun", type = "Innovations" },
                    { name = "Paint - Language Consequence", type = "Innovations" },
                    { name = "Symposium - Language Consequence", type = "Innovations" },
                } },
                ["Principle: Death"] = { tag = "Deck", name = "Principle: Death", type = "Innovations", faceDown = true, cards = {
                    { name = "Cannibalize - Death Principle", type = "Innovations" },
                    { name = "Graves - Death Principle", type = "Innovations" },
                } },
                ["Principle: Society"] = { tag = "Deck", name = "Principle: Society", type = "Innovations", faceDown = true, cards = {
                    { name = "Accept Darkness - Society Principle", type = "Innovations" },
                    { name = "Collective Toil - Society Principle", type = "Innovations" },
                } },
                ["Principle: Conviction"] = { tag = "Deck", name = "Principle: Conviction", type = "Innovations", faceDown = true, cards = {
                    { name = "Barbaric - Conviction Principle", type = "Innovations" },
                    { name = "Romantic - Conviction Principle", type = "Innovations" },
                } },
                ["Innovation 1"] = { tag = "Card", name = "Sun Language", type = "Innovations" },
                ["Principle: New Life"] = { tag = "Card", name = "Survival of the Fittest - New Life Principle", type = "Innovations" },
                ["Settlement Location 1"] = { tag = "Card", name = "The Sun", type = "Settlement Locations" },
                ["Settlement Location 2"] = { tag = "Card", name = "Sacred Pool", type = "Settlement Locations" },
            },
            references = {
                { name = "Age Reference", location = "Reference 1" },
                { name = "Intimacy (People of the Sun) Reference", location = "Reference 2" },
                { name = "Bold Reference", location = "Reference 3" },
                { name = "Insight Reference", location = "Reference 4" },
            },
            remove = {
                ["Fighting Arts"] = { "Leader" },
                ["Innovation Archive"] = { "Language", "Inner Lantern - Language Consequence" },
            },
            milestoneEvents = {
                ["huntXp"] = {
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 22 },  -- Retired
                },
                ["courage"] = {
                    { rules = "Core Rules", state = 56 },  -- Bold
                    { rules = "Core Rules", state = 83 },  -- See the Truth
                },
                ["understanding"] = {
                    { rules = "Core Rules", state = 65 },  -- Insight
                    { rules = "Core Rules", state = 90 },  -- White Secret
                },
                ["weaponProficiency"] = {
                    { rules = "Core Rules", state = 21 },  -- Specialist
                    { rules = "Core Rules", state = 21 },  -- Master
                },
            },
        },
    },

    timelineEvents = {
        { year = 8, name = "Promise Under the Sun", type = "RulebookEvent", notCampaign = "People of the Sun" },
    },

    terrain = {
        ["2 Salt Sculptures"] = { terrainTile = "Salt Sculpture", count = 2 },
    },

    terrainTileSizes = {
        ["Salt Sculpture"] = { x = 1, y = 2 },
    },

    settlementLocationGear = {
        ["Skyreef Sanctuary"] = "Skyreef Sanctuary Gear",
    },

    armorStats = {
        ["Cycloid Scale Armor"]   = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Cycloid Scale Hood"]    = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Cycloid Scale Sleeves"] = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Cycloid Scale Jacket"]  = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Cycloid Scale Skirt"]   = { head = 0, arms = 0, body = 0, waist = 2, legs = 0 },
        ["Cycloid Scale Shoes"]   = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },
        ["Apostle Crown"]         = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Denticle Axe"]    = { speed = 2, accuracy = 6, strength = 5 },
        ["Ink Blood Bow"]   = { speed = 2, accuracy = 7, strength = 8, deadly = 1 },
        ["Ink Sword"]       = { speed = 4, accuracy = 4, strength = 4, deadly = 3 },
        ["Skleaver"]        = { speed = 1, accuracy = 5, strength = 10 },
        ["Sky Harpoon"]     = { speed = 2, accuracy = 5, strength = 5, savage = true},
        ["Sunshark Arrows"] = { speed = 1, accuracy = 4, strength = 6, sharp = true },
        ["Sunshark Bow"]    = { speed = 3, accuracy = 6, strength = 0, sharp = true },
        ["Sunspot Dart"]    = { speed = 4, accuracy = 7, strength = 3, deadly = 1 },
        ["Prism Mace"]      = { speed = 3, accuracy = 6, strength = 10 },
        ["Sunring Bow"]     = { speed = 2, accuracy = 4, strength = 4 },
    },

    -- locations = {
    --     ["Sun Dial"] = {
    --         name = "Sun Dial",
    --         center = { x = -10.535775, y = 10.801341, z = 0.399195 },
    --         size = { x = 2, y = 2, z = 4 },
    --         board = "Showdown Board",
    --     },
    -- },

    guidNames = { ["2fb312"] = "Sunstalker Archive" },

    archiveEntries = {
        archive = "Sunstalker Archive",
        entries = {
            { "Sunstalker Rules", "Rulebook" },

            { "Intimacy (People of the Sun) Reference", "References"},

            { "Sunstalker Abilities", "Abilities" },
            { "Sunstalker Fighting Arts", "Fighting Arts" },
            { "Sunstalker Secret Fighting Arts", "Secret Fighting Arts" },
            { "Sunstalker Disorders", "Disorders" },
            { "Katana Proficiency", "Weapon Proficiencies" },
            { "Cycloid Scale Armor", "Armor Sets" },
            { "Sunstalker Strange Resources", "Strange Resources" },
            { "Sunstalker Resources", "Monster Resources" },

            { "2 Salt Sculptures", "Terrain" },
            { "Salt Sculpture", "Terrain Tiles" },
            { "Sun Dial", "Terrain Tiles" },

            { "Sunstalker Innovations", "Innovations" },

            { "Sunstalker Settlement Locations", "Settlement Locations" },

            { "Skyreef Sanctuary Gear", "Gear" },
            { "Sunstalker Rare Gear", "Gear" },

            { "Sunstalker", "Monster Figurine" },

            { "Sunstalker Hunt Events", "Monster Hunt Events" },
            { "Sky Fishing", "Special Hunt Events" },

            { "Shades", "Minion Figurine" },
            { "Sunstalker Info", "AI" },
            { "Sunstalker Basic Action", "AI" },
            { "Sunstalker Basic AI", "AI" },
            { "Sunstalker Advanced AI", "AI" },
            { "Sunstalker Legendary AI", "AI" },
            { "Sunstalker Special AI", "AI" },
            { "Sunstalker Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Sunstalker Rules",
            pages = {
                ["Sunstalker Rules"] = {
                    keywords = { "Sunstalker", "Rulebook", "Rules" },
                    state = 1,
                    rules = true
                },
                ["Promise Under the Sun"] = {
                    keywords = { "Promise", "Under", "the", "Sun" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Sunstalker"] = {
                    keywords = { "Showdown:", "Sunstalker" },
                    state = 5,
                    showdown = true,
                },
                ["Conquer Your Shadow"] = {
                    keywords = { "Conquer", "Your", "Shadow" },
                    state = 6,
                },
                ["Sky Fishing"] = {
                    keywords = { "Sky", "Fishing" },
                    state = 7,
                    huntEvent = true,
                },
                ["The Pool and the Sun"] = {
                    keywords = { "Pool", "and", "the", "Sun" },
                    state = 8,
                    timelineEvent = true,
                },
                ["Intimacy (Sunstalker)"] = {
                    keywords = { "Intimacy" },
                    state = 9,
                },
                ["The Great Sky Gift"] = {
                    keywords = { "The", "Great", "Sky", "Gift" },
                    state = 10,
                    timelineEvent = true,
                },
                ["Birth of Color"] = {
                    keywords = { "Birth", "Color" },
                    state = 11,
                    timelineEvent = true,
                },
                ["Final Gift"] = {
                    keywords = { "Final", "Gift" },
                    state = 12,
                    timelineEvent = true,
                },
                ["Umbilical Symbiosis"] = {
                    keywords = { "Umbilical", "Symbiosis" },
                    state = 13,
                },
                ["Edged Tonometry"] = {
                    keywords = { "Edged", "Tonometry" },
                    state = 14,
                    timelineEvent = true,
                },
                ["Sun Dipping"] = {
                    keywords = { "Sun", "Dipping" },
                    state = 15,
                    timelineEvent = true,
                },
                ["Warriors of the Sun"] = {
                    keywords = { "Warriors", "of", "the", "Sun" },
                    state = 16,
                },
                ["The Great Devourer"] = {
                    keywords = { "The", "Great", "Devourer" },
                    state = 17,
                    timelineEvent = true,
                },
            },
        },
    },

    minions = {
        {
            name = "Shade",
            movement = 4,
            size = { x = 1, y = 1 },
        }
    },

    monsters = {
        {
            name = "Sunstalker",
            size = { x = 4, y = 4 },
            rules = { "Sunstalker Rules", 5 },
            huntTrack = { "H", "M", "M", "H", "H", "O", "M", "H", "H", "M", "H" },
            position = "(11.5, 8.5)",
            rotation = { x = 0, y = -90, z = 0 },
            playerPositions = { "(1, 7)", "(1, 8)", "(1, 9)", "(1, 10)" },
            playerRotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 } },
            specialTerrain = {
                {
                    terrainTile = "Sun Dial",
                    position = "(20.5, 8.5)",
                    rotation = { x = 0, y = 180, z = 0 },
                },
            },
            miscObject = { name = "Shades", type = "Minion Figurine" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(3, 3.5)", "(10.5, 3)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 } },
                },
                {
                    terrain = "3 Stone Columns",
                    positions = { "(3, 13.5)", "(10.5, 14)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 } },
                },
                {
                    terrain = "2 Salt Sculptures",
                    positions = { "(18, 5.5)", "(18, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 4,
                    showdown = {
                        basic  = 7,
                        advanced = 2,
                        legendary = 1,
                        starting = {
                            special = { "Solar Energy", "Sun Dial", "Light & Shadow", "Shade", "Shadows of Darkness" },
                        },
                        movement = 16,
                        toughness = 10,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic  = 9,
                        advanced = 5,
                        legendary = 1,
                        starting = {
                            special = { "Solar Energy", "Sun Dial", "Light & Shadow", "Shade", "Shadows of Darkness", "Living Shadows" },
                        },
                        movement = 16,
                        toughness = 12,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic  = 12,
                        advanced = 6,
                        legendary = 2,
                        starting = {
                            special = { "Solar Energy", "Sun Dial", "Light & Shadow", "Shade", "Shadows of Darkness", "Living Shadows", "Monochrome" },
                        },
                        movement = 16,
                        toughness = 16,
                        speed = 2,
                        damage = 2,
                        accuracy = 1,
                        luck = 1,
                    },
                },
                {
                    name = "The Great Devourer",
                    level = 3,
                    showdown = {
                        rules = { "Sunstalker Rules", 17 },
                        basic  = 12,
                        advanced = 6,
                        legendary = 2,
                        starting = {
                            special = { "Solar Energy", "Sun Dial", "Light & Shadow", "Shade", "Shadows of Darkness", "Living Shadows", "Monochrome" },
                        },
                        movement = 16,
                        toughness = 18,
                        speed = 2,
                        damage = 2,
                        accuracy = 1,
                        luck = 2,
                        fixedTerrain = {
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(4, 5.5)", "(11.5, 3)", "(18, 5.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(4, 11.5)", "(11.5, 14)", "(18, 11.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 } },
                            },
                        },
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/Spidicules", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Spidicules",

    components = {
        ["Fighting Arts"] = "Spidicules Fighting Arts",
        ["Secret Fighting Arts"] = "Spidicules Secret Fighting Arts",
        ["Disorders"] = "Spidicules Disorders",
        ["Armor Sets"] = "Silk Armor",
        ["Strange Resources"] = "Spidicules Strange Resources",
        ["Terrain"] = "Spidicules Terrain",
        ["Terrain Tiles"] = { "Egg Sac", "Silk Nest" },
        ["Innovations"] = "Spidicules Innovations",
        ["Settlement Locations"] = "Silk Mill",
        ["Settlement Events"] = "Spidicules Settlement Events",
        ["Rare Gear"] = "Spidicules Rare Gear",
    },

    settlementEvents = {
        "Silk Storm",
    },

    timelineEvents = {
        { year = 2, name = "Young Rivals", type = "RulebookEvent" },
    },

    terrain = {
        ["Egg Sacs"] = {
            terrainTile = "Egg Sac",
            count = "*",
            miscObject = { name = "Spiderling", type = "Minion Figurine" },
        },
        ["Silk Nest"] = { terrainTile = "Silk Nest", count = 1 },
    },

    terrainTileSizes = {
        ["Egg Sac"] = { x = 1, y = 1 },
        ["Silk Nest"] = { x = 2, y = 2 },
    },

    settlementLocationGear = {
        ["Silk Mill"] = "Silk Mill Gear",
    },

    armorStats = {
        ["Silk Armor"]  = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Silk Turban"] = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Silk Wraps"]  = { head = 0, arms = 3, body = 0, waist = 0, legs = 0 },
        ["Silk Robes"]  = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Silk Sash"]   = { head = 0, arms = 0, body = 0, waist = 3, legs = 0 },
        ["Silk Boots"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 3 },
        ["Blue Ring"]   = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Green Ring"]  = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Red Ring"]    = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Amber Edge"]         = { speed = 1, accuracy = 6, strength = 4, slow = true },
        ["Amber Poleaxe"]      = { speed = 2, accuracy = 6, strength = 3 },
        ["Hooded Scrap Katar"] = { speed = 2, accuracy = 7, strength = 4, paired = true },
        ["Silk Whip"]          = { speed = 2, accuracy = 6, strength = 3 },
        ["Thowing Knife"]      = { speed = 4, accuracy = 9, strength = 2 },
        ["Grinning Visage"]    = { speed = 2, accuracy = 7, strength = 4 },
        ["The Weaver"]         = { speed = 3, accuracy = 6, strength = 2 },
        ["Throwing Knife"]     = { speed = 4, accuracy = 9, strength = 2 },
    },

    guidNames = { ["c5735b"] = "Spidicules Archive" },

    archiveEntries = {
        archive = "Spidicules Archive",
        entries = {
            { "Spidicules Rules", "Rulebook" },

            { "Spidicules Fighting Arts", "Fighting Arts" },
            { "Spidicules Secret Fighting Arts", "Secret Fighting Arts" },
            { "Spidicules Disorders", "Disorders" },
            { "Silk Armor", "Armor Sets" },
            { "Spidicules Strange Resources", "Strange Resources" },
            { "Spidicules Terrain", "Terrain" },
            { "Egg Sac", "Terrain Tiles" },
            { "Silk Nest", "Terrain Tiles" },
            { "Spidicules Innovations", "Innovations" },
            { "Silk Mill", "Settlement Locations" },
            { "Spidicules Settlement Events", "Settlement Events" },
            { "Silk Mill Gear", "Gear" },
            { "Spidicules Rare Gear", "Gear" },

            { "Spidicules", "Monster Figurine" },
            { "Spiderling", "Minion Figurine" },
            { "Spidicules Info", "AI" },
            { "Spidicules Basic Action", "AI" },
            { "Spidicules Basic AI", "AI" },
            { "Spidicules Advanced AI", "AI" },
            { "Spidicules Legendary AI", "AI" },
            { "Spidicules Special AI", "AI" },
            { "Spidicules Hit Locations", "Hit Locations" },
            { "Spidicules Hunt Events", "Monster Hunt Events" },
            { "Spidicules Resources", "Monster Resources" },
        },
    },

    rulebooks = {
        {
            name = "Spidicules Rules",
            pages = {
                ["Spidicules Rules"] = {
                    keywords = { "Spidicules", "Rulebook", "Rules" },
                    state = 1,
                },
                ["Young Rivals"] = {
                    keywords = { "Young", "Rivals" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Spidicules"] = {
                    keywords = { "Showdown:", "Spidicules" },
                    state = 5,
                    showdown = true,
                },
                ["The Forest Wants What it Wants (Spidicules)"] = {
                    keywords = { "The", "Forest", "Wants", "What", "it", "Wants" },
                    state = 6,
                    huntevent = true,
                },
                ["Spidisisyphus"] = {
                    keywords = { "Spidisisyphus" },
                    state = 7,
                },
                ["Puppet's Embalming"] = {
                    keywords = { "Puppet's", "Embalming" },
                    state = 8,
                },
                ["Silk Surgery"] = {
                    keywords = { "Silk", "Surgery" },
                    state = 9,
                },
                ["Taken"] = {
                    keywords = { "Taken" },
                    state = 10,
                    timelineEvent = true,
                },
            },
        },
    },

    minions = {
        {
            name = "Spiderling",
            movement = 4,
            size = { x = 1, y = 1 },
        }
    },

    monsters = {
        {
            name = "Spidicules",
            size = { x = 2, y = 2 },
            rules = { "Spidicules Rules", 5 },
            huntTrack = { "M", "M", "H", "H", "M", "F", "H", "M", "M", "H", "H" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 1)", "(11, 1)", "(12, 1)", "(13, 1)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
            -- no need for misc { "Spiderling" } since egg sacs fixed terrain will snag it
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 4,
                    showdown = {
                        starting = {
                            advanced = { "Frantic Spinning" },
                            special = { "Twitching Leg Pile", "Spawn", "Spiderling Action" },
                        },
                        basic = 5,
                        advanced = 4,
                        movement = 11,
                        toughness = 8,
                        fixedTerrain = {
                            {
                                terrain = "Silk Nest",
                                positions = { "(11.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "Egg Sacs",
                                positions = { "(11, 4)", "(12, 4)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            }
                        },
                        randomTerrain = 2,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 7,
                    showdown = {
                        starting = {
                            advanced = { "Feeding Time" },
                            special = { "Twitching Leg Pile", "Spawn", "Spiderling Action", "Hivemind" },
                        },
                        basic = 8,
                        advanced = 4,
                        movement = 14,
                        toughness = 10,
                        speed = 1,
                        damage = 1,
                        fixedTerrain = {
                            {
                                terrain = "Silk Nest",
                                positions = { "(11.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "Egg Sacs",
                                positions = { "(10, 5)", "(11, 4)", "(12, 4)", "(13, 5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            }
                        },
                        randomTerrain = 2,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 10,
                    showdown = {
                        starting = {
                            advanced = { "Necrotoxins" },
                            special = { "Twitching Leg Pile", "Spawn", "Spiderling Action", "Hivemind", "10,000 Teeth" },
                        },
                        basic = 12,
                        advanced = 7,
                        legendary = 2,
                        movement = 16,
                        toughness = 12,
                        speed = 2,
                        damage = 2,
                        fixedTerrain = {
                            {
                                terrain = "Silk Nest",
                                positions = { "(11.5, 8.5)" },
                                rotations = { { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "Egg Sacs",
                                positions = { "(9, 6)", "(10, 5)", "(11, 4)", "(12, 4)", "(13, 5)", "(14, 6)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            }
                        },
                        randomTerrain = 2,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/Slenderman", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Slenderman",

    components = {
        ["Fighting Arts"] = "Slenderman Fighting Arts",
        ["Secret Fighting Arts"] = "Clarity of Darkness",
        ["Disorders"] = "Slenderman Disorders",
        ["Strange Resources"] = "Slenderman Strange Resources",
        ["Settlement Events"] = "Slenderman Settlement Events",
        ["Innovations"] = "Dark Water Research",
        ["Rare Gear"] = "Slenderman Rare Gear",
    },

    removeTimelineEvent = { year = 6, name = "Armored Strangers" },
    replaceNemesis = { nemesis = "King's Man", replacement = "" },
    timelineEvents = {
        { year = 6, name = "It's Already Here", type = "RulebookEvent" },
    },

    settlementEvents = {
        "Slender Blight",
        "Phantom",
    },

    armorStats = {
        ["Gloom Bracelets"] = { head = 0, arms = 6, body = 0, waist = 0, legs = 0 },
        ["Gloom Mehndi"]    = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
    },

    weaponStats = {
        ["Gloom-Coated Arrow"] = { speed = 5, accuracy = 6, strength = 5, deadly = 1 },
        ["Gloom Hammer"]       = { speed = 2, accuracy = 7, strength = 13, deadly = 1 },
        ["Gloom Katana"]       = { speed = 4, accuracy = 5, strength = 0 },
    },

    guidNames = { ["797b30"] = "Slenderman Archive" },

    archiveEntries = {
        archive = "Slenderman Archive",
        entries = {
            { "Slenderman Rules", "Rulebook" },

            { "Path of Gloom", "Abilities" },
            { "Darkness Awareness", "Abilities" },
            { "Slenderman Fighting Arts", "Fighting Arts" },
            { "Clarity of Darkness", "Secret Fighting Arts" },
            { "Slenderman Disorders", "Disorders" },
            { "Slenderman Strange Resources", "Strange Resources" },

            { "Slenderman Settlement Events", "Settlement Events" },

            { "Dark Water Research", "Innovations" },

            { "Slenderman Rare Gear", "Gear" },

            { "Slenderman", "Monster Figurine" },

            { "Slenderman Info", "AI" },
            { "Slenderman Basic Action", "AI" },
            { "Slenderman Basic AI", "AI" },
            { "Slenderman Advanced AI", "AI" },
            { "Slenderman Legendary AI", "AI" },
            { "Slenderman Special AI", "AI" },
            { "Slenderman Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Slenderman Rules",
            pages = {
                ["Slenderman Rules"] = {
                    keywords = { "Slenderman", "Rulebook", "Rules" },
                    state = 1,
                },
                ["It's Already Here"] = {
                    keywords = { "It's", "Its", "Already", "Here" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Slenderman"] = {
                    keywords = { "Showdown:", "Slenderman" },
                    state = 5,
                    showdown = true,
                },
                ["A Dark Place"] = {
                    keywords = { "A", "Dark", "Place" },
                    state = 6,
                },
                ["Light-Forging"] = {
                    keywords = { "Light", "Forging" },
                    state = 7,
                },
                ["Forgotten Fear"] = {
                    keywords = { "Forgotten", "Fear" },
                    state = 8,
                    timelineEvent = true,
                },
            },
        },
    },

    monsters = {
        {
            name = "Slenderman",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Slenderman Rules", 5 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(1, 16)", "(1, 1)", "(22, 1)", "(22, 16)" },
            playerRotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(3, 3.5)", "(20, 3.5)", "(3, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Bug Patch",
                    positions = { "(20, 11)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Madness Inversion", "Madness Inversion", "Madness Inversion", "Madness Inversion" },
                        starting = {
                            special = { "Ensnare", "Gloom" },
                        },
                        basic = 8,
                        advanced = 5,
                        movement = 6,
                        toughness = 11,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Madness Inversion", "Madness Inversion", "Madness Inversion", "Madness Inversion" },
                        starting = {
                            special = { "Ensnare", "Gloom" },
                        },
                        basic = 8,
                        advanced = 6,
                        legendary = 1,
                        movement = 6,
                        toughness = 13,
                        speed = 1,
                        damage = 1,
                        accuracy = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Madness Inversion", "Madness Inversion", "Madness Inversion", "Madness Inversion" },
                        starting = {
                            special = { "Ensnare", "Gloom", "Hounds" },
                        },
                        basic = 10,
                        advanced = 8,
                        legendary = 2,
                        movement = 6,
                        toughness = 17,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                        luck = 1,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/Manhunter", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Manhunter",

    components = {
        ["Fighting Arts"] = "Manhunter Fighting Arts",
        ["Secret Fighting Arts"] = "Eternal Will",
        ["Strange Resources"] = "Manhunter Strange Resources",
        ["Innovations"] = "Manhunter Innovations",
        ["Rare Gear"] = "Manhunter Rare Gear",
    },

    timelineEvents = {
        { year = 5, name = "The Hanged Man", type = "RulebookEvent" },
    },

    armorStats = {
        ["Manhunter's Hat"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
    },
    guidNames = { ["e5fe39"] = "Manhunter Archive" },

    archiveEntries = {
        archive = "Manhunter Archive",
        entries = {
            { "Manhunter Rules", "Rulebook" },

            { "Manhunter Fighting Arts", "Fighting Arts" },
            { "Eternal Will", "Secret Fighting Arts" },
            { "Manhunter Strange Resources", "Strange Resources" },

            { "Manhunter Innovations", "Innovations" },

            { "Manhunter Rare Gear", "Gear" },

            { "Manhunter", "Monster Figurine" },

            { "Manhunter Info", "AI" },
            { "Manhunter Basic Action", "AI" },
            { "Manhunter Basic AI", "AI" },
            { "Manhunter Advanced AI", "AI" },
            { "Manhunter Legendary AI", "AI" },
            { "Manhunter Special AI", "AI" },
            { "Manhunter Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Manhunter Rules",
            pages = {
                ["Manhunter Rules"] = {
                    keywords = { "Manhunter", "Rulebook", "Rules" },
                    state = 1,
                },
                ["The Hanged Man"] = {
                    keywords = { "The", "Hanged", "Man" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Manhunter"] = {
                    keywords = { "Showdown:", "Manhunter" },
                    state = 5,
                    showdown = true,
                },
                ["Lottery"] = {
                    keywords = { "Lottery" },
                    state = 6,
                    timelineEvent = true,
                },
                ["Death Pit"] = {
                    keywords = { "Death", "Pit" },
                    state = 7,
                },
                ["Sonorous Rest"] = {
                    keywords = { "Sonorous", "Rest" },
                    state = 8,
                },
                ["Bleeding Heart"] = {
                    keywords = { "Bleeding", "Heart" },
                    state = 9,
                },
                ["Tools of War"] = {
                    keywords = { "Tools", "of", "War" },
                    state = 10,
                },
            },
        },
    },

    monsters = {
        {
            name = "Manhunter",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Manhunter Rules", 5 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(12, 13)", "(7, 8)", "(11, 4)", "(16, 9)" },
            playerRotations = {{ x = 0, y = 0, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(8.5, 7)", "(8.5, 10)", "(11, 12.5)" },
                    rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 },{ x = 0, y = 0, z = 0 } },
                },
                {
                    terrain = "3 Stone Columns",
                    positions = { "(14.5, 7)", "(14.5, 10)", "(12, 4.5)" },
                    rotations = { { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        starting = {
                            special = { "Short Stride", "Tombstone", "Gun Action", "Gritty Armament" },
                        },
                        basic = 7,
                        advanced = 3,
                        removeHitLocations = { "Mangled Groin", "Stake", "Stake", "Stake", "Stake", "Man Trap", "Man Trap", "Man Trap" },
                        movement = 6,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        starting = {
                            special = { "Full Stride", "Tombstone", "Gun Action", "Gritty Armament" },
                        },
                        basic = 7,
                        advanced = 6,
                        removeHitLocations = { "Mangled Groin", "Stake", "Stake", "Stake", "Stake", "Man Trap", "Man Trap", "Man Trap" },
                        movement = 7,
                        toughness = 11,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        starting = {
                            special = { "Full Stride", "Tombstone", "Gun Action", "Gritty Armament" },
                        },
                        basic = 8,
                        advanced = 7,
                        legendary = 1,
                        removeHitLocations = { "Mangled Groin", "Man Trap", "Man Trap", "Man Trap" },
                        movement = 8,
                        toughness = 11,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 4",
                    level = 4,
                    showdown = {
                        starting = {
                            special = { "Full Stride", "Tombstone", "Gun Action", "Gritty Armament" },
                        },
                        basic = 8,
                        advanced = 8,
                        legendary = 2,
                        removeHitLocations = { "Mangled Groin" },
                        movement = 9,
                        toughness = 13,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/LonelyTree", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Lonely Tree",

    components = {
        ["Hunt Events"] = "Object of Desire",
        ["Abilities"] = "Lonely Tree Abilities",
        ["Strange Resources"] = "Lonely Tree Strange Resources",
        ["Terrain"] = "The Lonely Tree",
        ["Terrain Tiles"] = { "The Lonely Tree", "Lonely Fruit" },

        ["Patterns"] =  "Afterdeath Brew",
        ["Rare Gear"] = "Afterdeath Brew",
    },

    terrain = {
        ["The Lonely Tree"] = {
            terrainTile = "The Lonely Tree",
            count = 1,
            miscObject = { name = "Lonely Fruit", type = "Terrain Tiles" },
            starting = { "Nightmare Fruit", "Monster Fruit" },
        },
    },

    terrainTileSizes = {
        ["The Lonely Tree"] = { x = 3, y = 3 },
        ["Lonely Fruit"] = { x = 1, y = 1 },
    },

    guidNames = { ["0857d8"] = "Lonely Tree Archive" },

    archiveEntries = {
        archive = "Lonely Tree Archive",
        entries = {
            { "Lonely Tree Rules", "Rulebook" },

            { "Lonely Tree Abilities", "Abilities" },
            { "Lonely Tree Strange Resources", "Strange Resources" },

            { "The Lonely Tree", "Terrain" },
            { "The Lonely Tree", "Terrain Tiles" },
            { "Lonely Fruit", "Terrain Tiles" },

            { "Lonely Tree", "Monster Figurine" },

            { "Object of Desire", "Hunt Events" },

            { "Lonely Tree Info", "AI" },
            { "Lonely Tree Basic Action", "AI" },
            { "Lonely Tree Basic AI", "AI" },
            { "Lonely Tree Advanced AI", "AI" },
            { "Lonely Tree Legendary AI", "AI" },
            { "Lonely Tree Special AI", "AI" },
            { "Lonely Tree Hit Locations", "Hit Locations" },

            { "Nightmare Fruit", "AI" },
            { "Monster Fruit", "AI" },

            { "Afterdeath Brew", "Patterns" },
            { "Afterdeath Brew", "Gear" },
        },
    },

    rulebooks = {
        {
            name = "Lonely Tree Rules",
            pages = {
                ["Lonely Tree Rules"] = {
                    keywords = { "Lonely", "Tree", "Rulebook", "Rules" },
                    state = 1,
                },
                ["The Lonely Lady"] = {
                    keywords = { "The", "Lonely", "Lady" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Lonely Tree"] = {
                    keywords = { "Showdown:", "Lonely", "Tree" },
                    state = 6,
                    showdown = true,
                },
            },
        },
    },

    monsters = {
        {
            name = "Lonely Tree",
            size = { x = 3, y = 3 },
            rules = { "Lonely Tree Rules", 6 },
            resourcesDeck = false,
            position = "(11, 8)",
            playerPositions = { "(9, 13)", "(10, 14)", "(11, 14)", "(12, 14)" },
            playerRotations = {{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "2 Tall Grass",
                    positions = { "(4.5, 1.5)", "(17.5, 1.5)", "(4.5, 14.5)", "(17.5, 14.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            miscObject = { name = "Lonely Fruit", type = "Terrain Tiles" },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        starting = {
                            special = { "Bear Fruit", "Impenetrable Trunk", "Nightmare Fruit" },
                        },
                        basic = 6,
                        advanced = 3,
                        legendary = 1,
                        toughness = 10,
                        damage = -1,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        starting = {
                            special = { "Bear Fruit", "Impenetrable Trunk", "Moving Ground", "Nightmare Fruit" },
                        },
                        basic = 8,
                        advanced = 5,
                        legendary = 1,
                        toughness = 13,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        starting = {
                            special = { "Bear Fruit", "Impenetrable Trunk", "Moving Ground", "Nightmare Fruit" },
                        },
                        basic = 8,
                        advanced = 5,
                        legendary = 2,
                        life = 20,
                        toughness = 17,
                        speed = 1,
                        damage = 1,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/LionKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Lion Knight",

    components = {
        ["Fighting Arts"] = "Lion Knight Fighting Arts",
        ["Secret Fighting Arts"] = "Lion Knight Secret Fighting Arts",
        ["Disorders"] = "Lion Knight Disorders",
        ["Tactics"] = "Lion Knight Tactics",
        ["Innovations"] = "Lion Knight Innovations",
        ["Armor Sets"] = "Lion Knight Armor Sets",
        ["Rare Gear"] = "Lion Knight Rare Gear",
    },

    timelineEvents = {
        { year = 6, name = "An Uninvited Guest", type = "RulebookEvent" },
        { year = 8, name = "Places, Everyone!", type = "RulebookEvent" },
        { year = 12, name = "Places, Everyone!", type = "RulebookEvent" },
        { year = 16, name = "Places, Everyone!", type = "RulebookEvent" },
    },

    terrainTileSizes = {
        ["Horn"] = { x = 1, y = 1 },
        ["Throne"] = { x = 1, y = 1 },
        ["Stage"] = { x = 4, y = 4 },
        ["Balcony"] = { x = 1, y = 2 }
    },

    armorStats = {
        ["Brawler Armor"]    = { head = 1, arms = 2, body = 4, waist = 0, legs = 0, hybrid = true },
        ["Dancer Armor"]     = { head = 0, arms = 1, body = 2, waist = 0, legs = 0, hybrid = true },
        ["Warlord Armor"]    = { head = 2, arms = 2, body = 1, waist = 0, legs = 0, hybrid = true },
        ["Hideous Disguise"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Lion Knight's Left Claw"]  = { speed = 2, accuracy = 5, strength = 4 },
        ["Lion Knight's Right Claw"] = { speed = 2, accuracy = 8, strength = 8 },
    },

    guidNames = { ["37eaad"] = "Lion Knight Archive" },

    archiveEntries = {
        archive = "Lion Knight Archive",
        entries = {
            { "Lion Knight Rules", "Rulebook" },

            { "Lion Knight Fighting Arts", "Fighting Arts" },
            { "Lion Knight Secret Fighting Arts", "Secret Fighting Arts" },
            { "Lion Knight Disorders", "Disorders" },
            { "Lion Knight Tactics", "Tactics" },
            { "Lion Knight Armor Sets", "Armor Sets" },

            { "Balcony (Terrain)", "Terrain" },
            { "Horn (Terrain)", "Terrain" },
            { "Throne (Terrain)", "Terrain" },
            { "Stage (Terrain)", "Terrain" },
            { "Balcony", "Terrain Tiles" },
            { "Horn", "Terrain Tiles" },
            { "Throne", "Terrain Tiles" },
            { "Stage", "Terrain Tiles" },

            { "Lion Knight Innovations", "Innovations" },

            { "Lion Knight Rare Gear", "Gear" },

            { "Lion Knight", "Monster Figurine" },

            { "Lion Knight Info", "AI" },
            { "Lion Knight Basic Action", "AI" },
            { "Lion Knight Basic AI", "AI" },
            { "Lion Knight Advanced AI", "AI" },
            { "Lion Knight Special AI", "AI" },
            { "Lion Knight Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Lion Knight Rules",
            pages = {
                ["Lion Knight Rules"] = {
                    keywords = { "Lion", "Knight", "Rulebook", "Rules" },
                    state = 1,
                },
                ["An Uninvited Guest"] = {
                    keywords = { "An", "Uninvited", "Guest" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Places, Everyone!"] = {
                    keywords = { "Places", "Everyone!" },
                    state = 4,
                    timelineEvent = true,
                },
                ["Showdown: Lion Knight"] = {
                    keywords = { "Showdown:", "Lion", "Knight" },
                    state = 5,
                    showdown = true,
                },
                ["Intermission"] = {
                    keywords = { "Intermission" },
                    state = 6,
                },
                ["Strange Caravan"] = {
                    keywords = { "Strange", "Caravan" },
                    state = 7,
                },
                ["Finale"] = {
                    keywords = { "Finale" },
                    state = 8,
                },
            },
        },
    },

    monsters = {
        {
            name = "Lion Knight",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Lion Knight Rules", 5 },
            resourcesDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(8, 12)", "(8, 5)", "(15, 5)", "(15, 12)" },
            playerRotations = {{ x = 0, y = 0, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 } },
            specialTerrain = {
                {
                    terrain = "Balcony (Terrain)",
                    terrainTile = "Balcony",
                    position = "(11.5, 1)",
                    rotation = { x = 0, y = 270, z = 0 },
                },
                {
                    terrain = "Horn (Terrain)",
                    terrainTile = "Horn",
                    position = "(18, 9)",
                    rotation = { x = 0, y = 180, z = 0 },
                },
                {
                    terrain = "Stage (Terrain)",
                    terrainTile = "Stage",
                    position = "(11.5, 8.5)",
                    rotation = { x = 0, y = 180, z = 0 },
                },
                {
                    terrain = "Throne (Terrain)",
                    terrainTile = "Throne",
                    position = "(5, 9)",
                    rotation = { x = 0, y = 180, z = 0 },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        specialTerrain = {},
                        survivorStatus = { "Ruler", "Damsel", "Villain", "Fool" },
                        starting = {
                            special = { "Zeal", "Outburst" },
                        },
                        basic = 10,
                        advanced = 2,
                        movement = 7,
                        toughness = 10,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Ruler", "Damsel", "Villain", "Fool" },
                        starting = {
                            special = { "Zeal", "Outburst", "Drama Lessons" },
                        },
                        basic = 10,
                        advanced = 5,
                        movement = 8,
                        toughness = 12,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Ruler", "Damsel", "Villain", "Fool" },
                        starting = {
                            special = { "Zeal", "Outburst", "Drama Lessons", "Last Act" },
                        },
                        basic = 12,
                        advanced = 9,
                        movement = 9,
                        toughness = 15,
                        speed = 1,
                        damage = 1,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/LionGod", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Lion God",

    components = {
        ["Fighting Arts"] = "Lion God Fighting Arts",
        ["Secret Fighting Arts"] = "Lion God Secret Fighting Arts",
        ["Disorders"] = "Lion God Disorders",
        ["Strange Resources"] = "Lion God Strange Resources",
        ["Terrain"] = "Lion God Terrain",
        ["Terrain Tiles"] = { "Lion Statue", "Sinkhole" },
        ["Innovations"] = "The Knowledge Worm",
        ["Rare Gear"] = "Lion God Rare Gear",
    },

    timelineEvents = {
        { year = 13, name = "The Silver City", type = "RulebookEvent" },
    },

    terrain = {
        ["Lion Statue"] = { terrainTile = "Lion Statue", count = 1 },
        ["Sinkhole"] = { terrainTile = "Sinkhole", count = 1 },
    },

    terrainTileSizes = {
        ["Lion Statue"] = { x = 2, y = 2 },
        ["Sinkhole"] = { x = 3, y = 3 },
    },

    armorStats = {
        ["Ancient Lion Claws"] = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Necromancer's Eye"]  = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    guidNames = { ["f2cc04"] = "Lion God Archive" },

    archiveEntries = {
        archive = "Lion God Archive",
        entries = {
            { "Lion God Rules", "Rulebook" },

            { "Lion God Fighting Arts", "Fighting Arts" },
            { "Lion God Secret Fighting Arts", "Secret Fighting Arts" },
            { "Lion God Disorders", "Disorders" },
            { "Lion God Strange Resources", "Strange Resources" },

            { "Lion God Terrain", "Terrain" },
            { "Lion Statue", "Terrain Tiles" },
            { "Sinkhole", "Terrain Tiles" },

            { "The Knowledge Worm", "Innovations" },

            { "Lion God Rare Gear", "Gear" },

            { "Lion God", "Monster Figurine" },

            { "Lion God Hunt Events", "Monster Hunt Events" },

            { "Lion God Info", "AI" },
            { "Lion God Basic Action", "AI" },
            { "Lion God Basic AI", "AI" },
            { "Lion God Advanced AI", "AI" },
            { "Lion God Legendary AI", "AI" },
            { "Lion God Special AI", "AI" },
            { "Lion God Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Lion God Rules",
            pages = {
                ["Lion God Rules"] = {
                    keywords = { "Lion", "God", "Rulebook", "Rules" },
                    state = 1,
                },
                ["The Silver City"] = {
                    keywords = { "The", "Silver", "City" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Showdown: Lion God"] = {
                    keywords = { "Showdown:", "Lion", "God" },
                    state = 5,
                    showdown = true,
                },
                ["Necropolis"] = {
                    keywords = { "Necropolis" },
                    state = 6,
                },
                ["The Knowledge Worm"] = {
                    keywords = { "The", "Knowledge", "Worm" },
                    state = 7,
                },
                ["A Gracious Host"] = {
                    keywords = { "A", "Gracious", "Host" },
                    state = 8,
                },
                ["Death Reading"] = {
                    keywords = { "Death", "Reading" },
                    state = 9,
                },
            },
        },
    },

    monsters = {
        {
            name = "Lion God",
            size = { x = 3, y = 3 },
            rules = { "Lion God Rules", 5 },
            resourcesDeck = false,
            huntTrack = { "H", "M", "H", "M", "H", "O", "H", "M", "H", "M", "H" },
            position = "(12, 9)",
            playerPositions = { "(10, 11)", "(10, 7)", "(14, 7)", "(14, 11)" },
            playerRotations = {{ x = 0, y = 0, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(2, 6.5)", "(2, 12.5)", "(21, 6.5)", "(21, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Toppled Pillar",
                    positions = { "(6.5, 9)", "(17.5, 9)" },
                    rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = -90, z = 0 } },
                },
                {
                    terrain = "Giant Stone Face",
                    positions = { "(12, 4.5)", "(12, 13.5)" },
                    rotations = { { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 } },
                },
                {
                    terrain = "Lion Statue",
                    positions = { "(8.5, 5.5)", "(15.5, 5.5)", "(8.5, 12.5)", "(15.5, 12.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 7,
                    showdown = {
                        starting = {
                            special = { "Whiplash", "Hollow Earth", "Heft" },
                        },
                        basic = 7,
                        advanced = 7,
                        legendary = 1,
                        movement = 8,
                        toughness = 14,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 9,
                    showdown = {
                        starting = {
                            special = { "Whiplash", "Hollow Earth", "Heft", "Divine Prowess" },
                        },
                        basic = 11,
                        advanced = 8,
                        legendary = 1,
                        movement = 9,
                        toughness = 16,
                        speed = 1,
                        damage = 1,
                        luck = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        starting = {
                            special = { "Whiplash", "Hollow Earth", "Heft", "Divine Prowess", "Immaculate Intuition" },
                        },
                        basic = 14,
                        advanced = 9,
                        legendary = 2,
                        movement = 10,
                        toughness = 21,
                        speed = 2,
                        damage = 3,
                        evasion = 1,
                        luck = 2,
                    },
                },
            }
        },
    },
}

end)
__bundle_register("Kdm/Expansion/Gorm", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Gorm",

    components = {
        ["Fighting Arts"] = "Gorm Fighting Arts",
        ["Secret Fighting Arts"] = "Immovable Object",
        ["Disorders"] = "Gorm Disorders",
        ["Armor Sets"] = "Gorment Armor",
        ["Strange Resources"] = "Gorm Strange Resources",
        ["Settlement Events"] = "Gorm Climate",
        ["Innovations"] = "Gorm Innovations",
        ["Settlement Locations"] = "Gorm Settlement Locations",
    },

    settlementEvents = {
        "Gorm Climate",
    },

    timelineEvents = {
        { year = 1, name = "The Approaching Storm", type = "RulebookEvent" },
    },

    settlementLocationGear = {
        ["Gormery"] = "Gormery Gear",
        ["Gormchymist"] = "Gormchymist Gear",
    },

    armorStats = {
        ["Gorment Armor"]     = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Gorment Mask"]      = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Gorment Sleeves"]   = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Regeneration Suit"] = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Gorment Suit"]      = { head = 0, arms = 0, body = 2, waist = 2, legs = 0 },
        ["Gorment Boots"]     = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },
    },

    weaponStats = {
        ["Acid-Tooth Dagger"] = { speed = 2, accuracy = 7, strength = 2, paired = true },
        ["Black Sword"]       = { speed = 3, accuracy = 5, strength = 10 },
        ["Gaxe"]              = { speed = 1, accuracy = 6, strength = 4 },
        ["Greater Gaxe"]      = { speed = 2, accuracy = 6, strength = 4, deadly = 1 },
        ["Knuckle Shield"]    = { speed = 3, accuracy = 7, strength = 1 },
        ["Rib Blade"]         = { speed = 1, accuracy = 6, strength = 5, slow = true, deadly = 1 },
        ["Riot Mace"]         = { speed = 2, accuracy = 5, strength = 5, deadly = 1 },
    },

    guidNames = { ["211ef7"] = "Gorm Archive" },

    archiveEntries = {
        archive = "Gorm Archive",
        entries = {
            { "Gorm Rules", "Rulebook" },

            { "Gorm Fighting Arts", "Fighting Arts" },
            { "Immovable Object", "Secret Fighting Arts" },
            { "Gorm Disorders", "Disorders" },
            { "Gorment Armor", "Armor Sets" },
            { "Gorm Strange Resources", "Strange Resources" },
            { "Gorm Resources", "Monster Resources" },

            { "Gorm Climate", "Settlement Events" },

            { "Gorm Innovations", "Innovations" },

            { "Gorm Settlement Locations", "Settlement Locations" },

            { "Gormery Gear", "Gear" },
            { "Gormchymist Gear", "Gear" },

            { "Gorm", "Monster Figurine" },

            { "Gorm Hunt Events", "Monster Hunt Events" },

            { "Gorm Info", "AI" },
            { "Gorm Basic Action", "AI" },
            { "Gorm Basic AI", "AI" },
            { "Gorm Advanced AI", "AI" },
            { "Gorm Legendary AI", "AI" },
            { "Gorm Special AI", "AI" },
            { "Gorm Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Gorm Rules",
            pages = {
                ["Gorm Rules"] = {
                    keywords = { "Gorm", "Rulebook", "Rules" },
                    state = 1,
                },
                ["The Approaching Storm"] = {
                    keywords = { "The", "Approaching", "Storm" },
                    state = 2,
                    timelineEvent = true,
                },
                ["Fetid Grotto"] = {
                    keywords = { "Fetid", "Grotto" },
                    state = 3,
                },
                ["The Final March"] = {
                    keywords = { "The", "Final", "March" },
                    state = 4,
                },
                ["Showdown: Gorm"] = {
                    keywords = { "Showdown:", "Gorm" },
                    state = 5,
                    showdown = true,
                },
                ["Melting Horror"] = {
                    keywords = { "Melting", "Horror" },
                    state = 6,
                },
            },
        },
    },

    monsters = {
        {
            name = "Gorm",
            size = { x = 3, y = 3 },
            rules = { "Gorm Rules", 5 },
            huntTrack = { "M", "M", "H", "H", "M", "O", "H", "H", "M", "M", "H" },
            position = "(12, 9)",
            playerPositions = { "(11, 16)", "(12, 16)", "(13, 16)", "(14, 15)" },
            fixedTerrain = {
                {
                    terrain = "2 Tall Grass",
                    positions = { "(9.5, 6.5)", "(14.5, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 4,
                    showdown = {
                        basic = 8,
                        -- customBasic = { "Posturing Piss" },
                        -- topAiCards = { "Posturing Piss" },
                        advanced = 2,
                        movement = 6,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 7,
                    showdown = {
                        basic = 9,
                        advanced = 5,
                        starting = {
                            special = { "Gorm's Den", "Musth" },
                        },
                        movement = 9,
                        toughness = 11,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic = 10,
                        advanced = 8,
                        legendary = 2,
                        starting = {
                            special = { "Ancient Tusks", "Gormyard" },
                        },
                        movement = 8,
                        toughness = 15,
                        speed = 2,
                        damage = 2,
                        luck = 1,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/FlowerKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Flower Knight",
    components = {
        ["Fighting Arts"] = "Otherworldly Luck",
        ["Secret Fighting Arts"] = "Flower Knight Secret Fighting Arts",
        ["Disorders"] = "Flower Knight Disorders",
        ["Tactics"] = "Flower Knight Tactics",
        ["Innovations"] = "Petal Spiral - Forbidden Dance Consequence",
        ["Terrain"] = "Flower Patches",
        ["Terrain Tiles"] = { "Flower Patch" },
        ["Rare Gear"] = "Flower Knight Rare Gear",
        ["Patterns"] = "Flower Knight Patterns",
    },

    timelineEvents = {
        { year = 5, name = "A Crone's Tale", type = "RulebookEvent" },
    },

    terrain = {
        ["Flower Patches"] = { terrainTile = "Flower Patch", count = "*" },
    },

    terrainTileSizes = {
        ["Flower Patch"] = { x = 1, y = 1 },
    },

    armorStats = {
        ["Flower Knight Helm"] = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Replica Flower Sword"] = { speed = 2, accuracy = 6, strength = 6 },
        ["Vespertine Arrow"]     = { speed = 2, accuracy = 6, strength = 0, deadly = 4 },
        ["Vespertine Bow"]       = { speed = 3, accuracy = 6, strength = 1, deadly = 1 },
        ["Vespertine Foil"]      = { speed = 4, accuracy = 5, strength = 1 },
    },

    guidNames = { ["475b51"] = "Flower Knight Archive" },

    archiveEntries = {
        archive = "Flower Knight Archive",
        entries = {
            { "Flower Knight Rules", "Rulebook" },

            { "Otherworldly Luck", "Fighting Arts" },
            { "Flower Knight Secret Fighting Arts", "Secret Fighting Arts" },
            { "Flower Knight Disorders", "Disorders" },
            { "Flower Knight Tactics", "Tactics" },
            { "Flower Knight Resources", "Monster Resources" },

            { "Flower Patches", "Terrain" },
            { "Flower Patch", "Terrain Tiles" },
            { "Fairy Ring", "Terrain Tiles" },

            { "Petal Spiral - Forbidden Dance Consequence", "Innovations" },

            { "Flower Knight Rare Gear", "Gear" },

            { "Flower Knight", "Monster Figurine" },

            { "Flower Knight Hunt Events", "Monster Hunt Events" },

            { "Flower Knight Info", "AI" },
            { "Flower Knight Basic Action", "AI" },
            { "Flower Knight Basic AI", "AI" },
            { "Flower Knight Advanced AI", "AI" },
            { "Flower Knight Legendary AI", "AI" },
            { "Flower Knight Special AI", "AI" },
            { "Flower Knight Hit Locations", "Hit Locations" },
            
            { "Flower Knight Patterns", "Patterns" },

        },
    },

    rulebooks = {
        {
            name = "Flower Knight Rules",
            pages = {
                ["Flower Knight Rules"] = {
                    keywords = { "Flower", "Knight", "Rulebook", "Rules" },
                    state = 1,
                },
                ["A Crone's Tale"] = {
                    keywords = { "A", "Crone's", "Tale" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Flower Knight"] = {
                    keywords = { "Showdown:", "Flower", "Knight" },
                    state = 6,
                    showdown = true,
                },
                ["The Forest Wants What it Wants (Flower Knight)"] = {
                    keywords = { "The", "Forest", "Wants", "What", "It", "Wants" },
                    state = 7,
                    huntEvent = true,
                },
                ["Breakthrough"] = {
                    keywords = { "Breakthrough" },
                    state = 8,
                },
                ["Sense Memory"] = {
                    keywords = { "Sense", "Memory" },
                    state = 9,
                    timelineEvent = true,
                },
                ["A Warm Virus"] = {
                    keywords = { "A", "Warm", "Virus" },
                    state = 10,
                    timelineEvent = true,
                },
                ["Necrotoxic Mistletoe"] = {
                    keywords = { "Necrotoxic", "Mistletoe" },
                    state = 11,
                    timelineEvent = true,
                },
            },
        },
    },

    monsters = {
        {
            name = "Flower Knight",
            size = { x = 2, y = 2 },
            rules = { "Flower Knight Rules", 6 },
            huntTrack = { "H", "H", "H", "H", "H", "F", "M", "M", "M", "M", "M" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 14)", "(11, 14)", "(12, 14)", "(13, 14)" },
            specialTerrain = {
                {
                    terrainTile = "Fairy Ring",
                    position = "(11.5, 8.5)",
                    rotation = { x = 0, y = 0, z = 0 },
                },
            },
            unfixedTerrain = { "Flower Patches" },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 8,
                    partyHuntPosition = 2,
                    showdown = {
                        basic  = 7,
                        advanced = 4,
                        starting = {
                            special = { "Bloom", "Set Roots" },
                        },
                        movement = 7,
                        toughness = 6,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 9,
                    partyHuntPosition = 1,
                    showdown = {
                        basic  = 8,
                        advanced = 4,
                        legendary = 1,
                        starting = {
                            special = { "Bloom", "Set Roots", "Razor Bulbs" },
                        },
                        movement = 8,
                        toughness = 8,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 10,
                    showdown = {
                        basic  = 9,
                        advanced = 5,
                        legendary = 2,
                        starting = {
                            special = { "Bloom", "Set Roots", "Razor Bulbs", "Perfect Aim", "Heart of the Woods" },
                        },
                        movement = 9,
                        toughness = 11,
                        speed = 1,
                        damage = 2,
                    },
                },
            }
        },
    },
}

end)
__bundle_register("Kdm/Expansion/DungBeetleKnight", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Dung Beetle Knight",

    components = {
        ["Fighting Arts"] = "Dung Beetle Knight Fighting Arts",
        ["Secret Fighting Arts"] = "Beetle Strength",
        ["Disorders"] = "Dung Beetle Knight Disorders",
        ["Strange Resources"] = "Dung Beetle Knight Strange Resources",
        ["Tactics"] = "Dung Beetle Knight Tactics",
        ["Armor Sets"] = "Rolling Armor",
        ["Terrain"] = "Resin Dung Ball",
        ["Terrain Tiles"] = { "Resin Dung Ball" },
        ["Innovations"] = "Dung Beetle Knight Innovations",
        ["Settlement Locations"] = "Wet Resin Crafter",
        ["Rare Gear"] = "Dung Beetle Knight Rare Gear",
    },

    timelineEvents = {
        { year = 8, name = "Rumbling in the Dark", type = "RulebookEvent"  },
    },

    terrain = {
        ["Resin Dung Ball"] = { terrainTile = "Resin Dung Ball", count = 1 },
    },

    terrainTileSizes = {
        ["Resin Dung Ball"] = { x = 2, y = 2 },
    },

    settlementLocationGear = {
        ["Wet Resin Crafter"] = "Wet Resin Crafter Gear",
    },

    armorStats = {
        ["Rolling Armor"]           = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
        ["Calcified Greaves"]       = { head = 3, arms = 3, body = 3, waist = 3, legs = 3, modifier = true },
        ["Calcified Shoulder Pads"] = { head = 3, arms = 3, body = 3, waist = 3, legs = 3, modifier = true },
        ["Century Greaves"]         = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Century Shoulder Pads"]   = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["DBK Errant Badge"]        = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Scarab Circlet"]          = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Trash Crown"]             = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Digging Claw"]               = { speed = 1, accuracy = 4, strength = 5, paired = true },
        ["Calcified Digging Claw"]     = { speed = 1, accuracy = 4, strength = 5, sharp = true, paired = true },
        ["Calcified Juggernaut Blade"] = { speed = 1, accuracy = 5, strength = 9, slow = true },
        ["Calcified Zanbato"]          = { speed = 1, accuracy = 5, strength = 8, slow = true, deadly = 1 },
    },

    guidNames = { ["d7ba5b"] = "Dung Beetle Knight Archive" },

    archiveEntries = {
        archive = "Dung Beetle Knight Archive",
        entries = {
            { "Dung Beetle Knight Rules", "Rulebook" },

            { "Momentum", "Abilities" },
            { "Steadfast", "Abilities" },

            { "Dung Beetle Knight Fighting Arts", "Fighting Arts" },
            { "Beetle Strength", "Secret Fighting Arts" },
            { "Dung Beetle Knight Disorders", "Disorders" },
            { "Dung Beetle Knight Strange Resources", "Strange Resources" },
            { "Dung Beetle Knight Tactics", "Tactics" },
            { "Rolling Armor", "Armor Sets" },
            { "Dung Beetle Knight Resources", "Monster Resources" },

            { "Resin Dung Ball", "Terrain" },
            { "Resin Dung Ball", "Terrain Tiles" },

            { "Dung Beetle Knight Innovations", "Innovations" },

            { "Wet Resin Crafter Gear", "Gear" },
            { "Dung Beetle Knight Rare Gear", "Gear" },

            { "Wet Resin Crafter", "Settlement Locations" },

            { "Dung Beetle Knight", "Monster Figurine" },

            { "Dung Beetle Knight Hunt Events", "Monster Hunt Events" },

            { "Dung Beetle Knight Info", "AI" },
            { "Dung Beetle Knight Basic Action", "AI" },
            { "Dung Beetle Knight Basic AI", "AI" },
            { "Dung Beetle Knight Advanced AI", "AI" },
            { "Dung Beetle Knight Legendary AI", "AI" },
            { "Dung Beetle Knight Special AI", "AI" },
            { "Dung Beetle Knight Hit Locations", "Hit Locations" },
        },
    },

    rulebooks = {
        {
            name = "Dung Beetle Knight Rules",
            pages = {
                ["Dung Beetle Knight Rules"] = {
                    keywords = { "Dung", "Beetle", "Knight", "Rulebook", "Rules" },
                    state = 1,
                },
                ["Rumbling in the Dark"] = {
                    keywords = { "Rumbling", "in", "the", "Dark" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Dung Beetle Knight"] = {
                    keywords = { "Showdown:", "Dung", "Beetle", "Knight" },
                    state = 6,
                    showdown = true,
                },
                ["Spelunking of Death"] = {
                    keywords = { "Spelunking", "of", "Death" },
                    state = 7,
                },
                ["Underground Sow"] = {
                    keywords = { "Underground", "Sow" },
                    state = 8,
                },
                ["Black Harvest"] = {
                    keywords = { "Black", "Harvest" },
                    state = 9,
                    timelineEvent = true,
                },
                ["Secret Meeting"] = {
                    keywords = { "Secret", "Meeting" },
                    state = 10,
                    timelineEvent = true,
                },
            },
        },
    },

    monsters = {
        {
            name = "Dung Beetle Knight",
            size = { x = 2, y = 2 },
            rules = { "Dung Beetle Knight Rules", 6 },
            huntTrack = { "H", "M", "M", "H", "H", "O", "M", "H", "H", "M", "H" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 15)", "(11, 14)", "(12, 14)", "(13, 15)" },
            fixedTerrain = {
                {
                    terrain = "Resin Dung Ball",
                    positions = { "(11.5, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "3 Stone Columns",
                    positions = { "(3, 3.5)", "(5, 8.5)", "(3, 13.5)", "(20, 3.5)", "(18, 8.5)", "(20, 13.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Bug Patch",
                    positions = { "(11, 4)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 5,
                    showdown = {
                        basic  = 7,
                        advanced = 3,
                        starting = {
                            special = { "Baller", "Power Forward", "Separation Anxiety", "Prepared Tunnels" },
                        },
                        movement = 7,
                        toughness = 12,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic  = 7,
                        advanced = 6,
                        legendary = 1,
                        starting = {
                            special = { "Baller", "Power Forward", "Separation Anxiety", "Prepared Tunnels", "Heavy Load" },
                        },
                        movement = 7,
                        toughness = 14,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic  = 8,
                        advanced = 9,
                        legendary = 2,
                        starting = {
                            special = { "Baller", "Power Forward", "Separation Anxiety", "Prepared Tunnels", "Burrow", "Heavy Load" },
                        },
                        movement = 8,
                        toughness = 18,
                        speed = 2,
                        damage = 2,
                        accuracy = 1,
                        evasion = 1,
                    },
                },
                {
                    name = "The Old Master",
                    level = 4,
                    showdown = {
                        rules = { "Dung Beetle Knight Rules", 10 },
                        customBasic  = { "Backspin Shot", "Smash Shot", "Feculent Drumming", "Resin-Plated Right", "Shoulder Bash" },
                        customAdvanced = { "Resin Sword Slash" },
                        starting = {
                            legendary = { "Sword Master" },
                            special = { "Baller", "Power Forward", "Separation Anxiety", "Prepared Tunnels", "Heavy Load" },
                            misc = { "Berserker" },
                        },
                        life = 25,
                        movement = 9,
                        toughness = 25,
                        speed = 2,
                        damage = 5,
                        accuracy = 1,
                        luck = 3,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/DragonKing", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Dragon King",

    components = {
        ["Abilities"] = "Dragon King Abilities",
        ["Fighting Arts"] = "Dragon King Fighting Arts",
        ["Secret Fighting Arts"] = "Dragon King Secret Fighting Arts",
        ["Disorders"] = "Dragon King Disorders",
        ["Weapon Proficiencies"] = "Scythe Proficiency",
        ["Armor Sets"] = "Dragon Armor",
        ["Strange Resources"] = "Dragon King Strange Resources",
        ["Terrain"] = "Dragon King Terrain",
        ["Terrain Tiles"] = { "Obsidian Tower", "Lava Pool" },
        ["Innovations"] = "Dragon King Innovations",
        ["Rare Gear"] = "Dragon King Rare Gear",
        ["Settlement Locations"] = "Dragon King Settlement Locations",
    },

    campaigns = {
        {
            name = "People of the Stars",
            years = 25,
            timeline = {
                { year = 1, type = "RulebookEvent", name = "Foundlings" },
                { year = 2, type = "RulebookEvent", name = "Endless Screams" },
                { year = 4, type = "ShowdownEvent", monster = "The Tyrant", level = "Level 1" },
                { year = 5, type = "RulebookEvent", name = "Midnight's Children" },
                { year = 7, type = "RulebookEvent", name = "Phoenix Feather" },
                { year = 9, type = "ShowdownEvent", monster = "The Tyrant", level = "Level 2" },
                { year = 10, type = "RulebookEvent", name = "Unveil the Sky" },
                { year = 12, type = "RulebookEvent", name = "Principle: Conviction" },
                { year = 13, type = "ShowdownEvent", monster = "Butcher", level = "Level 2" },
                { year = 16, type = "ShowdownEvent", level = "Level 2" },
                { year = 19, type = "ShowdownEvent", monster = "The Tyrant", level = "Level 3" },
                { year = 20, type = "RulebookEvent", name = "The Tomb" },
                { year = 23, type = "ShowdownEvent", level = "Level 3" },
                { year = 25, type = "RulebookEvent", name = "Death of the Dragon King" },
            },
            survivalActions = {
                { name = "Dodge", checked = true },
                { name = "Encourage", checked = false },
                { name = "Dash", checked = false },
                { name = "Surge", checked = false },
            },
            milestones = {
                { name = "First Birth", event = "Principle: New Life" },
                { name = "First Death", event = "Principle: Death" },
                { name = "15 Population", event = "Principle: Society" },
            },
            objectsByLocation = {
                ["Innovation Deck"] = { tag = "Deck", name = "Innovation Deck", type = "Innovations", faceDown = true, cards = {
                    { name = "Ammonia - Language Consequence", type = "Innovations" },
                    { name = "Drums - Language Consequence", type = "Innovations" },
                    { name = "Hovel - Language Consequence", type = "Innovations" },
                    { name = "Inner Lantern - Language Consequence", type = "Innovations" },
                    { name = "Paint - Language Consequence", type = "Innovations" },
                    { name = "Symposium - Language Consequence", type = "Innovations" },
                } },
                ["Principle: Death"] = { tag = "Deck", name = "Principle: Death", type = "Innovations", faceDown = true, cards = {
                    { name = "Cannibalize - Death Principle", type = "Innovations" },
                    { name = "Graves - Death Principle", type = "Innovations" },
                } },
                ["Principle: New Life"] = { tag = "Deck", name = "Principle: New Life", type = "Innovations", faceDown = true, cards = {
                    { name = "Protect the Young - New Life Principle", type = "Innovations" },
                    { name = "Survival of the Fittest - New Life Principle", type = "Innovations" },
                } },
                ["Principle: Society"] = { tag = "Deck", name = "Principle: Society", type = "Innovations", faceDown = true, cards = {
                    { name = "Accept Darkness - Society Principle", type = "Innovations" },
                    { name = "Collective Toil - Society Principle", type = "Innovations" },
                } },
                ["Principle: Conviction"] = { tag = "Deck", name = "Principle: Conviction", type = "Innovations", faceDown = true, cards = {
                    { name = "Barbaric - Conviction Principle", type = "Innovations" },
                    { name = "Romantic - Conviction Principle", type = "Innovations" },
                } },
                ["Innovation 1"] = { tag = "Card", name = "Dragon Speech", type = "Innovations" },
                ["Settlement Location 1"] = { tag = "Card", name = "Throne", type = "Settlement Locations" },
            },
            references = {
                { name = "Age Reference", location = "Reference 1" },
                { name = "Intimacy (People of the Stars) Reference", location = "Reference 2" },
                { name = "Awake (Courage) Reference", location = "Reference 3" },
                { name = "Awake (Understanding) Reference", location = "Reference 4" },
                { name = "Constellations Reference", location = "Reference 5" },
            },
            misc = {
                { name = "Constellations", type = "Abilities", position = { x = 110.875267, y = 4, z = -62.095192 }, rotation = { x = 0, y = 180, z = 180 } },
            },
            remove = {
                ["Innovation Archive"] = {
                    "Language",
                    "Lantern Oven - Ammonia Consequence",
                    "Family - Hovel Consequence",
                    "Clan of Death - Family Consequence",
                },
            },
            milestoneEvents = {
                ["huntXp"] = {
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 22 },  -- Retired
                },
                ["courage"] = {
                    { rules = "Dragon King Rules", state = 9 },  -- Awake
                    { rules = "Core Rules", state = 83 },  -- See the Truth
                },
                ["understanding"] = {
                    { rules = "Dragon King Rules", state = 9 },  -- Awake
                    { rules = "Core Rules", state = 90 },  -- White Secret
                },
                ["weaponProficiency"] = {
                    { rules = "Core Rules", state = 21 },  -- Specialist
                    { rules = "Core Rules", state = 21 },  -- Master
                },
            },
        },
    },

    timelineEvents = {
        { year = 8, name = "Glowing Crater", type = "RulebookEvent", notCampaign = "People of the Stars" },
    },

    terrain = {
        ["Obsidian Tower"] = { terrainTile = "Obsidian Tower", count = 1 },
        ["Lava Pool"] = { terrainTile = "Lava Pool", count = 1 },
    },

    terrainTileSizes = {
        ["Obsidian Tower"] = { x = 2, y = 2 },
        ["Lava Pool"] = { x = 2, y = 2 },
        ["Gate"] = { x = 2, y = 2 },
    },

    settlementLocationGear = {
        ["Dragon Armory"] = "Dragon Armory Gear",
    },

    armorStats = {
        ["Dragon Armor"]     = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Blast Shield"]     = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Dragonskull Helm"] = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Dragon Gloves"]    = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Dragon Mantle"]    = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Dragon Belt"]      = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
        ["Dragon Boots"]     = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },
        ["Dragon Vestments"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Hazmat Shield"]    = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
    },

    weaponStats = {
        ["Blast Shield"]     = { speed = 1, accuracy = 7, strength = 4 },
        ["Blast Sword"]      = { speed = 2, accuracy = 6, strength = 4 },
        ["Dragon Bite Bolt"] = { speed = 1, accuracy = 6, strength = 6, slow = true, devastating = 1 },
        ["Dragon Chakram"]   = { speed = 2, accuracy = 6, strength = 3 },
        ["Nuclear Knife"]    = { speed = 3, accuracy = 6, strength = 3 },
        ["Nuclear Scythe"]   = { speed = 2, accuracy = 6, strength = 4 },
        ["Talon Knife"]      = { speed = 2, accuracy = 6, strength = 4, paired = true },
        ["Celestial Spear"]  = { speed = 2, accuracy = 5, strength = 4 },
        ["Hazmat Shield"]    = { speed = 2, accuracy = 4, strength = 7 },
        ["Regal Edge"]       = { speed = 1, accuracy = 5, strength = 2, sharp = true },
    },

    guidNames = { ["f3b47c"] = "Dragon King Archive" },

    archiveEntries = {
        archive = "Dragon King Archive",
        entries = {
            { "Dragon King Rules", "Rulebook" },

            { "Constellations", "Abilities" },
            { "Constellations Reference", "References" },
            { "Intimacy (People of the Stars) Reference", "References" },
            { "Awake (Courage) Reference", "References" },
            { "Awake (Understanding) Reference", "References" },

            { "Dragon King Abilities", "Abilities" },
            { "Dragon King Fighting Arts", "Fighting Arts" },
            { "Dragon King Secret Fighting Arts", "Secret Fighting Arts" },
            { "Dragon King Disorders", "Disorders" },
            { "Scythe Proficiency", "Weapon Proficiencies" },
            { "Dragon Armor", "Armor Sets" },
            { "Dragon King Strange Resources", "Strange Resources" },
            { "Dragon King Resources", "Monster Resources" },

            { "Dragon King Terrain", "Terrain" },
            { "Gate", "Terrain" },

            { "Obsidian Tower", "Terrain Tiles" },
            { "Lava Pool", "Terrain Tiles" },
            { "Gate", "Terrain Tiles" },

            { "Dragon King Innovations", "Innovations" },

            { "Dragon Armory Gear", "Gear" },
            { "Dragon King Rare Gear", "Gear" },

            { "Dragon King Settlement Locations", "Settlement Locations" },

            { "Dragon King", "Monster Figurine" },

            { "Dragon King Info", "AI" },
            { "Dragon King Basic Action", "AI" },
            { "Dragon King Basic AI", "AI" },
            { "Dragon King Advanced AI", "AI" },
            { "Dragon King Legendary AI", "AI" },
            { "Dragon King Special AI", "AI" },
            { "Dragon King Hit Locations", "Hit Locations" },
            { "Dragon King Hunt Events", "Monster Hunt Events" },

            { "The Tyrant", "Monster Figurine" },
            { "The Tyrant Info", "AI" },
            { "The Tyrant Basic Action", "AI" },
            { "The Tyrant Basic AI", "AI" },
            { "The Tyrant Advanced AI", "AI" },
            { "The Tyrant Legendary AI", "AI" },
            { "The Tyrant Special AI", "AI" },
            { "The Tyrant Hit Locations", "Hit Locations" },

        },
    },

    rulebooks = {
        {
            name = "Dragon King Rules",
            pages = {
                ["Dragon King Rules"] = {
                    keywords = { "Dragon", "King", "Rulebook", "Rules" },
                    state = 1,
                },
                ["Glowing Crater"] = {
                    keywords = { "Glowing", "Crater" },
                    state = 3,
                    timelineEvent = true,
                },
                ["Showdown: Dragon King"] = {
                    keywords = { "Showdown:", "Dragon", "King" },
                    state = 4,
                    showdown = true,
                },
                ["Meltdown"] = {
                    keywords = { "Meltdown" },
                    state = 5,
                },
                ["Foundlings"] = {
                    keywords = { "Foundlings" },
                    state = 6,
                    timelineEvent = true,
                },
                ["Intimacy (Dragon King)"] = {
                    keywords = { "Intimacy" },
                    state = 7,
                },
                ["Midnight's Children"] = {
                    keywords = { "Midnight's", "Children" },
                    state = 8,
                    timelineEvent = true,
                },
                ["Awake"] = {
                    keywords = { "Awake" },
                    state = 9,
                },
                ["Unveil the Sky"] = {
                    keywords = { "Unveil", "Sky" },
                    state = 10,
                    timelineEvent = true,
                },
                ["Faces in the Sky"] = {
                    keywords = { "Faces", "Sky" },
                    state = 11,
                },
                ["The Tomb"] = {
                    keywords = { "The ", "Tomb" },
                    state = 12,
                    timelineEvent = true,
                },
                ["Showdown: The Tyrant"] = {
                    keywords = { "Showdown:", "Tyrant" },
                    state = 13,
                    showdown = true,
                },
                ["Death of the Dragon King"] = {
                    keywords = { "Death", "of", "the", "Dragon", "King" },
                    state = 14,
                    timelineEvent = true,
                },
            },
        },
    },

    monsters = {
        {
            name = "Dragon King",
            size = { x = 4, y = 4 },
            rules = { "Dragon King Rules", 4 },
            huntTrack = { "M", "H", "M", "M", "H", "O", "M", "H", "H", "M", "H" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "Toppled Pillar",
                    positions = { "(4.5, 3)", "(18.5, 14)" },
                    rotations = { { x = 0, y = 90, z = 0 }, { x = 0, y = -90, z = 0 } },
                },
                {
                    terrain = "3 Stone Columns",
                    positions = { "(15.5, 2)", "(5, 11.5)", "(8.5, 15)" },
                    rotations = { { x = 0, y = -90, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 } },
                },
            },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 5,
                    showdown = {
                        basic  = 8,
                        advanced = 4,
                        starting = {
                            special = { "Irradiate", "Unseen Agony" },
                        },
                        movement = 10,
                        toughness = 13,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic  = 8,
                        advanced = 7,
                        legendary = 1,
                        starting = {
                            special = { "Irradiate", "Unseen Agony" },
                        },
                        movement = 10,
                        toughness = 15,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic  = 9,
                        advanced = 8,
                        legendary = 2,
                        starting = {
                            special = { "Irradiate", "Unseen Agony", "Smolder" },
                        },
                        movement = 10,
                        toughness = 17,
                        speed = 2,
                        damage = 2,
                        luck = 1,
                    },
                },
                {
                    name = "Death of the Dragon King",
                    level = 3,
                    showdown = {
                        rules = { "Dragon King Rules", 14 },
                        position = "(11.5, 3.5)",
                        customBasic  = { "Gnash", "One-Two Punch", "Overheat", "Rough Smack" },
                        customAdvanced = { "Ashen Return", "Countdown", "Crisis Crater", "Glowing Fist", "Heated Strike", "Mournful Swipe" },
                        customLegendary = { "Death Descending" },
                        starting = {
                            special = { "Irradiate", "Unseen Agony", "Smolder" },
                            misc = { "Trample" },
                        },
                        life = 20,
                        movement = 10,
                        toughness = 17,
                        speed = 2,
                        damage = 3,
                        fixedTerrain = {
                            {
                                terrain = "Toppled Pillar",
                                positions = { "(4, 3.5)", "(19, 3.5)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                            },
                            {
                                terrain = "3 Stone Columns",
                                positions = { "(7, 5.5)", "(5.5, 11)", "(9.5, 14)", "(16, 5.5)", "(17.5, 11)", "(13.5, 14)" },
                                rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 90, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 } },
                            },
                        },
                    },
                },
            },
        },
        {
            name = "The Tyrant",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Dragon King Rules", 13 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(8, 5)", "(15, 5)", "(8, 11)", "(15, 11)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            specialTerrain = {
                {
                    terrain = "Gate",
                    miscObject = { name = "Gate", type = "Terrain Tiles" },
                },
            },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        starting = {
                            special = { "Crooked Step", "Spectral Blast", "Destiny's Marrow" },
                        },
                        basic = 6,
                        advanced = 5,
                        movement = 6,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        starting = {
                            special = { "Crooked Step", "Spectral Blast", "Destiny's Marrow", "Quickened" },
                        },
                        basic = 8,
                        advanced = 6,
                        movement = 7,
                        toughness = 10,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        starting = {
                            special = { "Crooked Step", "Spectral Blast", "Destiny's Marrow", "Quickened" },
                        },
                        basic = 12,
                        advanced = 8,
                        legendary = 2,
                        movement = 7,
                        toughness = 14,
                        speed = 2,
                        damage = 2,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Expansion/CommunityEdition", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Community Edition",

    archiveOverrides = {
        newArchive = "Community Edition Archive",
        oldArchive = "Core Archive",
        entries = {
            { "Core Rules", "Rulebook" },
            { "Intimacy Reference", "References"},

            { "Core Abilities", "Abilities" },
            { "Core Secret Fighting Arts", "Secret Fighting Arts" },
            { "Core Weapon Proficiencies", "Weapon Proficiencies" },
            { "Core Armor Sets", "Armor Sets" },
            { "Core Strange Resources", "Strange Resources" },

            { "Core Settlement Events", "Settlement Events" },

            { "Core Innovations", "Innovations" },

            { "Core Settlement Locations", "Settlement Locations" },

            { "Barber Surgeon Gear", "Gear" },
            { "Blacksmith Gear", "Gear" },
            { "Bone Smith Gear", "Gear" },
            { "Catarium Gear", "Gear" },
            { "Giga-Catarium Gear", "Gear" },
            { "Exhausted Lantern Hoard Gear", "Gear" },
            { "Leather Worker Gear", "Gear" },
            { "Mask Maker Gear", "Gear" },
            { "Plumery Gear", "Gear" },
            { "Skinnery Gear", "Gear" },
            { "Stone Circle Gear", "Gear" },
            { "Weapon Crafter Gear", "Gear" },
            { "Core Rare Gear", "Gear" },
            { "Promo Gear", "Gear" },
        },
    },

    settlementLocationGear = {
        ["Barber Surgeon (CE)"] = "Barber Surgeon Gear",
        ["Blacksmith (CE)"] = "Blacksmith Gear",
        ["Bone Smith (CE)"] = "Bone Smith Gear",
        ["Catarium (CE)"] = "Catarium Gear",
        ["Giga-Catarium (CE)"] = "Giga-Catarium Gear",
        ["Plumery (CE)"] = "Plumery Gear",
        ["Skinnery (CE)"] = "Skinnery Gear",
        ["Stone Circle (CE)"] = "Stone Circle Gear",
        ["Weapon Crafter (CE)"] = "Weapon Crafter Gear",
    },

    armorStats = {
        ["Scrap Shield (CE)"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },

        ["White Lion Armor (CE)"]    = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
        ["Lion Headdress (CE)"]      = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Helm (CE)"]     = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Gauntlet (CE)"] = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["White Lion Coat (CE)"]     = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["White Lion Skirt (CE)"]    = { head = 0, arms = 0, body = 0, waist = 2, legs = 0 },
        ["White Lion Boots (CE)"]    = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },

        ["Antelope Mask (CE)"]   = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["God Mask (CE)"]        = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Man Mask (CE)"]        = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Phoenix Mask (CE)"]    = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Mask (CE)"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Phoenix Gauntlet (CE)"] = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Phoenix Faulds (CE)"]   = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
        ["Phoenix Greaves (CE)"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },

        ["Screaming Horns (CE)"]  = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Forsaker Mask (CE)"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Regal Helm (CE)"]     = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Regal Gauntlet (CE)"] = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Regal Plackart (CE)"] = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Regal Faulds (CE)"]   = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
        ["Regal Greaves (CE)"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },
    },

    weaponStats = {
        ["Dragon Slayer (CE)"] = { speed = 1, accuracy = 6, strength = 9, slow = true, sharp = true, devastating = 1, earlyIron = true },
        ["Dragon Slayer (Broken)"] = { speed = 2, accuracy = 6, strength = 0, earlyIron = true },
        ["Lantern Dagger (CE)"] = { speed = 2, accuracy = 7, strength = 2, sharp = true, paired = true, earlyIron = true },
        ["Lantern Glaive (CE)"] = { speed = 2, accuracy = 6, strength = 4, sharp = true, earlyIron = true },
        ["Lantern Sword (CE)"] = { speed = 3, accuracy = 5, strength = 3, sharp = true, earlyIron = true },
        ["Ring Whip (CE)"] = { speed = 2, accuracy = 5, strength = 3, sharp = true, earlyIron = true },
        ["Bone Axe (CE)"] = { speed = 2, accuracy = 6, strength = 3 },
        ["Bone Axe (Broken)"] = { speed = 2, accuracy = 6, strength = 1 },
        ["Bone Blade (CE)"] = { speed = 2, accuracy = 6, strength = 2 },
        ["Bone Blade (Broken)"] = { speed = 2, accuracy = 7, strength = 1 },
        ["Bone Dagger (CE)"] = { speed = 3, accuracy = 7, strength = 1, paired = true },
        ["Bone Darts (CE)"] = { speed = 1, accuracy = 7, strength = 3 },
        ["Cat Fang Knife (CE)"] = { speed = 3, accuracy = 6, strength = 4, paired = true },
        ["King Spear (CE)"] = { speed = 2, accuracy = 6, strength = 3 },
        ["Oxidized Lantern Dagger (CE)"] = { speed = 3, accuracy = 6, strength = 4, sharp = true, paired = true },
        ["Oxidized Ring Whip (CE)"] = { speed = 2, accuracy = 5, strength = 5, sharp = true },
        ["Hunter Whip (CE)"] = { speed = 3, accuracy = 6, strength = 4 },
        ["Hollow Sword (CE)"] = { speed = 3, accuracy = 5, strength = 5, paired = true },
        ["Hollow Sword (Broken)"] = { speed = 2, accuracy = 6, strength = 4, paired = true },
        ["Sonic Tomahawk (CE)"] = { speed = 2, accuracy = 6, strength = 5, paired = true },
        ["Lantern Halberd (CE)"] = { speed = 2, accuracy = 4, strength = 7 },
        ["Muramasa (CE)"] = { speed = 6, accuracy = 6, strength = 6, sharp = true, deadly = 2 },
        ["Thunder Maul (CE)"] = { speed = 2, accuracy = 6, strength = 10},
        ["Rawhide Whip (CE)"] = { speed = 3, accuracy = 7, strength = 1 },
        ["Beast Knuckle (CE)"] = { speed = 2, accuracy = 5, strength = 4, paired = true },
        ["Lance of Longinus (CE)"] = { speed = 2, accuracy = 6, strength = 9 },
        ["Counterweighted Axe (CE)"] = { speed = 2, accuracy = 6, strength = 4 },
        ["Rainbow Katana (CE)"] = { speed = 4, accuracy = 4, strength = 4 },
        ["Scrap Shield (CE)"] = { speed = 2, accuracy = 7, strength = 5 },
        ["Scrap Sword (CE)"] = { speed = 2, accuracy = 5, strength = 3 },
        ["Skullcap Hammer (CE)"] = { speed = 2, accuracy = 5, strength = 5 },
        ["Whistling Mace"] = { speed = 3, accuracy = 6, strength = 3 },
        ["Whistling Mace (CE)"] = { speed = 3, accuracy = 6, strength = 4 },
        ["Zanbato (CE)"] = { speed = 1, accuracy = 6, strength = 6, slow = true, deadly = 1 },
        ["Zanbato (Broken)"] = { speed = 2, accuracy = 6, strength = 3 },
    },

    guidNames = { ["49ea5e"] = "Community Edition Archive" },
}

end)
__bundle_register("Kdm/Expansion/Core", function(require, _LOADED, __bundle_register, __bundle_modules)
return {
    name = "Core",
    --Test
    components = {
        ["Abilities"] = "Core Abilities",
        ["Fighting Arts"] = "Core Fighting Arts",
        ["Secret Fighting Arts"] = "Core Secret Fighting Arts",
        ["Disorders"] = "Core Disorders",
        ["Severe Injuries"] = "Core Severe Injuries",
        ["Weapon Proficiencies"] = "Core Weapon Proficiencies",
        ["Armor Sets"] = "Core Armor Sets",
        ["Vermin"] = "Core Vermin",
        ["Strange Resources"] = "Core Strange Resources",
        ["Basic Resources"] = "Core Basic Resources",
        ["Terrain"] = "Core Terrain",
        ["Terrain Tiles"] = "Core Terrain Tiles",
        ["Settlement Events"] = "Core Settlement Events",
        ["Innovations"] = "Core Innovations",
        ["Settlement Locations"] = "Core Settlement Locations",
        ["Rare Gear"] = "Core Rare Gear",
        ["Hunt Events"] = "Core Hunt Events",

        ["Patterns"] = "Core Patterns",
    },

    settlementEvents = {
        "Heat Wave",
        "Rivalry",
        "Hunt Reenactment",
        "Nickname",
        "Glossolalia",
        "Dark Dentist",
        "Plague",
        "Dark Trader",
        "Skull Eater",
        "Open Maw",
        "Triathlon of Death",
        "First Day",
        "Cracks in the Ground",
        "Weird Dream",
        "Acid Storm",
        "Haunted",
        "Murder",
        "Elder Council",
        "Clinging Mist",
        "Lights in the Sky",
        "Stranger in the Dark",
        "Story in the Snow",  --1.6
        "Dark Seamstress",    --1.6
    },

    campaigns = {
        {
            name = "People of the Lantern",
            timeline = {
                { year = 1, type = "RulebookEvent", name = "Returning Survivors" },
                { year = 2, type = "RulebookEvent", name = "Endless Screams" },
                { year = 4, type = "ShowdownEvent", monster = "Butcher", level = "Level 1" },
                { year = 5, type = "RulebookEvent", name = "Hands of Heat" },
                { year = 6, type = "RulebookEvent", name = "Armored Strangers" },
                { year = 7, type = "RulebookEvent", name = "Phoenix Feather" },
                { year = 9, type = "ShowdownEvent", monster = "King's Man", level = "Level 1" },
                { year = 11, type = "RulebookEvent", name = "Regal Visit" },
                { year = 12, type = "RulebookEvent", name = "Principle: Conviction" },
                { year = 13, type = "ShowdownEvent", monster = "The Hand", level = "Level 1" },
                { year = 16, type = "ShowdownEvent", monster = "Butcher", level = "Level 2" },
                { year = 19, type = "ShowdownEvent", monster = "King's Man", level = "Level 2" },
                { year = 20, type = "RulebookEvent", name = "Watched" },
                { year = 23, type = "ShowdownEvent", monster = "Butcher", level = "Level 3" },
                { year = 25, type = "ShowdownEvent", monster = "Watcher" },
                { year = 28, type = "ShowdownEvent", monster = "King's Man", level = "Level 3" },
                { year = 30, type = "ShowdownEvent", monster = "Gold Smoke Knight" },
            },
            survivalActions = {
                { name = "Dodge", checked = true },
                { name = "Encourage" },
                { name = "Dash" },
                { name = "Surge" },
                { name = "Endure" },
            },
            milestones = {
                { name = "First Birth", event = "Principle: New Life" },
                { name = "First Death", event = "Principle: Death" },
                { name = "15 Population", event = "Principle: Society" },
                { name = "5 Innovations", event = "Hooded Knight" },
            },
            objectsByLocation = {
                ["Innovation Deck"] = { tag = "Deck", name = "Innovation Deck", type = "Innovations", faceDown = true, cards = {
                    { name = "Ammonia - Language Consequence", type = "Innovations" },
                    { name = "Drums - Language Consequence", type = "Innovations" },
                    { name = "Hovel - Language Consequence", type = "Innovations" },
                    { name = "Inner Lantern - Language Consequence", type = "Innovations" },
                    { name = "Paint - Language Consequence", type = "Innovations" },
                    { name = "Symposium - Language Consequence", type = "Innovations" },
                } },
                ["Principle: Death"] = { tag = "Deck", name = "Principle: Death", type = "Innovations", faceDown = true, cards = {
                    { name = "Cannibalize - Death Principle", type = "Innovations" },
                    { name = "Graves - Death Principle", type = "Innovations" },
                } },
                ["Principle: New Life"] = { tag = "Deck", name = "Principle: New Life", type = "Innovations", faceDown = true, cards = {
                    { name = "Protect the Young - New Life Principle", type = "Innovations" },
                    { name = "Survival of the Fittest - New Life Principle", type = "Innovations" },
                } },
                ["Principle: Society"] = { tag = "Deck", name = "Principle: Society", type = "Innovations", faceDown = true, cards = {
                    { name = "Accept Darkness - Society Principle", type = "Innovations" },
                    { name = "Collective Toil - Society Principle", type = "Innovations" },
                } },
                ["Principle: Conviction"] = { tag = "Deck", name = "Principle: Conviction", type = "Innovations", faceDown = true, cards = {
                    { name = "Barbaric - Conviction Principle", type = "Innovations" },
                    { name = "Romantic - Conviction Principle", type = "Innovations" },
                } },
                ["Innovation 1"] = { tag = "Card", name = "Language", type = "Innovations" },
                ["Settlement Location 1"] = { tag = "Card", name = "Lantern Hoard", type = "Settlement Locations" },
            },
            references = {
                { name = "Age Reference", location = "Reference 1" },
                { name = "Intimacy Reference", location = "Reference 2" },
                { name = "Bold Reference", location = "Reference 3" },
                { name = "Insight Reference", location = "Reference 4" },
            },
            milestoneEvents = {
                ["huntXp"] = {
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 53 },  -- Age
                    { rules = "Core Rules", state = 22 },  -- Retired
                },
                ["courage"] = {
                    { rules = "Core Rules", state = 56 },  -- Bold
                    { rules = "Core Rules", state = 83 },  -- See the Truth
                },
                ["understanding"] = {
                    { rules = "Core Rules", state = 65 },  -- Insight
                    { rules = "Core Rules", state = 90 },  -- White Secret
                },
                ["weaponProficiency"] = {
                    { rules = "Core Rules", state = 21 },  -- Specialist
                    { rules = "Core Rules", state = 21 },  -- Master
                },
            },
        },
    },

    terrain = {
        ["2 Acanthus Plants"]    = { terrainTile = "Acanthus",           count = 2 },
        ["Bug Patch"]            = { terrainTile = "Bug Patch",          count = 1 },
        ["Dead Monster"]         = { terrainTile = "Dead Monster",       count = 1 },
        ["Debris"]               = { terrainTile = "Debris",             count = 1 },
        ["Giant Stone Face"]     = { terrainTile = "Giant Stone Face",   count = 1 },
        ["Nightmare Tree"]       = { terrainTile = "Nightmare Tree",     count = 1 },
        ["Ore Vein"]             = { terrainTile = "Ore Vein",           count = 1 },
        ["3 Stone Columns"]      = { terrainTile = "Stone Column",       count = 3 },
        ["Survivor Corpse"]      = { terrainTile = "Survivor Corpse",    count = 1 },
        ["2 Tall Grass"]         = { terrainTile = "Tall Grass",         count = 2 },
        ["Toppled Pillar"]       = { terrainTile = "Toppled Pillar",     count = 1 },
        ["Hovel"]                = { terrainTile = "Hovel",              count = 2 },
        ["2 Cowering Survivors"] = { terrainTile = "Cowering Survivors", count = 2 },
    },

    terrainTileSizes  = {
        ["Acanthus"]           = { x = 1, y = 1 },
        ["Bug Patch"]          = { x = 1, y = 1 },
        ["Dead Monster"]       = { x = 2, y = 2 },
        ["Debris"]             = { x = 1, y = 1 },
        ["Giant Stone Face"]   = { x = 2, y = 3 },
        ["Nightmare Tree"]     = { x = 3, y = 3 },
        ["Ore Vein"]           = { x = 1, y = 1 },
        ["Stone Column"]       = { x = 1, y = 2 },
        ["Survivor Corpse"]    = { x = 1, y = 1 },
        ["Tall Grass"]         = { x = 2, y = 2 },
        ["Toppled Pillar"]     = { x = 1, y = 4 },
        ["Hovel"]              = { x = 2, y = 2 },
        ["Cowering Survivors"] = { x = 1, y = 1},
    },

    settlementLocationGear = {
        ["Exhausted Lantern Hoard"]  = "Exhausted Lantern Hoard Gear",
        ["Skinnery"]                 = "Skinnery Gear",
        ["Bone Smith"]               = "Bone Smith Gear",
        ["Organ Grinder"]            = "Organ Grinder Gear",
        ["Leather Worker"]           = "Leather Worker Gear",
        ["Weapon Crafter"]           = "Weapon Crafter Gear",
        ["Blacksmith"]               = "Blacksmith Gear",
        ["Barber Surgeon"]           = "Barber Surgeon Gear",
        ["Mask Maker"]               = "Mask Maker Gear",
        ["Catarium"]                 = "Catarium Gear",
        ["Giga-Catarium"]            = "Giga-Catarium Gear",
        ["Stone Circle"]             = "Stone Circle Gear",
        ["Plumery"]                  = "Plumery Gear",
        ["Song of the Green Knight"] = "Green Armor",
    },

    armorStats = {
        ["Oxidized Beacon Shield"]  = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },

        ["Beacon Shield"]     = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
        ["Lantern Helm"]      = { head = 5, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Lantern Gauntlets"] = { head = 0, arms = 5, body = 0, waist = 0, legs = 0 },
        ["Lantern Cuirass"]   = { head = 0, arms = 0, body = 5, waist = 0, legs = 0 },
        ["Lantern Mail"]      = { head = 0, arms = 0, body = 0, waist = 5, legs = 0 },
        ["Lantern Greaves"]   = { head = 0, arms = 0, body = 0, waist = 0, legs = 5 },

        ["Scrap Shield"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },

        ["Skull Helm"] = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },

        ["White Lion Armor"]      = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Lion Headdress"]        = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Helm"]       = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Gauntlet"]   = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["White Lion Coat"]       = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Lion Slayer Cape"]      = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },
        ["White Lion Skirt"]      = { head = 0, arms = 0, body = 0, waist = 2, legs = 0 },
        ["White Lion Boots"]      = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },

        ["Green Armor"]  = { head = 5, arms = 5, body = 5, waist = 5, legs = 5, modifier = true },
        ["Fetorsaurus"]  = { head = 2, arms = 2, body = 2, waist = 2, legs = 2, modifier = true },
        ["Green Helm"]   = { head = 5, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Green Gloves"] = { head = 0, arms = 5, body = 0, waist = 0, legs = 0 },
        ["Green Plate"]  = { head = 0, arms = 0, body = 5, waist = 0, legs = 0 },
        ["Green Faulds"] = { head = 0, arms = 0, body = 0, waist = 5, legs = 0 },
        ["Green Boots"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 5 },

        ["Leather Armor"]   = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Leather Shield"]  = { head = 1, arms = 1, body = 1, waist = 1, legs = 1 },
        ["Leather Mask"]    = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Leather Bracers"] = { head = 0, arms = 3, body = 0, waist = 0, legs = 0 },
        ["Leather Cuirass"] = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Leather Skirt"]   = { head = 0, arms = 0, body = 0, waist = 3, legs = 0 },
        ["Leather Boots"]   = { head = 0, arms = 0, body = 0, waist = 0, legs = 3 },

        ["Antelope Mask"]   = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Death Mask"]      = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["God Mask"]        = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Man Mask"]        = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Phoenix Mask"]    = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["White Lion Mask"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Phoenix Armor"]    = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Phoenix Helm"]     = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Phoenix Gauntlet"] = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Phoenix Plackart"] = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Phoenix Faulds"]   = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
        ["Phoenix Greaves"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },

        ["Cloth Leggings"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 1 },
        ["Corsair Coat"] = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Detective Cap"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Dormant Twilight Cloak"] = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Hard Breastplate"] = { head = 0, arms = 0, body = 3, waist = 0, legs = 0 },
        ["Piranha Helm"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Scout's Tunic"] = { head = 2, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Speaker Mask"] = { head = 3, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Tabard"] = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },
        ["White Dragon Gauntlets"] = { head = 0, arms = 12, body = 0, waist = 0, legs = 0 },
        ["Vagabond Armor"]   = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },

        ["Forsaker Mask"] = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Regal Helm"]     = { head = 4, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Regal Gauntlet"] = { head = 0, arms = 4, body = 0, waist = 0, legs = 0 },
        ["Regal Plackart"] = { head = 0, arms = 0, body = 4, waist = 0, legs = 0 },
        ["Regal Faulds"]   = { head = 0, arms = 0, body = 0, waist = 4, legs = 0 },
        ["Regal Greaves"]  = { head = 0, arms = 0, body = 0, waist = 0, legs = 4 },

        ["Rawhide Armor"]    = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Rawhide Headband"] = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Rawhide Gloves"]   = { head = 0, arms = 1, body = 0, waist = 0, legs = 0 },
        ["Rawhide Vest"]     = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },
        ["Rawhide Pants"]    = { head = 0, arms = 0, body = 0, waist = 1, legs = 0 },
        ["Rawhide Boots"]    = { head = 0, arms = 0, body = 0, waist = 0, legs = 1 },

        ["Cloth"] = { head = 0, arms = 0, body = 0, waist = 1, legs = 0 },

        ["Screaming Armor"]       = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },
        ["Screaming Horns"]       = { head = 2, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Screaming Bracers"]     = { head = 0, arms = 2, body = 0, waist = 0, legs = 0 },
        ["Screaming Coat"]        = { head = 0, arms = 0, body = 2, waist = 0, legs = 0 },
        ["Screaming Skirt"]       = { head = 0, arms = 0, body = 0, waist = 2, legs = 0 },
        ["Screaming Leg Warmers"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 2 },

        ["Crystal Skin"] = { head = 3, arms = 3, body = 3, waist = 3, legs = 3, modifier = true },
        ["Shield Proficiency"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1, modifier = true },

        ["Teeth Bikini"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Leather Bodysuit"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Lantern Brassiere"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 0 },
        ["Rawhide Corset"] = { head = 0, arms = 0, body = 0, waist = 0, legs = 0 },

        ["Brave Dirndl"] = { head = 0, arms = 0, body = 1, waist = 1, legs = 0 },

        ["Grim Muffler"] = { head = 0, arms = 0, body = 1, waist = 0, legs = 0 },

        ["Retching Costume"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1 },        
        ["Big Bite Costume"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1 },
        ["Gold Cat Costume"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1 },
        ["Screaming Costume"] = { head = 1, arms = 1, body = 1, waist = 1, legs = 1 },

        ["White Sunlion Mask"] = { head = 1, arms = 0, body = 0, waist = 0, legs = 0 },
    },

    weaponStats = {
        ["Founding Stone"] = { speed = 2, accuracy = 7, strength = 1 },
        ["Fist & Tooth"] = { speed = 2, accuracy = 8, strength = 0, deadly = 1 },

        ["Beacon Shield"] = { speed = 1, accuracy = 6, strength = 5 },
        ["Dragon Slayer"] = { speed = 1, accuracy = 6, strength = 9, slow = true, sharp = true, devastating = 1, earlyIron = true },
        ["Lantern Dagger"] = { speed = 2, accuracy = 7, strength = 1, sharp = true, paired = true, earlyIron = true },
        ["Lantern Glaive"] = { speed = 2, accuracy = 6, strength = 4, sharp = true, earlyIron = true },
        ["Lantern Sword"] = { speed = 3, accuracy = 5, strength = 3, sharp = true, earlyIron = true },
        ["Perfect Slayer"] = { speed = 3, accuracy = 6, strength = 14, slow = true, sharp = true, devastating = 2 },
        ["Ring Whip"] = { speed = 2, accuracy = 5, strength = 0, sharp = true, earlyIron = true },
        ["Scrap Shield"] = { speed = 2, accuracy = 7, strength = 3 },

        ["Bone Axe"] = { speed = 2, accuracy = 6, strength = 3, savage = true },
        ["Bone Blade"] = { speed = 2, accuracy = 6, strength = 2 },
        ["Bone Club"] = { speed = 2, accuracy = 6, strength = 5 },
        ["Bone Dagger"] = { speed = 3, accuracy = 7, strength = 1 },
        ["Bone Darts"] = { speed = 1, accuracy = 7, strength = 3 },
        ["Bone Pickaxe"] = { speed = 1, accuracy = 8, strength = 2 },
        ["Bone Sickle"] = { speed = 2, accuracy = 8, strength = 1 },

        ["Cat Fang Knife"] = { speed = 3, accuracy = 6, strength = 2 },
        ["Cat Gut Bow"] = { speed = 2, accuracy = 7, strength = 3 },
        ["Claw Head Arrow"] = { speed = 1, accuracy = 6, strength = 6, slow = true },
        ["Dense Bone Arrows"] = { speed = 1, accuracy = 5, strength = 6, sharp = true },
        ["Hooked Claw Knife"] = { speed = 3, accuracy = 6, strength = 7 },
        ["King Spear"] = { speed = 2, accuracy = 6, strength = 3 },
        ["Lion Beast Katar"] = { speed = 2, accuracy = 7, strength = 3, deadly = 1, paired = true },
        ["Oxidized Beast Katar"] = { speed = 2, accuracy = 7, strength = 5, deadly = 1, sharp = true, paired = true },

        ["Oxidized Beacon Shield"] = { speed = 1, accuracy = 6, strength = 6 },
        ["Oxidized Lantern Dagger"] = { speed = 3, accuracy = 6, strength = 4, sharp = true, paired = true },
        ["Oxidized Lantern Glaive"] = { speed = 2, accuracy = 5, strength = 6, sharp = true },
        ["Oxidized Lantern Sword"] = { speed = 3, accuracy = 5, strength = 5, sharp = true },
        ["Oxidized Ring Whip"] = { speed = 2, accuracy = 5, strength = 3, sharp = true },

        ["Fetorsaurus"] = { speed = 2, accuracy = 5, strength = 9 },
        ["Griswaldo"] = { speed = 3, accuracy = 4, strength = 15, sharp = true, deadly = 1, savage = 1 },

        ["Hunter Whip"] = { speed = 3, accuracy = 6, strength = 3 },
        ["Leather Shield"] = { speed = 1, accuracy = 8, strength = 1 },

        ["Arc Bow"] = { speed = 1, accuracy = 6, strength = 9, slow = true },
        ["Feather Shield"] = { speed = 3, accuracy = 7, strength = 0 },
        ["Hollowpoint Arrow"] = { speed = 1, accuracy = 6, strength = 11, slow = true },
        ["Hollow Sword"] = { speed = 2, accuracy = 5, strength = 5 },
        ["Sonic Tomahawk"] = { speed = 3, accuracy = 5, strength = 6 },
        ["Finger of God"] = { speed = 2, accuracy = 5, strength = 5 },
        ["Rainbow Katana"] = { speed = 4, accuracy = 4, strength = 4 },

        ["Arm of the First Tree"] = { speed = 2, accuracy = 6, strength = 4 },
        ["Aya's Sword"] = { speed = 2, accuracy = 7, strength = 3 },
        ["Aya's Spear"] = { speed = 2, accuracy = 7, strength = 3 },
        ["Blood Plasma Gun"] = { speed = 0, accuracy = 4, strength = 0 },
        ["Blood Plasma Katana"] = { speed = 9, accuracy = 6, strength = 9, sharp = true, devastating = 1 },
        ["Giant Stone Face"] = { speed = 1, accuracy = 6, strength = 5, devastating = 1 },
        ["Hope Stealer"] = { speed = 2, accuracy = 6, strength = 0 },
        ["Speaker Cult Knife"] = { speed = 3, accuracy = 6, strength = 4, deadly = 1, sharp = true },
        ["Sword of Silence"] = { speed = 2, accuracy = 5, strength = 6 },
        ["Twilight Revolver"] = { speed = 1, accuracy = 6, strength = 10 },
        ["Xmaxe"] = { speed = 2, accuracy = 5, strength = 0 },

        ["Adventure Sword"] = { speed = 3, accuracy = 6, strength = 0 },
        ["Butcher Cleaver"] = { speed = 2, accuracy = 5, strength = 5, paired = true },
        ["Excalibur"] = { speed = 2, accuracy = 4, strength = 4, savage = true },
        ["Lantern Halberd"] = { speed = 2, accuracy = 4, strength = 7 },
        ["Muramasa"] = { speed = 6, accuracy = 6, strength = 6, sharp = true, deadly = 2 },
        ["Steel Shield"] = { speed = 1, accuracy = 6, strength = 6 },
        ["Steel Sword"] = { speed = 1, accuracy = 4, strength = 5, sharp = true, slow = true },
        ["Thunder Maul"] = { speed = 2, accuracy = 6, strength = 10},
        ["Twilight Sword"] = { speed = 1, accuracy = 9, strength = 9 },
        ["Brazen Bat"] = { speed = 2, accuracy = 5, strength = 6 },
        ["Tempered Spear"] = { speed = 2, accuracy = 5, strength = 5 },
        ["Durendal"] = { speed = 2, accuracy = 6, strength = 9 },
        ["Tempered Axe"] = { speed = 2, accuracy = 6, strength = 6, paired = true },
        ["Plated Shield"] = { speed = 1, accuracy = 8, strength = 3 },
        ["Tempered Dagger"] = { speed = 3, accuracy = 7, strength = 4, paired = true },
        ["Black Ghost Dagger"] = { speed = 3, accuracy = 7, strength = 2 },        

        ["Rawhide Whip"] = { speed = 3, accuracy = 7, strength = 1 },

        ["Beast Knuckle"] = { speed = 2, accuracy = 6, strength = 4, paired = true },
        ["Lance of Longinus"] = { speed = 2, accuracy = 6, strength = 9 },

        ["Counterweighted Axe"] = { speed = 2, accuracy = 6, strength = 4 },
        ["Scrap Dagger"] = { speed = 3, accuracy = 7, strength = 2 },
        ["Scrap Sword"] = { speed = 2, accuracy = 5, strength = 3 },
        ["Skullcap Hammer"] = { speed = 2, accuracy = 7, strength = 3 },
        ["Zanbato"] = { speed = 1, accuracy = 6, strength = 6, slow = true, deadly = 1 },
        ["Scrap Bone Spear"] = { speed = 2, accuracy = 6, strength = 3 },

    },

    guidNames = { ["6392cb"] = "Core Archive" },

    archiveEntries = {
        archive = "Core Archive",
        entries = {
            { "Core Rules", "Rulebook" },
            { "Age Reference", "References" },
            { "Intimacy Reference", "References" },
            { "Bold Reference", "References" },
            { "Insight Reference", "References" },

            { "Core Abilities", "Abilities" },
            { "Core Fighting Arts", "Fighting Arts" },
            { "Core Secret Fighting Arts", "Secret Fighting Arts" },
            { "Core Disorders", "Disorders" },
            { "Core Severe Injuries", "Severe Injuries" },
            { "Core Weapon Proficiencies", "Weapon Proficiencies" },
            { "Core Armor Sets", "Armor Sets" },
            { "Core Vermin", "Vermin" },
            { "Core Strange Resources", "Strange Resources" },
            { "Core Basic Resources", "Basic Resources" },

            { "Core Terrain", "Terrain" },
            { "Core Terrain Tiles", "Terrain Tiles" },

            { "Core Settlement Events", "Settlement Events" },

            { "Core Innovations", "Innovations" },

            { "Core Settlement Locations", "Settlement Locations" },

            { "Starting Gear", "Gear" },
            { "Core Rare Gear", "Gear" },
            { "Promo Gear", "Gear" },
            { "Barber Surgeon Gear", "Gear" },
            { "Blacksmith Gear", "Gear" },
            { "Bone Smith Gear", "Gear" },
            { "Catarium Gear", "Gear" },
            { "Giga-Catarium Gear", "Gear" },
            { "Exhausted Lantern Hoard Gear", "Gear" },
            { "Green Armor" , "Gear" },
            { "Leather Worker Gear", "Gear" },
            { "Mask Maker Gear", "Gear" },
            { "Organ Grinder Gear", "Gear" },
            { "Plumery Gear", "Gear" },
            { "Skinnery Gear", "Gear" },
            { "Stone Circle Gear", "Gear" },
            { "Weapon Crafter Gear", "Gear" },

            { "Hunt Party", "Hunt Party" },
            { "Core Hunt Events", "Hunt Events" },
            { "The Forest Gate", "Special Hunt Events" },
            { "Herb Gathering", "Special Hunt Events" },
            { "Mineral Gathering", "Special Hunt Events" },
            { "Underground Labyrinth", "Special Hunt Events" },

            { "Misc AI", "AI" },
            { "Battle Pressure", "Hit Locations" },

            { "Butcher", "Monster Figurine" },
            { "Butcher Info", "AI" },
            { "Butcher Basic Action", "AI" },
            { "Butcher Basic AI", "AI" },
            { "Butcher Advanced AI", "AI" },
            { "Butcher Special AI", "AI" },
            { "Butcher Hit Locations", "Hit Locations" },

            { "Gold Smoke Knight", "Monster Figurine" },
            { "Gold Smoke Knight Info", "AI" },
            { "Gold Smoke Knight Basic Action", "AI" },
            { "Gold Smoke Knight Basic AI", "AI" },
            { "Gold Smoke Knight Advanced AI", "AI" },
            { "Gold Smoke Knight Legendary AI", "AI" },
            { "Gold Smoke Knight Special AI", "AI" },
            { "Gold Smoke Knight Hit Locations", "Hit Locations" },

            { "King's Man", "Monster Figurine" },
            { "King's Man Info", "AI" },
            { "King's Man Basic Action", "AI" },
            { "King's Man Basic AI", "AI" },
            { "King's Man Advanced AI", "AI" },
            { "Familiar Face", "AI" },    -- legendary AI
            { "King's Man Special AI", "AI" },
            { "King's Man Hit Locations", "Hit Locations" },

            { "Phoenix", "Monster Figurine" },
            { "Phoenix Info", "AI" },
            { "Phoenix Basic Action", "AI" },
            { "Phoenix Basic AI", "AI" },
            { "Phoenix Advanced AI", "AI" },
            { "Phoenix Legendary AI", "AI" },
            { "Phoenix Special AI", "AI" },
            { "Phoenix Hit Locations", "Hit Locations" },
            { "Phoenix Resources", "Monster Resources" },
            { "Phoenix Hunt Events", "Monster Hunt Events" },

            { "Screaming Antelope", "Monster Figurine" },
            { "Screaming Antelope Info", "AI" },
            { "Screaming Antelope Basic Action", "AI" },
            { "Screaming Antelope Basic AI", "AI" },
            { "Screaming Antelope Advanced AI", "AI" },
            { "Screaming Antelope Legendary AI", "AI" },
            { "Screaming Antelope Special AI", "AI" },
            { "Screaming Antelope Hit Locations", "Hit Locations" },
            { "Screaming Antelope Resources", "Monster Resources" },
            { "Screaming Antelope Hunt Events", "Monster Hunt Events" },

            { "The Hand", "Monster Figurine" },
            { "The Hand Info", "AI" },
            { "The Hand Basic Action", "AI" },
            { "The Hand Basic AI", "AI" },
            { "The Hand Advanced AI", "AI" },
            { "The Hand Special AI", "AI" },
            { "The Hand Hit Locations", "Hit Locations" },

            { "Watcher", "Monster Figurine" },
            { "Watcher Info", "AI" },
            { "Watcher Basic Action", "AI" },
            { "Watcher Basic AI", "AI" },
            { "Watcher Special AI", "AI" },
            { "Watcher Hit Locations", "Hit Locations" },

            { "White Lion", "Monster Figurine" },
            { "White Lion Info", "AI" },
            { "White Lion Basic Action", "AI" },
            { "White Lion Basic AI", "AI" },
            { "White Lion Advanced AI", "AI" },
            { "White Lion Legendary AI", "AI" },
            { "White Lion Special AI", "AI" },
            { "White Lion Hit Locations", "Hit Locations" },
            { "White Lion Resources", "Monster Resources" },
            { "White Lion Hunt Events", "Monster Hunt Events" },

            { "White Gigalion Rules", "Rulebook" },
            { "White Gigalion", "Monster Figurine" },
            { "White Gigalion Info", "AI" },
            { "White Gigalion Basic Action", "AI" },
            { "White Gigalion Hit Locations", "Hit Locations" },

            { "Core Patterns", "Patterns" },
        },
    },

    rulebooks = {
        {
            name = "Core Rules",
            pages = {
                ["Introduction"] = {
                    keywords = { "Introduction" },
                    state = 1,
                },
                ["Prologue"] = {
                    keywords = { "Prologue" },
                    state = 2,
                },
                ["First Story"] = {
                    keywords = { "First", "Story" },
                    state = 11,
                },
                ["Survival Guide"] = {
                    keywords = { "Survival", "Guide" },
                    state = 18,
                },
                ["Survivors"] = {
                    keywords = { "Survivors" },
                    state = 20,
                },
                ["Monsters"] = {
                    keywords = { "Monsters" },
                    state = 24,
                },
                ["Resources"] = {
                    keywords = { "Resources" },
                    state = 28,
                },
                ["Terrain"] = {
                    keywords = { "Terrain" },
                    state = 29,
                },
                ["Hunt Phase"] = {
                    keywords = { "Hunt", "Phase" },
                    state = 30,
                },
                ["Showdown Phase"] = {
                    keywords = { "Showdown:", "Phase" },
                    state = 32,
                },
                ["Settlement Phase"] = {
                    keywords = { "Settlement", "Phase" },
                    state = 40,
                },
                ["Severe Injuries"] = {
                    keywords = { "Severe", "Injuries", "Injury" },
                    state = 43,
                },
                ["Brain Trauma"] = {
                    keywords = { "Brain", "Trauma" },
                    state = 44,
                },
                ["Hunt Events 1-11"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 1,
                    huntEventEnd = 11,
                    state = 45,
                },
                ["Hunt Events 12-25"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 12,
                    huntEventEnd = 25,
                    state = 46,
                },
                ["Hunt Events 26-38"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 26,
                    huntEventEnd = 38,
                    state = 47,
                },
                ["Hunt Events 39-53"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 39,
                    huntEventEnd = 53,
                    state = 48,
                },
                ["Hunt Events 54-69"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 54,
                    huntEventEnd = 69,
                    state = 49,
                },
                ["Hunt Events 70-79"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 70,
                    huntEventEnd = 79,
                    state = 50,
                },
                ["Hunt Events 80-94"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 80,
                    huntEventEnd = 94,
                    state = 51,
                },
                ["Hunt Events 95-100"] = {
                    keywords = { "Hunt", "Events" },
                    huntEventStart = 95,
                    huntEventEnd = 100,
                    state = 52,
                },
                ["Age"] = {
                    keywords = { "Age", "XP" },
                    state = 53,
                },
                ["Armored Strangers"] = {
                    keywords = { "Armored", "Strangers" },
                    state = 54,
                    timelineEvent = true,
                },
                ["Birth of a Savior"] = {
                    keywords = { "Birth", "Savior" },
                    state = 55,
                },
                ["Bold"] = {
                    keywords = { "Bold", "Courage" },
                    state = 56,
                },
                ["Bone Witch"] = {
                    keywords = { "Bone", "Witch" },
                    state = 57,
                    timelineEvent = true,
                },
                ["Cooking"] = {
                    keywords = { "Cooking" },
                    state = 58,
                },
                ["Crush & Devour"] = {
                    keywords = { "Crush", "Devour", "Screaming", "Antelope" },
                    state = 59,
                },
                ["Endless Screams"] = {
                    keywords = { "Endless", "Screams" },
                    state = 60,
                    timelineEvent = true,
                },
                ["Game Over"] = {
                    keywords = { "Game", "Over" },
                    state = 61,
                },
                ["Hands of Heat"] = {
                    keywords = { "Hands", "of", "Heat" },
                    state = 62,
                    timelineEvent = true,
                },
                ["Herb Gathering"] = {
                    keywords = { "Herb", "Gathering" },
                    state = 63,
                },
                ["Hooded Knight"] = {
                    keywords = { "Hooded", "Knight" },
                    state = 64,
                    timelineEvent = true,
                },
                ["Insight"] = {
                    keywords = { "Insight", "Understanding" },
                    state = 65,
                },
                ["Intimacy"] = {
                    keywords = { "Intimacy" },
                    state = 66,
                },
                ["King's Curse"] = {
                    keywords = { "King's", "Curse", "Man", "Regal" },
                    state = 67,
                },
                ["King's Step"] = {
                    keywords = { "King's", "Step", "Man" },
                    state = 68,
                },
                ["Lantern Research"] = {
                    keywords = { "Lantern", "Research" },
                    state = 69,
                },
                ["Legendary Lungs"] = {
                    keywords = { "Legendary", "Lungs", "Butcher" },
                    state = 70,
                },
                ["Legendary Monsters"] = {
                    keywords = { "Legendary", "Monsters" },
                    state = 71,
                },
                ["Mineral Gathering"] = {
                    keywords = { "Mineral", "Gathering", "Mining" },
                    state = 72,
                },
                ["Overwhelming Darkness"] = {
                    keywords = { "Overwhelming", "Darkness" },
                    state = 73,
                },
                ["Oxidation"] = {
                    keywords = { "Oxidation" },
                    state = 74,
                },
                ["Phoenix Feather"] = {
                    keywords = { "Phoenix", "Feather" },
                    state = 75,
                    timelineEvent = true,
                },
                ["Principle: Conviction"] = {
                    keywords = { "Principle", "Conviction" },
                    state = 76,
                    timelineEvent = true,
                },
                ["Principle: Death"] = {
                    keywords = { "Principle", "Death" },
                    state = 77,
                    timelineEvent = true,
                },
                ["Principle: New Life"] = {
                    keywords = { "Principle", "New", "Life" },
                    state = 78,
                    timelineEvent = true,
                },
                ["Principle: Society"] = {
                    keywords = { "Principle", "Society" },
                    state = 79,
                    timelineEvent = true,
                },
                ["Regal Visit"] = {
                    keywords = { "Regal", "Visit", "The", "Hand" },
                    state = 80,
                    timelineEvent = true,
                },
                ["Returning Survivors"] = {
                    keywords = { "Returning", "Survivors" },
                    state = 81,
                    timelineEvent = true,
                },
                ["Run Away"] = {
                    keywords = { "Run", "Away" },
                    state = 82,
                },
                ["See the Truth"] = {
                    keywords = { "See", "Truth", "Courage" },
                    state = 83,
                },
                ["Showdown: Butcher"] = {
                    keywords = { "Showdown:", "Butcher" },
                    state = 84,
                    showdown = true,
                },
                ["Showdown: The Hand"] = {
                    keywords = { "Showdown:", "The", "Hand" },
                    state = 85,
                    showdown = true,
                },
                ["Showdown: King's Man"] = {
                    keywords = { "Showdown:", "King's", "Man" },
                    state = 86,
                    showdown = true,
                },
                ["Showdown: Phoenix"] = {
                    keywords = { "Showdown:", "Phoenix" },
                    state = 87,
                    showdown = true,
                },
                ["Showdown: Screaming Antelope"] = {
                    keywords = { "Showdown:", "Screaming", "Antelope" },
                    state = 88,
                    showdown = true,
                },
                ["Showdown: White Lion"] = {
                    keywords = { "Showdown:", "White", "Lion" },
                    state = 89,
                    showdown = true,
                },
                ["White Secret"] = {
                    keywords = { "White", "Secret", "Understanding" },
                    state = 90,
                },
                ["White Speaker"] = {
                    keywords = { "White", "Speaker" },
                    state = 91,
                },
                ["Zero Presence"] = {
                    keywords = { "Zero", "Presence" },
                    state = 92,
                },
                ["Watched"] = {
                    keywords = { "Watched" },
                    state = 93,
                    timelineEvent = true,
                },
                ["Showdown: Watcher"] = {
                    keywords = { "Showdown:", "Watcher" },
                    state = 94,
                    showdown = true,
                },
                ["Blackout"] = {
                    keywords = { "Blackout" },
                    state = 95,
                },
                ["Showdown: Gold Smoke Knight"] = {
                    keywords = { "Showdown:", "Gold", "Smoke", "Knight" },
                    state = 96,
                    showdown = true,
                },
                ["Hammer and Nail"] = {
                    keywords = { "Hammer", "Nail", "Gold", "Smoke", "Knight" },
                    state = 97,
                },
                ["Game Variants"] = {
                    keywords = { "Game", "Variants" },
                    state = 98,
                },
                ["Glossary"] = {
                    keywords = { "Glossary" },
                    state = 99,
                },
            },
        },
        {
            name = "White Gigalion Rules",
            pages = {
                ["White Gigalion Introduction"] = {
                    keywords = { "White", "Gigalion", "Introduction" },
                    state = 1,
                },
                ["White Gigalion Rules"] = {
                    keywords = { "White", "Gigalion", "Rulebook", "Rules" },
                    state = 2,
                },
                ["Vignette: The Gigantic Cat"] = {
                    keywords = { "White", "Gigalion", "Vignette:", "the", "Gigantic", "Cat" },
                    state = 3,
                },
                ["Showdown: White Gigalion"] = {
                    keywords = { "Showdown:", "White", "Gigalion" },
                    state = 4,
                },
            },
        },
    },

    monsters = {
        {
            name = "Butcher",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 84 },
            resourcesDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(3, 3.5)", "(20, 3.5)", "(3, 11.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy" },
                        starting = {
                            special = { "Berserker", "Fast Target", "Dreaded Trophies" },
                        },
                        basic = 7,
                        advanced = 5,
                        movement = 5,
                        toughness = 9,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy" },
                        starting = {
                            special = { "Frenzied Berserker", "Fast Target", "Dreaded Trophies" },
                        },
                        basic = 10,
                        advanced = 5,
                        movement = 5,
                        toughness = 12,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy", "Infectious Lunacy" },
                        starting = {
                            special = { "Frenzied Berserker", "Fast Target", "Dreaded Trophies", "Invincible" },
                            misc = { "Indomitable" },
                        },
                        basic = 11,
                        advanced = 10,
                        movement = 5,
                        toughness = 15,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            },
        },
        {
            name = "Gold Smoke Knight",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 96 },
            resourcesDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(8, 5)", "(15, 5)", "(8, 12)", "(15, 12)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            randomTerrain = 3,
            levels = {
                {
                    name = "Level 1",
                    level = 4,
                    showdown = {
                        basic = 9,
                        advanced = 7,
                        legendary = 2,
                        movement = 8,
                        toughness = 27,
                        starting = {
                            special = { "Blacken", "Frustration", "Mauler", "Secondary Forge" },
                            misc = { "Indomitable" },
                        },
                    },
                },
            },
        },
        {
            name = "King's Man",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 86 },
            resourcesDeck = false,
            legendaryAiDeck = "Familiar Face",
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "3 Stone Columns",
                    positions = { "(10, 6.5)", "(11.5, 4)", "(13, 6.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 270, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting" },
                        },
                        basic = 10,
                        advanced = 2,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 5,
                        toughness = 12,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting", "Silent Hymn" },
                        },
                        basic = 11,
                        advanced = 4,
                        legendary = 1,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 6,
                        toughness = 15,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Battle Tempo", "Battle Tempo", "Battle Tempo", "Battle Tempo" },
                        starting = {
                            special = { "Weak Spot", "King's Combat", "King's Aura", "Out-Fighting", "Silent Hymn" },
                            misc = { "Indomitable" },
                        },
                        basic = 12,
                        advanced = 6,
                        legendary = 1,
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        movement = 6,
                        toughness = 18,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                    },
                },
            },
        },
        {
            name = "Phoenix",
            size = { x = 3, y = 3 },
            rules = { "Core Rules", 87 },
            huntTrack = { "H", "M", "H", "M", "H", "O", "M", "H", "M", "H", "H" },
            position = "(12, 9)",
            playerPositions = { "(10, 15)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "Nightmare Tree",
                    positions = { "(12, 9)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 5,
                    showdown = {
                        survivorStatus = { "Dreaded Decade", "Dreaded Decade", "Dreaded Decade", "Dreaded Decade" },
                        starting = {
                            special = { "Materialize", "Spiral Age", "Zeal" },
                        },
                        basic = 8,
                        advanced = 3,
                        legendary = 1,
                        movement = 8,
                        toughness = 10,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        survivorStatus = { "Dreaded Decade", "Dreaded Decade", "Dreaded Decade", "Dreaded Decade" },
                        starting = {
                            legendary = { "Top of the Food Chain" },
                            special = { "Materialize", "Spiral Age", "Zeal" },
                        },
                        basic = 10,
                        advanced = 6,
                        legendary = 1,
                        movement = 8,
                        toughness = 12,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        survivorStatus = { "Dreaded Decade", "Dreaded Decade", "Dreaded Decade", "Dreaded Decade" },
                        starting = {
                            legendary = { "Top of the Food Chain" },
                            special = { "Materialize", "Spiral Age", "Zeal" },
                            misc = { "Indomitable" },
                        },
                        basic = 13,
                        advanced = 7,
                        legendary = 2,
                        movement = 8,
                        toughness = 17,
                        speed = 2,
                        damage = 3,
                        luck = 2,
                    },
                },
                {
                    name = "Golden Eyed King of 1000 Years",
                    level = 5,
                    monsterHuntPosition = 11,
                    showdown = {
                        rules = { "Core Rules", 71 },
                        survivorStatus = { "Dreaded Decade", "Dreaded Decade", "Dreaded Decade", "Dreaded Decade" },
                        starting = {
                            legendary = { "Top of the Food Chain" },
                            special = { "Materialize", "Spiral Age", "Zeal" },
                            misc = { "Indomitable", "Berserker", "Weak Spot", "Golden Eyes" },
                        },
                        customBasic = { "Bored", "Instant Wing Strike", "Peck", "Peck", "Pustule Cannons" },
                        customAdvanced = { "The Difference Between Us", "Gouge & Feast", "Ripple", "Wing Punch" },
                        removeHitLocations = { "Glorious Arm Pit", "Soft Lower Gut" },
                        life = 25,
                        movement = 10,
                        toughness = 25,
                        speed = 2,
                        damage = 3,
                        evasion = 2,
                        luck = 1000,
                        unfixedTerrain = { "Ore Vein", "Bug Patch" },
                    },
                },
            },
        },
        {
            name = "Screaming Antelope",
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 88 },
            huntTrack = { "M", "H", "M", "H", "H", "O", "M", "H", "M", "H", "H" },
            position = "(11.5, 8.5)",
            rotation = { x = 0, y = 90, z = 0 },
            playerPositions = { "(22, 7)", "(22, 8)", "(22, 9)", "(22, 10)" },
            playerRotations = { { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 }, { x = 0, y = -90, z = 0 } },
            fixedTerrain = {
                {
                    terrain = "2 Acanthus Plants",
                    positions = { "(14, 6)", "(14, 11)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "2 Acanthus Plants",
                    positions = { "(15, 7)", "(15, 10)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "2 Acanthus Plants",
                    positions = { "(16, 8)", "(16, 9)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
                {
                    terrain = "Bug Patch",
                    positions = { "(12, 14)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 4,
                    showdown = {
                        basic = 7,
                        advanced = 3,
                        starting = {
                            special = { "Trample" },
                        },
                        movement = 6,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic = 10,
                        advanced = 5,
                        starting = {
                            special = { "Trample", "Diabolical" },
                        },
                        movement = 8,
                        toughness = 10,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 10,
                    showdown = {
                        basic = 12,
                        advanced = 8,
                        legendary = 2,
                        starting = {
                            legendary = { "Legendary Horns" },
                            special = { "Trample", "Diabolical", "Hypermetabolism" },
                            misc = { "Indomitable" },
                        },
                        movement = 8,
                        toughness = 12,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                        evasion = 1,
                    },
                },
                {
                    name = "Mad Steed",
                    level = 4,
                    monsterHuntPosition = 10,
                    showdown = {
                        rules = { "Core Rules", 71 },
                        customBasic = { "Bite", "Bite", "Stomp & Snort" },
                        customAdvanced = { "Crush and Devour", "Great Kick", "Ravenous" },
                        starting = {
                            legendary = { "Legendary Horns" },
                            special = { "Trample", "Diabolical", "Hypermetabolism"    },
                            misc = { "Indomitable", "Berserker", "King's Aura" },
                        },
                        miscHitLocations = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        removeHitLocations = { "Furry Throat" },
                        topHitLocationCards = { "Battle Pressure", "Battle Pressure", "Battle Pressure" },
                        life = 20,
                        movement = 9,
                        toughness = 18,
                        speed = 2,
                        damage = 5,
                        accuracy = 1,
                        luck = 1,
                        randomTerrain = 4
                    },
                },
            },
        },
        {
            name = "The Hand",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 85 },
            resourcesDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 16)", "(11, 16)", "(12, 16)", "(13, 16)" },
            fixedTerrain = {
                {
                    terrain = "Giant Stone Face",
                    positions = { "(11.5, 9)" },
                    rotations = { { x = 0, y = 180, z = 0 } },
                },
            },
            unfixedTerrain = { "3 Stone Columns" },
            randomTerrain = 1,
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Polarized Aura", "Polarized Aura", "Polarized Aura", "Polarized Aura" },
                        starting = {
                            special = { "Red Lens", "Green Lens", "Blue Lens", "Ghost Step", "Impossible Eyes" },
                        },
                        basic = 10,
                        customSpecial = { "Applause" },
                        bottomAiCards = { "Applause" },
                        movement = 5,
                        toughness = 14,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    showdown = {
                        survivorStatus = { "Polarized Aura", "Polarized Aura", "Polarized Aura", "Polarized Aura" },
                        starting = {
                            special = { "Red Lens", "Green Lens", "Blue Lens", "Ghost Step", "Impossible Eyes" },
                        },
                        basic = 10,
                        advanced = 1,
                        customSpecial = { "Applause" },
                        bottomAiCards = { "Applause" },
                        movement = 6,
                        toughness = 15,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    showdown = {
                        survivorStatus = { "Polarized Aura", "Polarized Aura", "Polarized Aura", "Polarized Aura" },
                        starting = {
                            special = { "Red Lens", "Green Lens", "Blue Lens", "Ghost Step", "Impossible Eyes" },
                            misc = { "Indomitable" },
                        },
                        basic = 10,
                        advanced = 2,
                        customSpecial = { "Applause" },
                        bottomAiCards = { "Applause" },
                        movement = 6,
                        toughness = 30,
                        speed = 3,
                        damage = 6,
                    },
                },
            },
        },
        {
            name = "Watcher",
            nemesis = true,
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 94 },
            resourcesDeck = false,
            advancedAiDeck = false,
            legendaryAiDeck = false,
            position = "(11.5, 8.5)",
            playerPositions = { "(7, 4)", "(16, 4)", "(7, 13)", "(16, 13)" },
            playerRotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 },{ x = 0, y = 0, z = 0 },{ x = 0, y = 0, z = 0 } },
            levels = {
                {
                    name = "Level 1",
                    level = 1,
                    showdown = {
                        survivorStatus = { "Retinue", "Retinue", "Retinue", "Retinue" },
                        starting = {
                            special = { "Audience", "Lantern Vortex", "Vapor of Nothingness", "Horripilation" },
                            misc = { "Indomitable" },
                        },
                        basic = 12,
                        life = 15,
                        movement = 0,
                        toughness = 20,
                    },
                },
            },
        },
        {
            name = "White Gigalion",
            size = { x = 3, y = 3 },
            rules = { "White Gigalion Rules", 4 },
            advancedAiDeck = "White Lion Advanced AI",
            specialAiDeck = "White Lion Special AI",
            legendaryAiDeck = "White Lion Legendary AI",
            basicAiDeck = "White Lion Basic AI",
            huntEventsDeck = "White Lion Hunt Events",
            resourcesDeck = "White Lion Resources",
            huntTrack = { "H", "H", "H", "H", "M", "O", "M", "H", "M", "M", "H" },
            position = "(12, 9)",
            playerPositions = { "(10, 14)", "(11, 15)", "(12, 15)", "(13, 15)" },
            unfixedTerrain = { "2 Tall Grass" },
            randomTerrain = 2,
            levels = {
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 8,
                    showdown = {
                        basic = 10,
                        customAdvanced = { "Smart Cat" },
                        advanced = 5,
                        starting = {
                            special = { "Vicious", "Giga Claws" },
                        },
                        topAiCards = { "Smart Cat" },
                        movement = 8,
                        toughness = 10,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic = 11,
                        customAdvanced = { "Smart Cat" },
                        advanced = 8,
                        legendary = 1,
                        starting = {
                            legendary = { "Golden Eyes" },
                            special = { "Vicious", "Giga Claws", "Merciless" },
                            misc = { "Indomitable" },
                        },
                        topAiCards = { "Smart Cat" },
                        movement = 10,
                        toughness = 16,
                        speed = 2,
                        damage = 2,
                        luck = 1,
                    },
                },
            },
        },
        {
            name = "White Lion",
            size = { x = 2, y = 2 },
            rules = { "Core Rules", 89 },
            huntTrack = { "M", "M", "H", "H", "M", "O", "H", "M", "M", "H", "H" },
            position = "(11.5, 8.5)",
            playerPositions = { "(10, 14)", "(11, 15)", "(12, 15)", "(13, 14)" },
            fixedTerrain = {
                {
                    terrain = "2 Tall Grass",
                    positions = { "(9.5, 6.5)", "(13.5, 10.5)" },
                    rotations = { { x = 0, y = 180, z = 0 }, { x = 0, y = 180, z = 0 } },
                },
            },
            randomTerrain = 2,
            levels = {
                {
                    name = "Prologue",
                    level = 1,
                    showdown = {
                        rules = { "Core Rules", 1 },
                        customBasic = { "Claw", "Chomp", "Size Up", "Power Swat", "Grasp" },
                        customAdvanced = { "Maul", "Terrifying Roar", "Enraged" },
                        movement = 6,
                        toughness = 6,
                        topAiCards = { "Claw" },
                        topHitLocationCards = { "Strange Hand" },
                        fixedTerrain = {},
                        randomTerrain = 0,
                    },
                },
                {
                    name = "Level 1",
                    level = 1,
                    monsterHuntPosition = 4,
                    showdown = {
                        basic = 7,
                        advanced = 3,
                        movement = 6,
                        toughness = 8,
                    },
                },
                {
                    name = "Level 2",
                    level = 2,
                    monsterHuntPosition = 7,
                    showdown = {
                        basic = 10,
                        advanced = 5,
                        starting = {
                            special = { "Cunning" },
                        },
                        movement = 7,
                        toughness = 10,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Level 3",
                    level = 3,
                    monsterHuntPosition = 11,
                    showdown = {
                        basic = 10,
                        advanced = 9,
                        legendary = 2,
                        starting = {
                            special = { "Cunning", "Merciless" },
                            misc = { "Indomitable" },
                        },
                        movement = 8,
                        toughness = 14,
                        speed = 2,
                        damage = 2,
                        accuracy = 2,
                        luck = 1,
                    },
                },
                {
                    name = "Beast of Sorrow",
                    level = 4,
                    monsterHuntPosition = 11,
                    showdown = {
                        rules = { "Core Rules", 71 },
                        basic = 10,
                        advanced = 5,
                        legendary = 1,
                        starting = {
                            special = { "Cunning" },
                            misc = { "Trample", "Weak Spot", "Indomitable" },
                        },
                        movement = 7,
                        toughness = 13,
                        speed = 1,
                        damage = 1,
                    },
                },
                {
                    name = "Great Golden Cat",
                    level = 4,
                    monsterHuntPosition = 11,
                    showdown = {
                        rules = { "Core Rules", 71 },
                        customBasic = { "Combo Claw", "Vicious Claw", "Power Swat" },
                        customAdvanced = { "Terrifying Roar", "Bloody Claw" },
                        customLegendary = { "Vanish" },
                        starting = {
                            special = { "Cunning", "Merciless" },
                            misc = { "Indomitable", "Golden Eyes", "Trample", "Top of the Food Chain" },
                        },
                        life = 15,
                        movement = 9,
                        toughness = 17,
                        speed = 2,
                        damage = 5,
                        accuracy = 1,
                        luck = 1,
                    },
                },
            },
        },
    },
}

end)
__bundle_register("Kdm/Util/Check", function(require, _LOADED, __bundle_register, __bundle_modules)
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Check = {}

---------------------------------------------------------------------------------------------------

-- this is the __call metamethod, so the first parameter is ignored
function Check.Check(ignore, condition, fmt, ...)
    if not condition then
        return false, Util.SafeFormat(fmt, ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.Fail(fmt, ...)
    if debug then
        log(debug.traceback(), nil, "error")
    end
    return false, Util.SafeFormat(fmt, ...)
end

---------------------------------------------------------------------------------------------------

function Check.Type(value, expectedType, fmt, ...)
    if value == nil then
        return false, Util.SafeFormat("Required %s is nil: "..(fmt or ""), expectedType, ...)
    end
    local actualType = type(value)
    if actualType != expectedType then
        return false, Util.SafeFormat("Required %s arg has type %s: "..(fmt or ""), expectedType, actualType, ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.TypeOrNil(value, expectedType, fmt, ...)
    if value != nil then
        local actualType = type(value)
        if actualType != expectedType then
            return false, Util.SafeFormat("Required %s arg has type %s: "..(fmt or ""), expectedType, actualType, ...)
        end
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.Str(value, fmt, ...) return Check.Type(value, "string", fmt, ...) end
function Check.StrOrNil(value, fmt, ...) return Check.TypeOrNil(value, "string", fmt, ...) end

function Check.Boolean(value, fmt, ...) return Check.Type(value, "boolean", fmt, ...) end
function Check.BooleanOrNil(value, fmt, ...) return Check.TypeOrNil(value, "boolean", fmt, ...) end

function Check.Num(value, fmt, ...) return Check.Type(value, "number", fmt, ...) end
function Check.NumOrNil(value, fmt, ...) return Check.TypeOrNil(value, "number", fmt, ...) end

function Check.Table(value, fmt, ...) return Check.Type(value, "table", fmt, ...) end
function Check.TableOrNil(value, fmt, ...) return Check.TypeOrNil(value, "table", fmt, ...) end

function Check.Object(value, fmt, ...) return Check.Type(value, "userdata", fmt, ...) end
function Check.ObjectOrNil(value, fmt, ...) return Check.TypeOrNil(value, "userdata", fmt, ...) end

function Check.Func(value, fmt, ...) return Check.Type(value, "function", fmt, ...) end
function Check.FuncOrNil(value, fmt, ...) return Check.TypeOrNil(value, "function", fmt, ...) end

---------------------------------------------------------------------------------------------------

function Check.Vec3(value, fmt, ...)
    local res = Check.Type(value, "table", fmt, ...)
    if not res then
        return res
    end
    if value.x == nil or value.y == nil or value.z == nil then
        return false, Util.SafeFormat("Required arg must be a vec3: %s "..(fmt or ""), value, ...)
    end
    return true
end

function Check.Vec3OrNil(value, fmt, ...)
    local res = Check.TypeOrNil(value, "table", fmt, ...)
    if not res then
        return res
    end
    if value.x == nil or value.y == nil or value.z == nil then
        return false, Util.SafeFormat("Optional arg must be a vec3: %s "..(fmt or ""), value, ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.Vec2(value, fmt, ...)
    local res = Check.Type(value, "table", fmt, ...)
    if not res then
        return res
    end
    if value.x == nil or value.y == nil then
        return false, Util.SafeFormat("Required arg must be a vec2: %s "..(fmt or ""), value, ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.Vec2OrNil(value, fmt, ...)
    local res = Check.TypeOrNil(value, "table", fmt, ...)
    if not res then
        return res
    end
    if value.x == nil or value.y == nil then
        return false, Util.SafeFormat("Optional arg must be a vec2: %s "..(fmt or ""), value, ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.Color(value, fmt, ...)
    local res = Check.Type(value, "table", fmt, ...)
    if not res then
        return res
    end
    if #value != 3 and #value != 4 and (value.r == nil or value.g == nil or value.b == nil) then
        return false, Util.SafeFormat("Required arg must be a color: "..(fmt or ""), ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

function Check.ColorOrNil(value, fmt, ...)
    local res = Check.TypeOrNil(value, "table", fmt, ...)
    if not res then
        return res
    end
    if #value != 3 and #value != 4 and (value.r == nil or value.g == nil or value.b == nil) then
        return false, Util.SafeFormat("Optional arg must be a color: "..(fmt or ""), ...)
    end
    return true
end

---------------------------------------------------------------------------------------------------

setmetatable(Check, { __call = Check.Check })
return Check

end)
__bundle_register("Kdm/Util/Util", function(require, _LOADED, __bundle_register, __bundle_modules)
local Util = {}

---------------------------------------------------------------------------------------------------

function Util.TabStr(t)
    if type(t) != "table" then
        return tostring(t)
    end

    local entries = {}
    for k, v in pairs(t) do
        local vstr = (type(v) == "table") and Util.TabStr(v) or tostring(v)
        table.insert(entries, tostring(k).."="..vstr)
    end
    return "{"..table.concat(entries, ",").."}"
end

---------------------------------------------------------------------------------------------------

function Util.SafeFormat(fmt, ...)
    fmt = fmt or ""

    local args = table.pack(...)
    for i = 1, args.n do
        local arg = args[i]
        if arg == nil then
            args[i] = "<nil>"
        elseif type(arg) == "table" then
            args[i] = tostring(arg)
        end
    end

    local result
    if not pcall(function() result = string.format(fmt, table.unpack(args)) end) then
        result = "FORMATTING ERROR: fmt="..fmt
        for i = 1, args.n do
            result = result..", arg"..i.."="..tostring(args[i])
        end
    end

    return result
end

---------------------------------------------------------------------------------------------------

function Util.ArrayContains(array, value)
    for _, element in ipairs(array) do
        if element == value then
            return true
        end
    end

    return false
end

---------------------------------------------------------------------------------------------------

function Util.Find(array, value)
    for i, v in ipairs(array) do
        if v == value then
            return v
        end
    end
    return nil
end

---------------------------------------------------------------------------------------------------

function Util.FindIf(array, fn)
    for i, v in ipairs(array) do
        if fn(v) then
            return v
        end
    end
    return nil
end
---------------------------------------------------------------------------------------------------

function Util.Intersect(t1, t2)
    result = {}
    for k, v in pairs(t1) do
        if t2[k] ~= nil then
            result[k] = v
        end
    end
    return result
end

---------------------------------------------------------------------------------------------------

function Util.Index(array, field)
    local index = {}
    for _, elem in ipairs(array) do
        index[elem[field]] = elem
    end
    return index
end

---------------------------------------------------------------------------------------------------

function Util.MultiIndex(array, field)
    local index = {}
    for _, elem in ipairs(array) do
        local k = elem[field]
        if not index[k] then
            index[k] = { elem }
        else
            table.insert(index[k], elem)
        end
    end
    return index
end

---------------------------------------------------------------------------------------------------

function Util.Split(str, sep)
    local results = {}
    for match in string.gmatch(str, "([^"..sep.."]+)") do
        table.insert(results, match)
    end
    return results
end

---------------------------------------------------------------------------------------------------

-- creates a new array consistenting of a1..a2
function Util.ConcatArrays(a1, a2)
    local result = {}
    for i = 1, #a1 do
        result[i] = a1[i]
    end
    for i = 1, #a2 do
        result[#a1 + i] = a2[i]
    end
    return result
end

---------------------------------------------------------------------------------------------------

-- appends a2 onto a1, does *not* create a new array!
function Util.AppendArray(a1, a2)
    local n = #a1
    for i = 1, #a2 do
        a1[n + i] = a2[i]
    end
end

---------------------------------------------------------------------------------------------------

function Util.Max(v1, v2)
    return v1 > v2 and v1 or v2
end

---------------------------------------------------------------------------------------------------

function Util.Min(v1, v2)
    return v1 < v2 and v1 or v2
end

---------------------------------------------------------------------------------------------------

function Util.Clamp(x, lo, hi)
    if x < lo then
        return lo
    elseif x > hi then
        return hi
    else
        return x
    end
end

---------------------------------------------------------------------------------------------------

function Util.RemoveUnordered(array, index)
    array[index] = array[#array]
    array[#array] = nil
end

---------------------------------------------------------------------------------------------------

Util.HIGHLIGHT_COLOR = { r = 1, g = 0, b = 0.5 }

function Util.Highlight(object, seconds)
    seconds = seconds or 10

    object.highlightOn(Util.HIGHLIGHT_COLOR, seconds)
    local pos = object.getPosition()
    local size = object.getBounds().size
    Physics.cast({
        origin    = { x = pos.x, y = pos.y + 5, z = pos.z },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = size.x * 2, y = size.y * 2, z = size.z * 2 },
        debug     = true,
    })
end

---------------------------------------------------------------------------------------------------

function Util.HighlightAll(objects, seconds)
    for _, object in ipairs(objects) do
        Util.Highlight(object, seconds)
    end
end

---------------------------------------------------------------------------------------------------

function Util.ColorUiString(color)
    return string.format("rgb(%f, %f, %f)", color.r, color.g, color.b)
end

---------------------------------------------------------------------------------------------------

-- sorted array method
-- function Util.Unique(sortedArray, eqFunc)
--     local n = #sortedArray
--     if n <= 1 then
--         return
--     end
--     local u = 1
--     for i = 2, n do
--         if not eqFunc(sortedArray[i], sortedArray[u]) then
--             u = u + 1
--             sortedArray[u] = sortedArray[i]
--         end
--     end
--
--     u = u + 1
--     while u <= n do
--         sortedArray[u] = nil
--         u = u + 1
--     end
-- end

-- table method
function Util.Unique(array, keyField)
    local table = {}
    for _, elem in ipairs(array) do
        table[elem[keyField]] = elem
    end
    local results = {}
    for _, elem in pairs(table) do
        table.insert(results, elem)
    end
    return results
end

---------------------------------------------------------------------------------------------------

function Util.Filter(array, filter)
    local results = {}
    for _, elem in ipairs(array) do
        if filter(elem) then
            table.insert(results, elem)
        end
    end
    return results
end

---------------------------------------------------------------------------------------------------

function Util.Lerp(x0, x1, t)
    return x0 + t * (x1 - x0)
end

---------------------------------------------------------------------------------------------------

function Util.Capitalize(s)
    return string.upper(string.sub(s, 1, 1))..string.sub(s, 2)
end

---------------------------------------------------------------------------------------------------

function Util.Map(a, f)
    local results = {}
    for _, elem in ipairs(a) do
        table.insert(results, f(elem))
    end
    return results
end

---------------------------------------------------------------------------------------------------

function Util.TruncateString(s, max)
    if not s or s:len() <= max then
        return s
    end

    return s:sub(1, max - 2)..".."
end

---------------------------------------------------------------------------------------------------

function Util.LookAt(params)
    local position = nil
    if params.position then
        position = params.position
    elseif params.object then
        position = params.object.getPosition()
    else
        assert(false, "Either position or object is required")
    end

    for _, player in ipairs(Player.getPlayers()) do
        player.lookAt({
            position = position,
            pitch = params.pitch or 65,
            yaw = 0,
            distance = params.distance or 60,
        })
    end
end

---------------------------------------------------------------------------------------------------

function Util.DeepCopy(source)
    local copy
    if type(source) != "table" then
        return source
    end

    local copy = {}
    for key, value in next, source, nil do
        copy[Util.DeepCopy(key)] = Util.DeepCopy(value)
    end

    return copy
end

---------------------------------------------------------------------------------------------------

function Util.IsFaceDown(object)
    local z = object.getRotation().z
    return z >= 15 and z <= 345
end

---------------------------------------------------------------------------------------------------

function Util.TokenValue(token)
    local value = Util.IsFaceDown(token) and -1 or 1
    local qty = token.getQuantity()
    if qty >= 2 then
        value = value * qty
    end
    return value
end

---------------------------------------------------------------------------------------------------

function Util.CopyArray(a)
    local copy = {}
    for i, v in ipairs(a) do
        copy[i] = v
    end
    return copy
end

---------------------------------------------------------------------------------------------------

function Util.CopyMap(m)
    local copy = {}
    for k, v in pairs(m) do
        copy[k] = v
    end
    return copy
end

---------------------------------------------------------------------------------------------------

return Util

end)
__bundle_register("Kdm/Ui", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local log = require("Kdm/Log").ForModule("Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Ui = {}
Ui.__index = Ui

Ui.DEFAULT_Z = 10.5
Ui.SCALE = 0.1

Ui.LIGHT_BROWN = "#bbb4a1"
Ui.MID_BROWN = "#7f7059"
Ui.DARK_BROWN = "#453824"

Ui.LIGHT_RED = "#E96C6C"
Ui.DARK_RED = "#831010"

Ui.MID_BROWN_COLORS = "#7f7059|#655741|#655741|#ffffff"
Ui.DARK_BROWN_COLORS = "#453824|#2f2410|#2f2410|#ffffff"
Ui.INVISIBLE_COLORS = "#00000000|#00000088|#00000088|#00000000"
--Ui.INVISIBLE_COLORS = "#ff008888|#ff0088cc|#ff008888|#ff008888"

Ui.IMAGE_COLORS = "#ffffff|#dddddd|#dddddd|#ffffff"
Ui.LEFT_MOUSE_BUTTON = "-1"

---------------------------------------------------------------------------------------------------

function Ui.Init()
    Ui.root3dsByObject = {}

    Ui.globalRoot2d = {}
    Ui.globalRoot2d.children = GLOBAL_OBJECT.UI.getXmlTable()
    Ui.globalRoot2d.object = GLOBAL_OBJECT
    Ui.globalRoot2d.attributes = {
        id = "G",
    }
    Ui.globalRoot2d.CreateElem = Ui.CreateElem2d
    setmetatable(Ui.globalRoot2d, Ui)
end

---------------------------------------------------------------------------------------------------

function Ui.Create3d(id, object, z)
    assert(Check.Str(id))
    assert(Check.Object(object))
    assert(Check.Num(z))

    local root3d = Ui.root3dsByObject[object]
    if root3d == nil then
        root3d = {
            object = object,
            z = z * -100,
            rotation = "0 0 180",
            positionFactor = 100,
            widthFactor = 1000,
            heightFactor = 1000,
            scale = "0.1 0.1",
            children = object.UI.getXmlTable(),
            attributes = {
                id = id,
            },
        }
        root3d.CreateElem = Ui.CreateElem3d
        setmetatable(root3d, Ui)

        Ui.root3dsByObject[object] = root3d
    end

    return root3d
end

---------------------------------------------------------------------------------------------------

function Ui.Get2d()
    return Ui.globalRoot2d
end

---------------------------------------------------------------------------------------------------

function Ui:Panel(params)
    local panel = self:CreateElem("Panel", params)
    panel.attributes.color = params.color or "#00000000"
    panel.z = self.z
    panel.rotation = "0 0 0"
    panel.positionFactor = self.positionFactor
    panel.widthFactor = self.widthFactor
    panel.heightFactor = self.heightFactor
    panel.scale = self.scale
    panel.CreateElem = self.CreateElem
    setmetatable(panel, Ui)

    return panel
end

---------------------------------------------------------------------------------------------------

function Ui:VerticalScroll(params)
    local verticalScroll = self:CreateElem("VerticalScrollView", params)
    verticalScroll.attributes.color = params.color or "#00000000"
    verticalScroll.z = self.z
    verticalScroll.rotation = "0 0 0"
    verticalScroll.positionFactor = self.positionFactor
    verticalScroll.widthFactor = self.widthFactor
    verticalScroll.heightFactor = self.heightFactor
    verticalScroll.scale = self.scale
    verticalScroll.CreateElem = self.CreateElem
    setmetatable(verticalScroll, Ui)

    return verticalScroll
end

---------------------------------------------------------------------------------------------------

function Ui:Text(params)
    assert(Check.Num(params.fontSize))
    local text = self:CreateElem("Text", params)
    text.attributes.text = params.text or ""
    text.attributes.color = params.color or Ui.DARK_BROWN
    text.attributes.alignment = params.alignment or "MiddleLeft"
    text.attributes.fontSize = params.fontSize
    text.attributes.fontStyle = params.fontStyle
    text.attributes.textOffset = params.textOffset or "0 0 0 0"
    text.attributes.horizontalOverflow = params.horizontalOverflow or "Overflow"
    text.attributes.verticalOverflow = params.verticalOverflow or "Overflow"
    setmetatable(text, Ui)

    return text
end

---------------------------------------------------------------------------------------------------

function Ui:Image(params)
    local image = self:CreateElem("Image", params)
    image.attributes.image = params.image
    image.attributes.color = params.color or "#ffffffff"
    setmetatable(image, Ui)

    return image
end

---------------------------------------------------------------------------------------------------

function Ui:Input(params)
    local input = self:CreateElem("InputField", params)
    -- If you specify *any* value for attributes.colors, then the input will bug out and disappear when you click into it then
    -- release the mouse button. This is only noticable when there's no background image (ie our floating search box)
    -- This bug occurs even if you specify the literal nil, or the default colors value from
    -- https://api.tabletopsimulator.com/ui/inputelements/#inputfield: "#FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5)"
    -- This workaround is to avoid even setting nil for the colors attribute to avoid this bug.
    if not params.workaroundNilColors then
        input.attributes.colors = params.colors or Ui.INVISIBLE_COLORS
    end
    input.attributes.text = params.text
    input.attributes.placeholder = params.placeholder or " "
    input.attributes.textColor = params.textColor or Ui.DARK_BROWN
    input.attributes.selectionColor = params.selectionColor or "#44444488"
    input.attributes.fontSize = params.fontSize
    input.attributes.fontStyle = params.fontStyle
    input.attributes.textAlignment = params.textAlignment or "MiddleLeft"
    input.attributes.textOffset = params.textOffset or "0 0 0 0"
    input.attributes.readOnly = params.readOnly
    input.attributes.lineType = params.lineType
    setmetatable(input, Ui)
    input:RegisterOnValueChanged(params.onValueChanged)

    return input
end

---------------------------------------------------------------------------------------------------

function Ui:Button(params)
    local button = self:CreateElem("Button", params)
    if params.image then
        button.attributes.image = params.image
        button.attributes.colors = params.colors or Ui.IMAGE_COLORS
    else
        button.attributes.colors = params.colors or Ui.INVISIBLE_COLORS
    end
    button.attributes.text = params.text
    button.attributes.textColor = params.textColor
    button.attributes.fontSize = params.fontSize
    button.attributes.textAlignment = params.textAlignment or "MiddleLeft"
    setmetatable(button, Ui)
    button:RegisterOnClick(params.onClick)

    return button
end

---------------------------------------------------------------------------------------------------

function Ui:CheckBox(params)
    local checkBox = self:CreateElem("Button", params)
    checkBox.checkedImage = params.checkedImage or "CheckBoxFilled"
    checkBox.checkedColors = params.checkedColors or Ui.IMAGE_COLORS
    checkBox.uncheckedImage = params.uncheckedImage -- or nil
    if checkBox.uncheckedImage then
        checkBox.uncheckedColors = params.uncheckedColors or Ui.IMAGE_COLORS
    else
        checkBox.uncheckedColors = params.uncheckedColors or Ui.INVISIBLE_COLORS
    end
    if params.checked then
        checkBox.attributes.image = checkBox.checkedImage
        checkBox.attributes.colors = checkBox.checkedColors
    else
        checkBox.attributes.image = checkBox.uncheckedImage
        checkBox.attributes.colors = checkBox.uncheckedColors
    end
    setmetatable(checkBox, Ui)
    checkBox:RegisterOnClick(params.onClick)

    return checkBox
end

---------------------------------------------------------------------------------------------------

function Ui:CheckButton(params)
    assert(Check.Num(params.fontSize))
    assert(Check.Str(params.text))

    local checkButton = self:CreateElem("Button", params)
    checkButton.checkedColors = params.checkedColors or Ui.DARK_BROWN_COLORS
    checkButton.uncheckedColors = params.uncheckedColors or Ui.MID_BROWN_COLORS
    checkButton.attributes.colors = params.checked and checkButton.checkedColors or checkButton.uncheckedColors
    checkButton.attributes.textColor = params.textColor or Ui.LIGHT_BROWN
    checkButton.attributes.text = params.text
    checkButton.attributes.fontSize = params.fontSize
    checkButton.attributes.textAlignment = params.textAlignment or "MiddleCenter"
    setmetatable(checkButton, Ui)
    checkButton:RegisterOnClick(params.onClick)

    return checkButton
end

---------------------------------------------------------------------------------------------------

function Ui:OptionButtonGroup(params)
    assert(Check.Str(params.id))
    assert(Check.Num(params.fontSize))
    assert(Check.Func(params.onClick))

    local id = params.id.."OptionButtons"

    log:Debugf("Creating OptionButtonGroup %s", id)

    local group = {
        id = id,
        parent = self,
        options = {},
        selectedColors = params.selectedColors or Ui.DARK_BROWN_COLORS,
        unselectedColors = params.unselectedColors or Ui.INVISIBLE_COLORS,
        textColor = params.textColor or Ui.LIGHT_BROWN,
        textAlignment = params.textAlignment or "MiddleCenter",
        fontSize = params.fontSize,
        onClick = params.onClick,
    }
    setmetatable(group, Ui)

    return group
end

---------------------------------------------------------------------------------------------------

function Ui:OptionButton(params)
    local id = self.id..(#self.options + 1)

    log:Debugf("Creating OptionButton %s", id)

    params.id = id
    local optionButton = self.parent:CreateElem("Button", params)
    optionButton.attributes.text = params.text
    optionButton.attributes.colors = params.selected and self.selectedColors or self.unselectedColors
    optionButton.attributes.textColor = self.textColor
    optionButton.attributes.fontSize = self.fontSize
    optionButton.attributes.textAlignment = self.textAlignment
    optionButton.group = self
    optionButton.optionValue = params.optionValue
    setmetatable(optionButton, Ui)
    optionButton:RegisterOnClick(function() self.onClick(optionButton) end)
    table.insert(self.options, optionButton)

    optionButton.Select = Ui.SelectOptionButton

    return optionButton
end

---------------------------------------------------------------------------------------------------

function Ui.OptionCheckBoxGroup(self, params)
    assert(Check.Str(params.id))
    assert(Check.Func(params.onClick))

    local id = params.id.."OptionCheckBoxes"

    log:Debugf("Creating OptionCheckBoxGroup %s", id)

    local group = {
        id = id,
        parent = self,
        options = {},
        checkedImage = params.checkedImage or "CheckBoxFilled",
        checkedColors = params.checkedColors or Ui.IMAGE_COLORS,
        uncheckedImage = params.uncheckedImage, -- or nil
        uncheckedColors = params.uncheckedColors or Ui.INVISIBLE_COLORS,
        onClick = params.onClick,
    }
    setmetatable(group, Ui)

    return group
end

---------------------------------------------------------------------------------------------------

function Ui:OptionCheckBox(params)
    local id = self.id..(#self.options + 1)

    log:Debugf("Creating OptionCheckBox %s", id)

    params.id = id
    local optionCheckBox = self.parent:CreateElem("Button", params)
    optionCheckBox.optionValue = params.optionValue
    optionCheckBox.checkedImage = self.checkedImage
    optionCheckBox.checkedColors = self.checkedColors
    optionCheckBox.uncheckedImage = self.uncheckedImage
    optionCheckBox.uncheckedColors = self.uncheckedColors
    if params.checked then
        optionCheckBox.attributes.image = optionCheckBox.checkedImage
        optionCheckBox.attributes.colors = optionCheckBox.checkedColors
    else
        optionCheckBox.attributes.image = optionCheckBox.uncheckedImage
        optionCheckBox.attributes.colors = optionCheckBox.uncheckedColors
    end
    optionCheckBox.group = self
    setmetatable(optionCheckBox, Ui)
    optionCheckBox:RegisterOnClick(function() self.onClick(optionCheckBox) end)
    table.insert(self.options, optionCheckBox)
    optionCheckBox.Select = Ui.SelectOptionCheckBox

    return optionCheckBox
end

---------------------------------------------------------------------------------------------------

function Ui:Counter(params)
    assert(Check.Func(params.onValueChanged))

    -- This must work with both 2d (x/y/w/h) and 3d (tl/br)
    local x, y, width, height
    if params.topLeft then
        x = params.topLeft.x
        y = params.topLeft.y
        width = params.bottomRight.x - x
        height = params.bottomRight.y - y
    else
        x = params.x
        y = params.y
        width = params.width
        height = params.height
    end

    local counter = self:Text({
        id = params.id,

        x = x,
        y = y,
        width = width,
        height = height,

        topLeft = { x = x, y = y },
        bottomRight = { x = x + width, y = y + height },

        text = params.text or 0,
        color = params.color or Ui.LIGHT_BROWN,
        fontSize = params.fontSize,
        alignment = "LowerCenter",
        horizontalOverflow = "Overflow",
        verticalOverflow = "Overflow",
    })

    counter.minusButton = self:Button({
        id = params.id.."Minus",

        x = x,
        y = y,
        width = width / 2,
        height = height,

        topLeft = { x = x, y = y },
        bottomRight = { x = x + (width / 2), y = y + height },

        onClick = function(mouseButton)
            params.onValueChanged((mouseButton == Ui.LEFT_MOUSE_BUTTON) and -1 or -10)
        end,
    })

    counter.plusButton = self:Button({
        id = params.id.."Plus",

        x = x + (width / 2),
        y = y,
        width = width / 2,
        height = height,

        topLeft = { x = x + (width / 2), y = y },
        bottomRight = { x = x + width, y = y + height },

        onClick = function(mouseButton)
            params.onValueChanged((mouseButton == Ui.LEFT_MOUSE_BUTTON) and 1 or 10)
        end,
    })

    return counter
end

---------------------------------------------------------------------------------------------------

-- 2D elements use absolute pixel positioning (x, y, width, height), so no need for scaling factors
function Ui:CreateElem2d(tag, params)
    assert(Check.Table(params, params.id))
    assert(Check.Str(params.id))
    assert(Check.Num(params.x, params.id))
    assert(Check.Num(params.y, params.id))
    assert(Check.Num(params.width, params.id))
    assert(Check.Num(params.height, params.id))

    local id = self.attributes.id.."_"..params.id..tag

    log:Debugf("Creating 2d %s %s", tag, id)

    local elem = {
        tag = tag,
        object = self.object,
        attributes = {
            id = id,
            rectAlignment = params.rectAlignment or "UpperLeft",
            offsetXY = params.x.." "..params.y,
            width = params.width,
            height = params.height,
            active = params.active == nil or params.active
        },
        children = {},
    }
    table.insert(self.children, elem)

    return elem
end

---------------------------------------------------------------------------------------------------

-- 3d uis must be scaled based on the size of the underlying object, hence position/width/heightFactor
function Ui:CreateElem3d(tag, params)
    assert(Check.Str(params.id, params.id))
    assert(Check.Vec2(params.topLeft, params.id))
    assert(Check.Vec2(params.bottomRight, params.id))

    local id = self.attributes.id.."_"..params.id..tag

    log:Debugf("Creating 3d %s %s", tag, id)

    local topLeft = params.topLeft
    local bottomRight = params.bottomRight
    local centerX = ((topLeft.x + bottomRight.x) / 2) * self.positionFactor
    local centerY = ((topLeft.y + bottomRight.y) / 2) * self.positionFactor
    local centerZ = params.z and (params.z * -100) or self.z

    local elem = {
        tag = tag,
        object = self.object,
        children = {},
        attributes = {
            id = id,
            position = centerX.." "..centerY.." "..centerZ,
            width = math.abs(bottomRight.x - topLeft.x) * self.widthFactor,
            height = math.abs(bottomRight.y - topLeft.y) * self.heightFactor,
            scale = self.scale,
            rotation = self.rotation,
            active = params.active == nil or params.active,
        },
    }
    table.insert(self.children, elem)

    return elem
end

---------------------------------------------------------------------------------------------------

function Ui:RegisterOnClick(onClick)
    assert(Check.FuncOrNil(onClick))
    self.onClick = onClick or function() end
    local onClickFunctionName = self.attributes.id.."_OnClick"
    GLOBAL_OBJECT.setVar(onClickFunctionName, function(player, mouseButton)
        self.onClick(mouseButton, player)
    end)
    self.attributes.onClick = "Global/"..onClickFunctionName
end

---------------------------------------------------------------------------------------------------

function Ui:RegisterOnValueChanged(onValueChanged)
    assert(Check.FuncOrNil(onValueChanged))
    self.onValueChanged = onValueChanged or function() end
    local onValueChangedFunctionName = self.attributes.id.."_OnValueChanged"
    GLOBAL_OBJECT.setVar(onValueChangedFunctionName, function(_, value)
        self.onValueChanged(value)
    end)
    self.attributes.onValueChanged = "Global/"..onValueChangedFunctionName
end

---------------------------------------------------------------------------------------------------

function Ui:SetAttribute(attribute, type, value, nilAllowed)
    local id = self.attributes.id
    assert(Check.Str(attribute, id))
    assert(Check.Str(type, id))
    if nilAllowed then
        assert(Check.TypeOrNil(value, type, "%s: %s %s", id, attribute, type))
    else
        assert(Check.Type(value, type, "%s: %s %s", id, attribute, type))
    end
    log:Debugf("Setting %s %s to %s", id, attribute, tostring(value))
    self.attributes[attribute] = value
    self.object.UI.setAttribute(id, attribute, value)
end

function Ui:GetAttribute(attribute)
    return self.attributes[attribute]
end

function Ui:ShowForPlayer(color)
    if self:GetAttribute("active") == false then
        self:SetAttribute("active", "boolean", true)
        self:SetAttribute("visibility", "string", color)
    end

    return self:GetAttribute("visibility")
end

function Ui:HideForPlayer(color)
    if self:GetAttribute("active") == true then
        if self:GetAttribute("visibility") == color then
            self:SetAttribute("active", "boolean", false)
        end
        return self:GetAttribute("visibility")
    else
        return "None"
    end
end

function Ui:Show() self:SetAttribute("active", "boolean", true) end
function Ui:Hide() self:SetAttribute("active", "boolean", false) end
function Ui:SetOffsetXY(offsetXY) self:SetAttribute("offsetXY", "string", offsetXY) end
function Ui:SetWidth(width) self:SetAttribute("width", "number", width) end
function Ui:SetHeight(height) self:SetAttribute("height", "number", height) end
function Ui:SetText(text)
    local id = self.attributes.id
    text = (text != nil) and tostring(text) or ""   -- nil will not actually clear the text
    log:Debugf("Setting %s text to '%s'", id, text)
    self.attributes.text = text
    self.object.UI.setAttribute(id, "text", self.attributes.text)
    self.object.UI.setAttribute(id, "color", self.attributes.color)
    self.object.UI.setAttribute(id, "colors", self.attributes.colors)
    self.object.UI.setAttribute(id, "textColor", self.attributes.textColor)
end
function Ui:SetColor(color) self:SetAttribute("color", "string", color) end
function Ui:SetColors(colors) self:SetAttribute("colors", "string", colors) end
function Ui:SetTextColor(textColor) self:SetAttribute("textColor", "string", textColor) end
function Ui:SetFontStyle(fontStyle) self:SetAttribute("fontStyle", "string", fontStyle) end
function Ui:SetFontSize(fontSize) self:SetAttribute("fontSize", "number", fontSize) end
function Ui:SetImage(image) self:SetAttribute("image", "string", image, true) end

function Ui:Check(checked)
    if checked then
        self.attributes.image = self.checkedImage
        self.attributes.colors = self.checkedColors
    else
        self.attributes.image = self.uncheckedImage
        self.attributes.colors = self.uncheckedColors
    end
    log:Debugf("Setting %s image to %s, colors to %s", self.attributes.id, self.attributes.image, self.attributes.colors)
    self.object.UI.setAttribute(self.attributes.id, "image", self.attributes.image)
    self.object.UI.setAttribute(self.attributes.id, "colors", self.attributes.colors)
    self.object.UI.setAttribute(self.attributes.id, "textColor", self.attributes.textColor)
end

function Ui:SelectOptionButton()
    for _, option in ipairs(self.group.options) do
        if option == self then
            option.attributes.colors = self.group.selectedColors
        else
            option.attributes.colors = self.group.unselectedColors
        end
        log:Debugf("Setting %s colors to %s and textColor to %s", option.attributes.id, option.attributes.colors, option.attributes.textColor)
        option.object.UI.setAttribute(option.attributes.id, "colors", option.attributes.colors)
        option.object.UI.setAttribute(option.attributes.id, "textColor", option.attributes.textColor)
    end
end

function Ui:SelectOptionCheckBox()
    for _, option in ipairs(self.group.options) do
        if option == self then
            option.attributes.image = self.group.checkedImage
            option.attributes.colors = self.group.checkedColors
        else
            option.attributes.image = self.group.uncheckedImage
            option.attributes.colors = self.group.uncheckedColors
        end
        log:Debugf("Setting %s image to %s and colors to %s", option.attributes.id, option.attributes.image,  option.attributes.colors)
        option.object.UI.setAttribute(option.attributes.id, "image", option.attributes.image)
        option.object.UI.setAttribute(option.attributes.id, "colors", option.attributes.colors)
    end
end

function Ui:OptionValue() return self.optionValue end
function Ui:SetOptionValue(optionValue) self.optionValue = optionValue end

---------------------------------------------------------------------------------------------------

function Ui:SetOnClick(onClick)
    assert(Check.FuncOrNil(onClick))
    self.onClick = onClick
end

function Ui:SetOnValueChanged(onValueChanged)
    assert(Check.FuncOrNil(onValueChanged))
    self.onValueChanged = onValueChanged
end

---------------------------------------------------------------------------------------------------

function Ui:ApplyToObject()
    if #self.children > 0 then
        self.object.UI.setXmlTable(self.children)
    end
end

---------------------------------------------------------------------------------------------------

return {
    Init = Ui.Init,
    Create3d = Ui.Create3d,
    Get2d = Ui.Get2d,
    LEFT_MOUSE_BUTTON = Ui.LEFT_MOUSE_BUTTON,

    IMAGE_COLORS = Ui.IMAGE_COLORS,
    INVISIBLE_COLORS = Ui.INVISIBLE_COLORS,

    LIGHT_BROWN = Ui.LIGHT_BROWN,
    MID_BROWN = Ui.MID_BROWN,
    DARK_BROWN = Ui.DARK_BROWN,

    LIGHT_RED = Ui.LIGHT_RED,
    DARK_RED = Ui.DARK_RED,

    --LIGHT_BROWN_COLORS = Ui.LIGHT_BROWN_COLORS,
    MID_BROWN_COLORS = Ui.MID_BROWN_COLORS,
    DARK_BROWN_COLORS = Ui.DARK_BROWN_COLORS,
}

end)
__bundle_register("Kdm/Log", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Console = require("Kdm/Console")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Log = {}
Log.__index = Log
Log.__call = function(self, ...) log(...) end

Log.logsByModule = {}

Log.DEBUG_MODULES = {
    --["BattleUi"] = true,
    --["Campaign"] = true,
    --["Expansion"] = true,
    --["Hunt"] = true,
    --["Location"] = true,
    --["Player"] = true,
    --["Rules"] = true,
    --["Showdown"] = true,
    --["Survivor"] = true,
    --["Timeline"] = true,
}

Log.POST_INIT_DEBUG_MODULES = {
    --["Ui"] = true,
}

---------------------------------------------------------------------------------------------------

function Log.Create(module)
    local log = {
        module = module
    }
    setmetatable(log, Log)

    log:EnableDebug(Log.DEBUG_MODULES[module])

    return log
end

---------------------------------------------------------------------------------------------------

function Log:Printf(fmt, ...)
    fmt = fmt or ""
    local msg = Util.SafeFormat(fmt, ...)
    log(Util.SafeFormat("[%s] "..fmt, self.module, ...), nil, "print")
    printToAll(Util.SafeFormat("[66aaff]"..fmt, ...))
end

---------------------------------------------------------------------------------------------------

function Log:DisabledDebugf(fmt, ...) end

function Log:EnabledDebugf(fmt, ...)
    fmt = fmt or ""
    local s = Util.SafeFormat("[%s] "..fmt, self.module, ...)
    log(s, nil, "debug")
end

---------------------------------------------------------------------------------------------------

function Log:Errorf(fmt, ...)
    fmt = fmt or ""
    log(Util.SafeFormat("[%s] "..fmt, self.module, ...), nil, "error")
    printToAll(Util.SafeFormat("[ff4444]"..fmt, ...))
end

---------------------------------------------------------------------------------------------------

function Log:Broadcastf(fmt, ...)
    fmt = fmt or ""
    log(Util.SafeFormat("[%s] "..fmt, self.module, ...), nil, "print")
    broadcastToAll(Util.SafeFormat(fmt, ...))
end

---------------------------------------------------------------------------------------------------

function Log:EnableDebug(enable)
    if enable then
        self.Debugf = Log.EnabledDebugf
    else
        self.Debugf = Log.DisabledDebugf
    end
end

---------------------------------------------------------------------------------------------------

function Log.Init()
    logStyle("debug", { r = 1.0, g = 1.0, b = 1.0 }, "", "")
    logStyle("print", { r = 0.0, g = 1.0, b = 1.0 }, "", "")
    logStyle("error", { r = 1.0, g = 0.0, b = 0.0 }, "", "")

    Console.AddCommand("debug", function(args)
        if #args != 3 or (args[3] != "on" and args[3] != "off") then
            return Console.Printf("Usage: debug <module> <on|off>")
        end

        local module = args[2]
        local log = Log.logsByModule[module]
        if not log then
            return Console.Printf("Unknown module '%s'", module)
        end

        local enabled = args[3] == "on"
        log:EnableDebug(enabled)

        Console.Printf("%s debugging for %s", enabled and "Enabled" or "Disabled", log.module)
    end, "Toggles debug logging for specific modules")
end

---------------------------------------------------------------------------------------------------

function Log.PostInit()
    for module, _ in pairs(Log.POST_INIT_DEBUG_MODULES) do
        Log.logsByModule[module]:EnableDebug(true)
    end
end

---------------------------------------------------------------------------------------------------

function Log.ForModule(module)
    local log = Log.logsByModule[module]
    if not log then
        log = Log.Create(module)
        Log.logsByModule[module] = log
        Log.logsByModule[module:lower()] = log  -- for console commands, which come in all lowercase
    end
    return log
end

---------------------------------------------------------------------------------------------------

return {
    Init = Log.Init,
    PostInit = Log.PostInit,
    ForModule = Log.ForModule,
}

end)
__bundle_register("Kdm/Console", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local EventManager = require("Kdm/Util/EventManager")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Console = {}

---------------------------------------------------------------------------------------------------

function Console.Init()
    Console.commands = {}

    EventManager.AddHandler("onChat", function(message, player, previousReturnValue)
        if message == "" or message:sub(1, 1) != ">" then
            return (previousReturnValue == nil) or previousReturnValue
        end

        Console.Printf(message)

        local args = Console.Tokenize(message)
        local command = Console.commands[args[1]:lower()]
        if not command then
            Console.Printf("Unrecognized command: %s", args[1])
            return false
        end

        command.func(args)

        return false
    end)

    Console.AddCommand("help", function(args)
        for name, command in pairs(Console.commands) do
            Console.Printf("%s %s", name, command.description)
        end
    end, "Shows all commands")
end

---------------------------------------------------------------------------------------------------

function Console.Printf(fmt, ...)
    print(Util.SafeFormat("[aaaaaa]"..fmt, ...))
end

---------------------------------------------------------------------------------------------------

function Console.AddCommand(name, commandFunc, description)
    name = name:lower()
    assert(Check(not Console.commands[name], "Command %s already registered", name))
    Console.commands[name] = {
        func = commandFunc,
        description = description
    }
end

---------------------------------------------------------------------------------------------------

function Console.Tokenize(message)
    local tokens = {}

    local dq = 34   -- ascii double quote "
    local sq = 39   -- ascii single quote '

    local bytes = table.pack(string.byte(message, 1, message:len()))
    local i = 2 -- skip leading console char
    while true do
        local start = i

        -- skip whitespace
        while i <= #bytes and bytes[i] <= 32 do
            i = i + 1
        end
        if i > #bytes then
            break
        end

        local tokenStart = i

        -- check for leading quote (we ignore quotes mid-token)
        local quote = nil
        local b = bytes[i]
        if b == dq or b == sq then
            quote = b
            i = i + 1
            tokenStart = i
        end

        -- find end of word
        if quote then
            while i <= #bytes and bytes[i] ~= quote do
                i = i + 1
            end
            if bytes[i] != quote then
                log:Errorf("String missing "..string.char(quote).." quote ")
                return
            end
        else
            while i <= #bytes and bytes[i] > 32 do
                i = i + 1
            end
        end

        table.insert(tokens, message:sub(tokenStart, i - 1):lower())
        i = i + 1
    end

    return tokens
end

---------------------------------------------------------------------------------------------------

return {
    Init = Console.Init,
    Printf = Console.Printf,
    AddCommand = Console.AddCommand,
}

end)
__bundle_register("Kdm/Util/EventManager", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")

---------------------------------------------------------------------------------------------------

local EventManager = {}

EventManager.ON_SURVIVOR_DESTROYED = "onSurvivorDestroyed"
EventManager.ON_SURVIVOR_STAT_CHANGED = "onSurvivorStatChanged"
EventManager.ON_SURVIVOR_CARDS_CHANGED = "onSurvivorCardsChanged"
EventManager.ON_PLAYER_SURVIVOR_LINKED = "onPlayerSurvivorLinked"
EventManager.ON_PLAYER_SURVIVOR_UNLINKED = "onPlayerSurvivorUnlinked"
EventManager.ON_PLAYER_WEAPONS_CHANGED = "onPlayerWeaponsChanged"
EventManager.ON_PLAYER_COLOR_CHANGED = "onPlayerColorChanged"
EventManager.ON_SHOWDOWN_STARTED = "onShowdownStart"
EventManager.ON_SHOWDOWN_ENDED = "onShowdownEnded"
EventManager.ON_MONSTER_STAT_CHANGED = "onMonsterStatChanged"
EventManager.ON_SURVIVOR_GETS_IN_PLAY = "onSurvivorGetsInPlay"
EventManager.ON_SURVIVOR_BACK_TO_SETTLEMENT = "onSurvivorBackToSettlement"

EventManager.handlers = {}
EventManager.globalHandlers = {}

---------------------------------------------------------------------------------------------------

function EventManager.AddHandler(event, handler)
    assert(Check.Str(event))
    assert(Check.Func(handler))

    local handlers = EventManager.handlers[event]
    if handlers then
        table.insert(handlers, handler)
        return
    end

    EventManager.globalHandlers[event] = _G[event]

    _G[event] = function(...)
        local globalHandler = EventManager.globalHandlers[event]
        local returnValue
        if globalHandler then
            returnValue = globalHandler(...)
        end

        local args = table.pack(...)
        local n = #args
        table.insert(args, returnValue)
        for _, handler in ipairs(EventManager.handlers[event]) do
            args[n + 1] = returnValue
            returnValue = handler(table.unpack(args))
        end

        return returnValue
    end

    EventManager.handlers[event] = { handler }
end

---------------------------------------------------------------------------------------------------

function EventManager.FireEvent(event, ...)
    assert(Check.Str(event))

    local globalHandler = EventManager.globalHandlers[event]
    if globalHandler then
        globalHandler(...)
    end

    for _, handler in ipairs(EventManager.handlers[event] or {}) do
        handler(...)
    end
end

---------------------------------------------------------------------------------------------------

return EventManager

end)
__bundle_register("Kdm/Timeline", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Hunt = require("Kdm/Hunt")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Timeline")
local MessageBox = require("Kdm/MessageBox")
local Rules = require("Kdm/Rules")
local Showdown = require("Kdm/Showdown")
local Trie = require("Kdm/Util/Trie")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")


-------------------------------------------------------------------------------------------------

local Timeline = {}

Timeline.MAX_YEARS = 30
Timeline.MAX_YEAR_EVENTS = 6
Timeline.MAX_SURVIVAL_ACTIONS = 6
Timeline.MAX_MILESTONES = 4
Timeline.MAX_QUARRIES = 10
Timeline.MAX_NOTES = 6
Timeline.MAX_TIMELINE_EVENT_POPUP_RESULTS = 5

Timeline.RIGHT_MOUSE_BUTTON = "-2"

Timeline.EVENT_TYPE_ICONS = {
    ["RulebookEvent"] =  "RulebookEventIcon",
    ["HuntEvent"] = "HuntEventIcon",
    ["ShowdownEvent"] = "ShowdownEventIcon",
    ["SettlementEvent"] = "SettlementEventIcon",
}

Timeline.EVENT_TYPE_IMAGES = {
    ["RulebookEvent"] = "RulebookEventButton",
    ["HuntEvent"] = "HuntEventButton",
    ["ShowdownEvent"] = "ShowdownEventButton",
    ["SettlementEvent"] = "SettlementEventButton",
}

---------------------------------------------------------------------------------------------------

function Timeline.Init(saveState)
    Timeline.InitDefaultEvents()

    Timeline.survivalActions = {}
    for i = 1, Timeline.MAX_SURVIVAL_ACTIONS do
        Timeline.survivalActions[i] = {}
    end
    Timeline.milestones = {}
    for i = 1, Timeline.MAX_MILESTONES do
        Timeline.milestones[i] = {}
    end
    Timeline.quarries = {}
    for i = 1, Timeline.MAX_QUARRIES do
        Timeline.quarries[i] = {}
    end
    Timeline.notes = {}
    for i = 1, Timeline.MAX_NOTES do
        Timeline.notes[i] = {}
    end
    Timeline.years = {}
    for i = 1, Timeline.MAX_YEARS do
        Timeline.years[i] = {
            events = {}
        }
        for j = 1, Timeline.MAX_YEAR_EVENTS do
            Timeline.years[i].events[j] = {}
        end
    end

    Timeline.InitState(saveState)
    Timeline.InitExpansions()
    Timeline.InitUi(ui)
end

---------------------------------------------------------------------------------------------------

function Timeline.InitDefaultEvents()
    Timeline.trie = Trie()
    Timeline.defaultEvents = {
        {
            keywords = { "Unspecified", "Nemesis"},
            event = {
                type = "ShowdownEvent",
                name = "Unspecified Nemesis",
                nemesis = true,
            },
        },
    }
    for level = 1, 3 do
        table.insert(Timeline.defaultEvents, {
            keywords = { "Unspecified", "Nemesis", "Level", tostring(level) },
            event = {
                type = "ShowdownEvent",
                name = "Unspecified Nemesis - Level "..level,
                nemesis = true,
            },
        })
    end
    for _, event in ipairs(Timeline.defaultEvents) do
        for _, keyword in ipairs(event.keywords) do
            Timeline.trie:Set(keyword, event.event)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.InitState(saveState)
    Timeline.settlementName = saveState.name
    Timeline.survivalLimit = saveState.survivalLimit or 1
    Timeline.departingBonuses = saveState.departingBonuses
    Timeline.arrivalBonuses = saveState.arrivalBonuses

    local survivalActions = saveState.survivalActions or {}
    for i = 1, Timeline.MAX_SURVIVAL_ACTIONS do
        if survivalActions[i] then
            Timeline.survivalActions[i].name = survivalActions[i].name
            Timeline.survivalActions[i].checked = survivalActions[i].checked
        else
            Timeline.survivalActions[i].name = nil
            Timeline.survivalActions[i].checked = nil
        end
    end

    local milestones = saveState.milestones or {}
    for i = 1, Timeline.MAX_MILESTONES do
        if milestones[i] then
            Timeline.milestones[i].name = milestones[i].name
            Timeline.milestones[i].event = milestones[i].event
            Timeline.milestones[i].checked = milestones[i].checked
        else
            Timeline.milestones[i].name = nil
            Timeline.milestones[i].event = nil
            Timeline.milestones[i].checked = nil
        end
    end

    local quarries = saveState.quarries or {}
    for i = 1, Timeline.MAX_QUARRIES do
        Timeline.quarries[i].quarry = quarries[i]
    end

    local notes = saveState.notes or {}
    for i = 1, Timeline.MAX_NOTES do
        Timeline.notes[i].note = notes[i]
    end

    local years = saveState.years or {}
    for i = 1, Timeline.MAX_YEARS do
        local year = years[i] or {}
        Timeline.years[i].checked = year.checked
        local events = year.events or {}
        for j = 1, Timeline.MAX_YEAR_EVENTS do
            if events[j] then
                Timeline.years[i].events[j].event = events[j]
            else
                Timeline.years[i].events[j].event = nil
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.InitExpansions()
    for _, expansion in ipairs(Expansion.All()) do
        for _, rulebook in ipairs(expansion.rulebooks or {}) do
            for name, page in pairs(rulebook.pages) do
                if page.timelineEvent then
                    local event = {
                        name = name,
                        type = "RulebookEvent",
                        rulebook = rulebook.name,
                        state = page.state,
                        expansion = expansion.name,
                    }
                    for _, keyword in ipairs(page.keywords) do
                        Timeline.trie:Set(keyword, event)
                    end
                end
            end
        end

        for _, monster in ipairs(expansion.monsters or {}) do
            local monsterKeywords = Util.Split(monster.name, " ")
            if #monster.levels == 1 then
                local event = {
                    type = monster.nemesis and "ShowdownEvent" or "HuntEvent",
                    name = Timeline.ShowdownEventTimelineName(monster.name, nil, monster.nemesis),
                    monster = monster.name,
                    expansion = expansion.name,
                }
                for _, keyword in ipairs(monsterKeywords) do
                    Timeline.trie:Set(keyword, event)
                end
            else
                for _, level in ipairs(monster.levels) do
                    local levelKeywords = Util.Split(level.name, " ")
                    local event = {
                        type = monster.nemesis and "ShowdownEvent" or "HuntEvent",
                        name = Timeline.ShowdownEventTimelineName(monster.name, level.name, monster.nemesis),
                        monster = monster.name,
                        level = level.name,
                        expansion = expansion.name,
                    }
                    for _, keyword in ipairs(Util.ConcatArrays(monsterKeywords, levelKeywords)) do
                        Timeline.trie:Set(keyword, event)
                    end
                end
            end
        end

        for _, settlementEvent in ipairs(expansion.settlementEvents or {}) do
            for _, keyword in ipairs(Util.Split(settlementEvent, " ")) do
                Timeline.trie:Set(keyword, {
                    name = settlementEvent,
                    type = "SettlementEvent",
                    expansion = expansion.name,
                })
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.InitUi(ui)
    Timeline.uiOpen = false

    local ui = Ui.Get2d()
    local panel = ui:Panel({ id = "Timeline", rectAlignment = "MiddleCenter", x = 0, y = 0, width = 1600, height = 935, active = Timeline.uiOpen })
    Timeline.panel = panel
    panel:Image({ id = "Timeline", image = "Settlement", x = 0, y = 0, width = 1600, height = 935 })
    panel:Button({ id = "Close", x = 1570, y = 0,  width = 30, height = 30, onClick = function(mouseButton, player)
        Timeline.HideUiForAll()
    end })
    Timeline.settlementNameInput = panel:Input({ id = "SettlementName", x = 198, y = -45, width = 482, height = 40, fontSize = 24, onValueChanged = function(value)
        log:Debugf("Setting settlement name to %s", value)
        Timeline.settlementName = value
    end })
    Timeline.survivalLimitCounter = panel:Counter({ id = "SurvivalLimit", x = 793, y = -55, width = 50, height = 50, fontSize = 36, color = Ui.DARK_BROWN, onValueChanged = function(delta)
        local value = Timeline.survivalLimit + delta
        Timeline.survivalLimit = value
        log:Debugf("Setting survival limit to %d", value)
        Timeline.survivalLimitCounter:SetText(value)
    end })

    Timeline.departingBonusesInput = panel:Input({ id = "DepartingBonus", x = 980, y = -45, width = 288, height = 25, onValueChanged = function(value)
        log:Debugf("Setting departing bonuses to %s", value)
        Timeline.departingBonuses = value
        Timeline.departingBonusesInput:SetText(value)
    end })
    Timeline.arrivalBonusesInput = panel:Input({ id = "ArrivalBonus", x = 980, y = -79, width = 288, height = 25, onValueChanged = function(value)
        log:Debugf("Setting arrival bonuses to %s", value)
        Timeline.arrivalBonuses = value
        Timeline.arrivalBonusesInput:SetText(value)
    end })

    local coords = {
        { x = 1301, y = -112 },
        { x = 1301, y = -142 },
        { x = 1301, y = -173 },
        { x = 1435, y = -112 },
        { x = 1435, y = -142 },
        { x = 1435, y = -172 },
    }
    for i, survivalAction in ipairs(Timeline.survivalActions) do
        local x, y = coords[i].x, coords[i].y
        survivalAction.checkBox = panel:CheckBox({ id = "SurvivalAction"..i, x = x, y = y, width = 20, height = 20, uncheckedImage = "CheckBoxEmpty", active = false, onClick = function()
            local name = Timeline.survivalActions[i].name
            if name then
                local checked = not Timeline.survivalActions[i].checked
                log:Debugf("%s survival action %s", checked and "Checking" or "Unchecking", name)
                Timeline.survivalActions[i].checked = checked
                Timeline.survivalActions[i].checkBox:Check(checked)
            end
        end })
        survivalAction.text = panel:Text({ id = "SurvivalAction"..i, x = x+26, y = y + 5, width = 100, height = 30, fontSize = 12, fontStyle = "Bold", text = "Embolden", active = false })
    end

    local checkBoxY = -277
    local textY = checkBoxY + 2
    local buttonY = -272
    local dy = -40
    for i, milestone in ipairs(Timeline.milestones) do
        milestone.checkBox = panel:CheckBox( { id = "Milestone"..i, x = 1301, y = checkBoxY, width = 20, height = 20, uncheckedImage = "CheckBoxEmpty", active = false, onClick = function()
            local milestone = Timeline.milestones[i]
            assert(milestone)
            local value = not milestone.checked
            log:Debugf("%s milestone %s", value and "Checking" or "Unchecking", milestone.name)
            milestone.checked = value
            Timeline.milestones[i].checkBox:Check(value)
        end })
        milestone.text = panel:Text({ id = "Milestone"..i, x = 1326, y = textY, width = 86, height = 25, fontSize = 12, fontStyle = "Bold", active = false })
        milestone.eventButton = panel:Button({ id = "MilestoneEvent"..i, x = 1417, y = buttonY, width = 145, height = 30, image = "MilestoneButton", active = false, onClick = function(mouseButton, player)
            local milestone = Timeline.milestones[i]
            assert(milestone)
            Timeline.HideUiForAll()
            local rulebook, state = Rules.RulebookAndState(milestone.event)
            Rules.SpawnRules(rulebook, state)
            --Location.Get("Rules Board"):LookAt({ pitch = 90 })
        end })
        milestone.eventText = panel:Text({ id = "MilestoneEvent"..i, x = 1447, y = buttonY, width = 108, height = 30, fontSize = 12, color = Ui.LIGHT_BROWN, active = false })

        checkBoxY = checkBoxY + dy
        textY = textY + dy
        buttonY = buttonY + dy
    end

    local dy = 27
    for i, quarry in ipairs(Timeline.quarries) do
        local x = (i <= 5) and 1301 or 1437
        local row = (i - 1) % 5
        quarry.input = panel:Input({ id = "Quarries"..i, x = x, y = -499 - (row * dy), width = 125, height = 25, fontSize = 12, fontStyle = "Bold", onValueChanged = function(value)
            log:Debugf("Setting quarries[%d] to %s", i, value)
            Timeline.quarries[i].quarry = value
            Timeline.quarries[i].input:SetText(value)
        end })
    end

    local dy = 27
    for i, note in ipairs(Timeline.notes) do
        note.input = panel:Input({ id = "Notes"..i, x = 1301, y = -719 - (i - 1) * dy, width = 261, height = 25, onValueChanged = function(value)
            log:Debugf("Setting settlement notes %d to %s", i, value)
            Timeline.notes[i].note = value
            Timeline.notes[i].input:SetText(value)
        end })
    end

    -----------------------------------------------------------------------------------------------

    local scroll = panel:VerticalScroll({ id = "V", x = 23, y = -158, width = 1242, height = 760 - 6 })
    local timelinePanel = scroll:Panel({ id = "Timeline", x = 0, y = 0, width = 1242, height = 1563 })
    timelinePanel:Image({ id = "Timeline", image = "Timeline30", x = 0, y = 0, width = 1242, height = 1563 })

    local x1 = 78
    local width = 172
    local dx = 192
    local dy = -52
    local offset = 30

    for i, year in ipairs(Timeline.years) do
        local y = -15 + ((i - 1) * dy)
        year.checkBox = timelinePanel:CheckBox({ id = "Year"..i, x = 10, y = y, width = 20, height = 20, uncheckedImage = "CheckBoxEmpty", onClick = function()
            local checked = not Timeline.years[i].checked
            log:Debugf("%s year %d", checked and "Checking" or "Unchecking", i)
            Timeline.years[i].checked = checked
            Timeline.years[i].checkBox:Check(checked)
        end })

        local y = -10 + ((i - 1) * dy)
        for j, event in ipairs(year.events) do
            local id = "Year"..i.."Event"..j
            local x = x1 + ((j - 1) * dx)
            year.events[j].button = timelinePanel:Button({ id = id, x = x, y = y, width = width, height = 30, onClick = function(mouseButton)
                Timeline.ShowTimelineEventPopup(i, j)
            end })
            year.events[j].text = timelinePanel:Text({ id = id, x = x + offset, y = y, width = width - offset, height = 30, fontSize = 12, horizontalOverflow = "Wrap", color = Ui.LIGHT_BROWN })
        end
    end

    -----------------------------------------------------------------------------------------------

    Timeline.popupOpen = false

    local popupPanel = ui:Panel({ id = "AddTimelineEvent", rectAlignment = "MiddleCenter", x = 0, y = 0, width = 376, height = 493, active = false })
    Timeline.popupPanel = popupPanel
    popupPanel:Image({ id = "AddTimelineEvent", image = "AddTimelineEvent", x = 0, y = 0, width = 376, height = 493 })
    popupPanel:Button({ id = "Close", x = 336, y = -10, width = 30, height = 30, onClick = function()
        Timeline.HideTimelineEventPopup()
    end })
    Timeline.popupSearchInput = popupPanel:Input({ id = "Search", x = 13+5, y = -52, width = 350-6, height = 30, fontSize = 14, textColor = Ui.LIGHT_BROWN, placeholder = "search events...", onValueChanged = Timeline.SearchEvents })
    Timeline.popupResults = {}
    Timeline.popupResultButtons = {}
    Timeline.popupResultIcons = {}
    Timeline.popupResultTexts = {}
    for i = 1, Timeline.MAX_TIMELINE_EVENT_POPUP_RESULTS do
        local y = -67 - (i * 30)
        local x = 13+3
        Timeline.popupResultButtons[i] = popupPanel:Button({ id = "SearchResult"..i, x = x, y = y, width = 350-6, height = 30, active = false, onClick = function()
            Timeline.AddTimelineEvent(Timeline.popupYear, Timeline.popupEvent, Timeline.popupResults[i])
            Timeline.HideTimelineEventPopup()
        end })
        x = x + 2   -- 2 padding
        Timeline.popupResultIcons[i] = popupPanel:Image({ id = "SearchResult"..i, x = x, y = y-5, width = 24, height = 20, active = false })
        x = x + 24 + 3  -- 3 padding
        Timeline.popupResultTexts[i] = popupPanel:Text({ id = "SearchResult"..i, x = x, y = y, width = 350-6-24-6, height = 30, fontSize = 14, color = Ui.LIGHT_BROWN, active = false })
    end
    Timeline.popupCustomNameInput = popupPanel:Input({ id = "CustomName", x = 13+3, y = -355, width = 350-6, height = 30, fontSize = 14, textColor = Ui.LIGHT_BROWN, placeholder = "enter event name...", onValueChanged = function(value)
        log:Debugf("Setting custom name to %s", value)
        Timeline.popupCustomName = value
    end })
    Timeline.popupType = "RulebookEvent"
    Timeline.popupTypeOptionCheckBoxGroup = popupPanel:OptionCheckBoxGroup({ id = "Event", uncheckedImage = "CheckBoxEmpty", uncheckedColors = Ui.IMAGE_COLORS, onClick = function(option)
        log:Debugf("Selected event type %s", option:OptionValue())
        Timeline.popupType = option:OptionValue()
        option:Select()
    end })
    Timeline.popupRulebookEventCheckBox = Timeline.popupTypeOptionCheckBoxGroup:OptionCheckBox({ x = 58, y = -405, width = 20, height = 20, checked = true, optionValue = "RulebookEvent" })
    Timeline.popupShowdownEventCheckBox = Timeline.popupTypeOptionCheckBoxGroup:OptionCheckBox({ x = 166, y = -405, width = 20, height = 20, optionValue = "ShowdownEvent" })
    Timeline.popupSettlementEventCheckBox = Timeline.popupTypeOptionCheckBoxGroup:OptionCheckBox({ x = 270, y = -405, width = 20, height = 20, optionValue = "SettlementEvent" })
    popupPanel:Button({ id = "Add", x = 65, y = -450, width = 100, height = 30, onClick = function()
        if Timeline.popupCustomName == nil or Timeline.popupCustomName == "" then
            return log:Broadcastf("Please enter the event's name.")
        end

        Timeline.AddTimelineEvent(Timeline.popupYear, Timeline.popupEvent,  { name = Timeline.popupCustomName, type = Timeline.popupType, custom = true })
        Timeline.HideTimelineEventPopup()
    end })
    popupPanel:Button({ id = "Cancel", x = 211, y = -450, width = 100, height = 30, onClick = Timeline.HideTimelineEventPopup })
end

---------------------------------------------------------------------------------------------------

function Timeline.PostInit()
    Timeline.SetUiFromState()
end

---------------------------------------------------------------------------------------------------

function Timeline.SetUiFromState()
    Timeline.settlementNameInput:SetText(Timeline.settlementName)
    Timeline.survivalLimitCounter:SetText(Timeline.survivalLimit)
    Timeline.departingBonusesInput:SetText(Timeline.departingBonuses)
    Timeline.arrivalBonusesInput:SetText(Timeline.arrivalBonuses)

    for _, survivalAction in ipairs(Timeline.survivalActions) do
        if survivalAction.name then
            survivalAction.checkBox:Show()
            survivalAction.checkBox:Check(survivalAction.checked)
            survivalAction.text:Show()
            survivalAction.text:SetText(survivalAction.name)
        else
            survivalAction.checkBox:Hide()
            survivalAction.text:Hide()
        end
    end

    for _, milestone in ipairs(Timeline.milestones) do
        if milestone.name then
            milestone.checkBox:Show()
            milestone.checkBox:Check(milestone.checked)
            milestone.text:Show()
            milestone.text:SetText(milestone.name)
            milestone.eventButton:Show()
            milestone.eventText:Show()
            milestone.eventText:SetText(milestone.event)
        else
            milestone.checkBox:Hide()
            milestone.text:Hide()
            milestone.eventButton:Hide()
            milestone.eventText:Hide()
        end
    end

    for _, quarry in ipairs(Timeline.quarries) do
        quarry.input:SetText(quarry.quarry)
    end

    for _, note in ipairs(Timeline.notes) do
        note.input:SetText(note.note)
    end

    for i, year in ipairs(Timeline.years) do
        year.checkBox:Check(year.checked)
        for j, event in ipairs(year.events) do
            if event.event then
                Timeline.AddTimelineEvent(i, j, event.event)
            else
                Timeline.RemoveTimelineEvent(i, j)
            end
        end
    end
end

-----------------------------------------------------------------------------------------------

function Timeline.Save()
    local survivalActions = {}
    for i, survivalAction in pairs(Timeline.survivalActions) do
        if survivalAction and survivalAction.name then
            survivalActions[i] = { name = survivalAction.name, checked = survivalAction.checked }
        end
    end

    local milestones = {}
    for i, milestone in ipairs(Timeline.milestones) do
        if milestone.name then
            milestones[i] = { name = milestone.name, checked = milestone.checked, event = milestone.event }
        end
    end

    local quarries = {}
    for i, quarry in ipairs(Timeline.quarries) do
        quarries[i] = quarry.quarry
    end

    local notes = {}
    for i, note in ipairs(Timeline.notes) do
        notes[i] = note.note
    end

    local years = {}
    for i, year in ipairs(Timeline.years) do
        local events = {}
        for j, event in ipairs(year.events) do
            events[j] = event.event
        end
        years[i] = { checked = year.checked, events = events }
    end

    return {
        name = Timeline.settlementName,
        survivalLimit = Timeline.survivalLimit,
        departingBonuses = Timeline.departingBonuses,
        arrivalBonuses = Timeline.arrivalBonuses,
        survivalActions = survivalActions,
        milestones = milestones,
        quarries = quarries,
        notes = notes,
        years = years,
    }
end

---------------------------------------------------------------------------------------------------

function Timeline.Import(importState)
    Timeline.InitState(importState)
    Timeline.SetUiFromState()
end

---------------------------------------------------------------------------------------------------

function Timeline.Export()
    return Timeline.Save()  -- no difference for us
end

---------------------------------------------------------------------------------------------------

function Timeline.ShowUi(player)
    log:Debugf("Showing settlement UI for ".. player.steam_name)

    str = Timeline.panel:ShowForPlayer(player.color)

    if str == player.color then
        Timeline.uiOpen = true
    else
        log:Errorf(str .. " is already looking at the Settlement UI", player.steam_name, player.color)
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.HideUi(player)
    log:Debugf("Hiding settlement UI for " .. player.steam_name)

    str = Timeline.panel:HideForPlayer(player.color)

    if str == "None" or str == player.color then
        Timeline.uiOpen = false
    else
        log:Errorf(str .. " is already looking at the Settlement UI", player.steam_name, player.color)
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.ShowUiForAll()
    log:Debugf("Showing Timeline UI for all")
    Timeline.panel:Show()
    Timeline.uiOpen = true
end

function Timeline.HideUiForAll()
    log:Debugf("Hiding Timeline UI for all")
    Timeline.panel:Hide()
    Timeline.uiOpen = false
end

---------------------------------------------------------------------------------------------------

function Timeline.IsUiOpen()
    return Timeline.uiOpen
end

---------------------------------------------------------------------------------------------------

function Timeline.ShowTimelineEventPopup(year, event)
    if Timeline.popupOpen then
        log:Debugf("Timeline event panel already open")
        return
    end

    log:Debugf("Showing timeline event panel for year %d, event %d", year, event)

    Timeline.popupPanel:Show()
    Timeline.popupOpen = true
    Timeline.popupYear = year
    Timeline.popupEvent = event
end

---------------------------------------------------------------------------------------------------

function Timeline.HideTimelineEventPopup()
    log:Debugf("Hiding Timeline event popup")

    Timeline.popupPanel:Hide()
    Timeline.popupOpen = nil
    Timeline.popupYear = nil
    Timeline.popupEvent = nil

    Timeline.popupSearchInput:SetText(nil)
    Timeline.SetEventSearchResults({})

    Timeline.popupCustomName = nil
    Timeline.popupCustomNameInput:SetText(nil)

    Timeline.popupType = Timeline.popupRulebookEventCheckBox:OptionValue()
    Timeline.popupRulebookEventCheckBox:Select()
end

---------------------------------------------------------------------------------------------------

function Timeline.SearchEvents(searchTerms)
    if searchTerms == nil or searchTerms == "" then
        Timeline.SetEventSearchResults({})
    end

    -- only accept results that match all terms
    local matchIndex = {}
    local i = 1
    for term in string.gmatch(searchTerms, "%S+") do
        local termMatches = Timeline.trie:Get(term)
        local termIndex = Util.Index(termMatches, "name")
        matchIndex = (i == 1) and termIndex or Util.Intersect(matchIndex, termIndex)
        i = i + 1
    end

    -- sort matches
    local sortedMatches = {}
    for _, m in pairs(matchIndex) do
        table.insert(sortedMatches, m)
    end
    table.sort(sortedMatches, function(x, y) return x.name < y.name end)

    log:Debugf("Search results for %s: %s", searchTerms, Util.Map(sortedMatches, function(m) return m.name end))
    Timeline.SetEventSearchResults(sortedMatches)
end

---------------------------------------------------------------------------------------------------

function Timeline.SetEventSearchResults(results)
    Timeline.popupResults = results
    for i = 1, Util.Min(Timeline.MAX_TIMELINE_EVENT_POPUP_RESULTS, #results) do
        local result = results[i]
        log:Debugf("Setting result %d to %s", i, result.name)

        local button = Timeline.popupResultButtons[i]
        button:Show()

        local icon = Timeline.popupResultIcons[i]
        icon:Show()
        icon:SetImage(Timeline.EVENT_TYPE_ICONS[result.type])

        local text = Timeline.popupResultTexts[i]
        text:Show()
        text:SetText(result.name)
    end

    for i = #results + 1, 5 do
        local button = Timeline.popupResultButtons[i]
        button:Hide()

        local icon = Timeline.popupResultIcons[i]
        icon:Hide()
        icon:SetImage(nil)

        local text = Timeline.popupResultTexts[i]
        text:Hide()
        text:SetText(nil)
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.AddTimelineEvent(yearIndex, eventIndex, params)
    assert(Check.Num(yearIndex))
    assert(Check.Num(eventIndex))

    local name, type = params.name, params.type
    if type == "ShowdownEvent" or type == "HuntEvent" then
        name = params.custom and params.name or Timeline.ShowdownEventTimelineName(params.monster, params.level, params.nemesis)
    end
    assert(Check.Str(name))

    log:Debugf("Adding %s event %s to year %d, event %d", type, name, yearIndex, eventIndex)

    local event = Timeline.years[yearIndex].events[eventIndex]
    event.button:SetImage(Timeline.EVENT_TYPE_IMAGES[type])
    event.button:SetColors(Ui.IMAGE_COLORS)
    event.button:SetOnClick(function(mouseButton, player) Timeline.DoEvent(yearIndex, eventIndex, mouseButton, player) end)
    event.text:Show()
    event.text:SetText(name)

    Timeline.years[yearIndex].events[eventIndex].event = {
        name = name,
        type = type,
        custom = params.custom,
        monster = params.monster,
        nemesis = params.nemesis,
        level = params.level,
    }
end

---------------------------------------------------------------------------------------------------

function Timeline.RemoveTimelineEvent(yearIndex, eventIndex)
    assert(Check.Num(yearIndex))
    assert(Check.Num(eventIndex))

    local event = Timeline.years[yearIndex].events[eventIndex]
    event.button:SetImage(nil)
    event.button:SetColors(Ui.INVISIBLE_COLORS)
    event.button:SetOnClick(function() Timeline.ShowTimelineEventPopup(yearIndex, eventIndex) end)
    event.text:Hide()
    event.text:SetText(nil)

    Timeline.years[yearIndex].events[eventIndex].event = nil
end

---------------------------------------------------------------------------------------------------

Timeline.levelAbbr ={
    ["Level 1"] = "Lvl 1",
    ["Level 2"] = "Lvl 2",
    ["Level 3"] = "Lvl 3",
    ["Level 4"] = "Lvl 4",
}

function Timeline.ShowdownEventTimelineName(monster, level, nemesis)
    level = Timeline.levelAbbr[level] or level
    local name = (monster and monster:len() > 0) and monster or nil
    if monster and level then
        if nemesis then
            return "Nemesis - "..monster.." "..level
        else
            return monster.." "..level
        end
    elseif monster then
        if nemesis then
            return "Nemesis - "..monster
        else
            return monster
        end
    elseif level then
        return "Nemesis - "..level
    else
        return "Nemesis"
    end
end

---------------------------------------------------------------------------------------------------

function Timeline.DoEvent(yearIndex, eventIndex, mouseButton, player)
    local event = Timeline.years[yearIndex].events[eventIndex].event
    assert(Check(event, "No event data for year %d, event %d", yearIndex, eventIndex))

    log:Debugf("Processing year %d, event %d: %s", yearIndex, eventIndex, event)

    if mouseButton == Timeline.RIGHT_MOUSE_BUTTON then
        log:Debugf("RMB clicked, removing year %d, event %d", yearIndex, eventIndex)
        Timeline.RemoveTimelineEvent(yearIndex, eventIndex)

    else
        local handler = Timeline.eventHandlersByType[event.type]
        assert(Check(handler, "Unrecognized event type: %s", event.type))
        handler(event, player)
    end
end

---------------------------------------------------------------------------------------------------

Timeline.eventHandlersByType = {
    ["RulebookEvent"] = function(event, player)
        if event.custom then
            return log:Debugf("Custom timeline event button, no effect")
        end

        Timeline.HideUiForAll()
        rulebook, state = Rules.RulebookAndState(event.name)
        Rules.SpawnRules(rulebook, state)
        --Location.Get("Rules Board"):LookAt({ pitch = 90 })
    end,

    ["ShowdownEvent"] = function(event, player)
        if event.custom then
            Timeline.HideUiForAll()
            Showdown.ShowUi(player)
            return
        end


        local msg = string.format("Ready to start showdown for %s", event.monster)
        if event.level then
            msg = msg.." ("..event.level..")"
        end
        msg = msg.."?"
        MessageBox.Show(msg, function()
            Timeline.HideUiForAll()
            Showdown.Setup(event.monster, event.level)
        end)
    end,

    ["HuntEvent"] = function(event, player)
        if event.custom then
            Timeline.HideUiForAll()
            Hunt.ShowUi(player)
            return
        end


        local msg = string.format("Ready to start hunt for %s", event.monster)
        if event.level then
            msg = msg.." ("..event.level..")"
        end
        msg = msg.."?"
        MessageBox.Show(msg, function()
            Timeline.HideUiForAll()
            Hunt.Setup(event.monster, event.level)
        end)
    end,

    ["SettlementEvent"] = function(event, player)
        Timeline.HideUiForAll()

        local settlementEventsLocation = Location.Get("Settlement Events")
        local deck = settlementEventsLocation:FirstObject({ types = { "Settlement Events" } })
        if deck == nil then
            log:Broadcastf("Couldn't find Settlement Event deck in the highlighted location, so created a new one.")
            deck = Archive.Take({ name = "Settlement Events", type = "Settlement Events", location = settlementEventsLocation, rotation = { x = 0, y = 180, z = 180 } })
            Util.Highlight(deck)
        end
        local card = Container(deck):Take({ name = event.name, type = "Settlement Events", location = Location.Get("Drawn Settlement Events") })
        if not card then
            log:Broadcastf("Couldn't find the '%s' card in the Settlement Events Deck", event.name)
            Util.Highlight(deck)
            return
        end

        --Util.LookAt({ object = card, pitch = 75, distance = 10 })
    end
}

---------------------------------------------------------------------------------------------------

return {
    Init = Timeline.Init,
    PostInit = Timeline.PostInit,
    Save = Timeline.Save,
    Import = Timeline.Import,
    Export = Timeline.Export,
    ShowUi = Timeline.ShowUi,
    HideUi = Timeline.HideUi,
    ShowUiForAll = Timeline.ShowUiForAll,
    HideUiForAll = Timeline.HideUiForAll,
    IsUiOpen = Timeline.IsUiOpen,
    MAX_YEARS = Timeline.MAX_YEARS,
    MAX_YEAR_EVENTS = Timeline.MAX_YEAR_EVENTS,
}

end)
__bundle_register("Kdm/Util/Trie", function(require, _LOADED, __bundle_register, __bundle_modules)
local Util = require("Kdm/Util/Util")

local Trie = {}

---------------------------------------------------------------------------------------------------
-- trie multimap: maps prefixes to one or more values
-- all searches are case-insensitive

local TrieClass = {}
TrieClass.__index = TrieClass

local function Trie_Create()
   local trie = {
      children = {},
      byte = nil,
      values = {},
   }
   setmetatable(trie, TrieClass)
   return trie
end

---------------------------------------------------------------------------------------------------

-- associates word to value, so that a subsequent Trie.Get by word (or a prefix) will include this value
function TrieClass.Set(trie, word, value)
   word = string.lower(word)
   local node = trie
   for i = 1, #word do
      local b = word:byte(i)
      local foundChild = nil
      for _, child in ipairs(node.children) do
         if child.byte == b then
            foundChild = child
            break
         end
      end

      if foundChild == nil then
         foundChild = {
            children = {},
            byte = b,
            values = {},
         }
         table.insert(node.children, foundChild)
      end

      node = foundChild
   end

   table.insert(node.values, value)
end

---------------------------------------------------------------------------------------------------

-- returns all values for all words starting with the word arg
function TrieClass.Get(trie, word)
   word = string.lower(word)
   local node = trie
   for i = 1, #word do
      local b = word:byte(i)
      local foundChild = nil
      for _, child in pairs(node.children) do
         if child.byte == b then
            foundChild = child
            break
         end
      end

      if foundChild == nil then
         return {}
      end

      node = foundChild
   end

   -- BFS down the rest of the tree and aggregate all results
   local results = {}
   local queue = {}
   table.insert(queue, node)
   while #queue > 0 do
      node = queue[#queue]
      table.remove(queue)

      for _, v in ipairs(node.values) do
         table.insert(results, v)
      end

      for _, child in pairs(node.children) do
         table.insert(queue, child)
      end
   end

   return results
end

---------------------------------------------------------------------------------------------------

return Trie_Create

end)
__bundle_register("Kdm/Showdown", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local EventManager = require("Kdm/Util/EventManager")
local Expansion = require("Kdm/Expansion")
local Grid = require("Kdm/Util/Grid")
local log = require("Kdm/Log").ForModule("Showdown")
local Location = require("Kdm/Location")
local Monster = require("Kdm/Monster")
local NamedObject = require("Kdm/NamedObject")
local Overlay = require("Kdm/Util/Overlay")
local Player = require("Kdm/Player")
local Rules = require("Kdm/Rules")
local Terrain = require("Kdm/Terrain")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Showdown = {}
Showdown.MAX_TRAITS_MOODS = 14
Showdown.MAX_TERRAIN = 10

---------------------------------------------------------------------------------------------------

function Showdown.Init()
    Showdown.settingUp = false
    Showdown.InitExpansions()
    Showdown.InitUi()
    Showdown.InitOverlay()

    EventManager.AddHandler("onObjectPickUp", Showdown.OnObjectPickUp)
    EventManager.AddHandler("onObjectDrop", Showdown.OnObjectDrop)
end

---------------------------------------------------------------------------------------------------

function Showdown.InitExpansions()
    Showdown.monsters = {}
    Showdown.monstersByName = {}
    Showdown.expansionsByMonsterName = {}
    Showdown.sizesByMonsterName = {}
    Showdown.levelsByMonsterLevelName = {}
    Showdown.minionsByName = {}

    for _, expansion in ipairs(Expansion.All()) do
        for _, monster in ipairs(expansion.monsters or {}) do
            if monster.resourcesDeck == nil then monster.resourcesDeck = monster.name.." Resources" end
            if monster.info == nil then monster.info = monster.name.." Info" end
            if monster.basicAction == nil then monster.basicAction = monster.name.." Basic Action" end
            if monster.basicAiDeck == nil then monster.basicAiDeck = monster.name.." Basic AI" end
            if monster.advancedAiDeck == nil then monster.advancedAiDeck = monster.name.." Advanced AI" end
            if monster.legendaryAiDeck == nil then monster.legendaryAiDeck = monster.name.." Legendary AI" end
            if monster.specialAiDeck == nil then monster.specialAiDeck = monster.name.." Special AI" end
            if monster.hitLocationsDeck == nil then monster.hitLocationsDeck = monster.name.." Hit Locations" end
            monster.expansion = expansion
            table.insert(Showdown.monsters, monster)
            Showdown.monstersByName[monster.name] = monster
            Showdown.expansionsByMonsterName[monster.name] = expansion
            Showdown.sizesByMonsterName[monster.name] = { x = monster.size.x, y = monster.size.y }

            for _, level in ipairs(monster.levels) do
                Showdown.levelsByMonsterLevelName[monster.name..level.name] = level
            end
        end

        for _, minion in ipairs(expansion.minions or {}) do
            Showdown.minionsByName[minion.name] = minion
        end
    end
    table.sort(Showdown.monsters, function(x, y) return x.name < y.name end)
end

---------------------------------------------------------------------------------------------------

function Showdown.InitUi()
    Showdown.uiOpen = false
    local ui = Ui.Get2d()
    local panel = ui:Panel({ id = "Showdown", rectAlignment = "MiddleCenter", x = 0, y = 0, width = 667, height = 632, active = false })
    Showdown.panel = panel
    panel:Image({ id = "Showdown", image = "Showdown", x = 0, y = 0, width = 667, height = 632 })
    panel:Button({ id = "Close", x = 627, y = -10, width = 30, height = 30, onClick = function(mouseButton, player) Showdown.HideUi(player) end })
    local monsterScroll = panel:VerticalScroll({ id = "V", x = 20+3, y = -(109+3), width = 306-6, height = 216-6 })
    local monsterPanel = monsterScroll:Panel({ id = "Monster", x = 0, y = 0, width = 280, height = #Showdown.monsters * 30 })
    Showdown.monsterButtonGroup = monsterPanel:OptionButtonGroup({ id = "Monster", textAlignment = "MiddleLeft", fontSize = 16, onClick = Showdown.SelectMonster })
    Showdown.monsterOptionButtons = {}
    local y = 0
    for _, monster in ipairs(Showdown.monsters) do
        Showdown.monsterOptionButtons[monster.name] = Showdown.monsterButtonGroup:OptionButton({x = 0, y = y, width = 280, height = 30, text = monster.name, optionValue = monster })
        y = y - 30
    end

    local levelPanel = panel:Panel({ id = "Level", x = 341+3, y = -(109+3), width = 306-6, height = 216-6 })

    Showdown.levelButtonGroup = levelPanel:OptionButtonGroup({ id = "Level", textAlignment = "MiddleLeft", fontSize = 16, onClick = function(option)
        local level = option:OptionValue()
        log:Debugf("Selected %s, %s", Showdown.monster.name, level.name)
        Showdown.level = level
        option:Select()
    end  })
    Showdown.levelOptionButtons = {}
    local y = 0
    for i = 1, 7 do
        Showdown.levelOptionButtons[i] = Showdown.levelButtonGroup:OptionButton({ x = 0, y = y, width = 300, height = 30, active = false })
        y = y - 30
    end

    panel:Button({ id = "Begin", x = 183, y = -345, width = 301, height = 60, onClick = function(mouseButton, player)
        if not Showdown.monster or not Showdown.level then
            return log:Broadcastf("Please select a monster and level")
        end

        --log:Printf("Checking if isUnlockedMode")
        if Expansion.IsUnlockedMode() != true then
            local expansion = Showdown.expansionsByMonsterName[Showdown.monster.name]
            if not Expansion.IsEnabled(expansion.name) then
                return log:Broadcastf("Requires %s expansion.", expansion.name)
            end
        end

        log:Debugf("Begin showdown clicked for monster %s, level %s", Showdown.monster.name, Showdown.level.name)
        Showdown.HideUi(player)
        Showdown.Setup(Showdown.monster, Showdown.level)
    end })

    panel:Button({ id = "Clean", x = 183, y = -552, width = 301, height = 60, onClick = function(mouseButton, player)
        log:Debugf("Clean showdown clicked")
        Showdown.Clean()
        Showdown.HideUi(player)
    end })
end

---------------------------------------------------------------------------------------------------

function Showdown.InitOverlay()
    local overlayObject = NamedObject.Get("Overlay")
    local left = 27.011892
    local top = -15.859633
    local right = 76.526237
    local bottom  = -51.838516
    -- local left = 6.363780
    -- local top = -3.159184
    -- local right = -6.015290
    -- local bottom = 5.837886
    local width = right - left
    local cellWidth = width / 21
    local height = bottom - top
    local cellHeight = height / 15

    Showdown.grid = Grid.Create({
        object = overlayObject,
        left = left + cellWidth / 2,
        right = right - cellWidth / 2,
        top = top + cellHeight / 2,
        bottom = bottom - cellHeight / 2,
        -- left = 6.0777295,
        -- top = -2.86238375,
        -- right = -5.73516825,
        -- bottom = 5.527284,
        cols = 22,
        rows = 16,
    })

    Showdown.overlay = Overlay.Create({
        object = overlayObject,
        grid = Showdown.grid,
        --height = 10.75,
        height = 11.750850,
    })
end

---------------------------------------------------------------------------------------------------

function Showdown.ShowUi(player)
    log:Debugf("Showing showdown UI for ".. player.steam_name)

    str = Showdown.panel:ShowForPlayer(player.color)

    if str == player.color then
        Showdown.uiOpen = true
    else
        log:Errorf(str .. "is already looking at the Showdown UI", player.steam_name, player.color)
    end
end

function Showdown.HideUi(player)
    log:Debugf("Hiding showdown UI for ".. player.steam_name)

    str = Showdown.panel:HideForPlayer(player.color)

    if str == "None" or str == player.color then
        Showdown.uiOpen = false
    else
        log:Errorf(str .. "is already looking at the Showdown UI", player.steam_name, player.color)
    end
end

function Showdown.IsUiOpen()
    return Showdown.uiOpen
end

---------------------------------------------------------------------------------------------------

function Showdown.SelectMonster(option)
    local monster = option:OptionValue()
    log:Debugf("Selected %s", monster.name)
    Showdown.monster = monster

    for i, level in ipairs(monster.levels) do
        local levelOptionButton = Showdown.levelOptionButtons[i]
        levelOptionButton:Show()
        levelOptionButton:SetOptionValue(level)
        levelOptionButton:SetText(level.name)
    end

    for i = #monster.levels + 1, 7 do
        local levelOptionButton = Showdown.levelOptionButtons[i]
        levelOptionButton:SetText(nil)
        levelOptionButton:SetOptionValue(nil)
        levelOptionButton:Hide()
    end

    option:Select()

    Showdown.level = Showdown.levelOptionButtons[1]:OptionValue()
    Showdown.levelOptionButtons[1]:Select()
end

-------------------------------------------------------------------------------------------------

function Showdown.MonsterByNameForShowdown(monsterName)
    for _, monster in ipairs(Showdown.monsters) do
        if monster.name == monsterName then
            return monster
        end
    end
end

-------------------------------------------------------------------------------------------------

function Showdown.Setup(monsterOrName, levelOrName)
    if Showdown.settingUp then
        log:Errorf("Showdown setup currently in progress, please wait until finished before setting up another hunt. If the showdown appears to be stuck, click 'Cleanup Showdown' from the 'Cleanup' menu to reset.")
        return
    end

    local monster = nil
    if type(monsterOrName) == "string" then
--        monster = Showdown.monstersByName[monsterOrName]
        monster = Showdown.MonsterByNameForShowdown(monsterOrName)
        assert(Check(monster, "Unknown monster %s", monsterOrName))
    else
        monster = monsterOrName
    end

    local level = nil
    if levelOrName == nil then -- Security check for Showdowns such as Watcher when launched from the Timeline.
        levelOrName = "Level 1"
    end
    if type(levelOrName) == "string" then
        -- Todo: FIX IT
        level = Showdown.levelsByMonsterLevelName[monster.name..levelOrName]
        assert(Check(level, "Unknown level %s for monster %s", levelOrName, monster.name))
    else
        level = levelOrName
    end

    local showdownSetup = level.showdown
    assert(Check(showdownSetup, "No showdown setup for %s, %s", monster.name, level.name))

    local blocking = Showdown.CleanInternal()
    if #blocking > 0 then
        log:Broadcastf("Something is blocking showdown setup. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    log:Printf("Setting up showdown against %s %s...", monster.name, level.name)

    Showdown.settingUp = true

    -----------------------------------------------------------------------------------------------
    -- Rules

    local rules = showdownSetup.rules or monster.rules
    Rules.SpawnRules(rules[1], rules[2])

    -----------------------------------------------------------------------------------------------
    -- Resources

    local monsterResourcesLocation = Location.Get("Monster Resources")
    if not monster.resourcesDeck then
        monsterResourcesLocation:BoxClean({ types = { "Monster Resources" } })

    else
        local monsterResourcesAlreadyExist = false
        local hits = monsterResourcesLocation:RayCast()
        for _, hit in ipairs(hits) do
            local obj = hit.hit_object
            if obj.getGMNotes() == "Monster Resources" then
                if obj.getName() == monster.resourcesDeck then
                    log:Debugf("Found monster resources: %s (%s), skipping spawn", obj.getName(), obj.getGUID())
                    monsterResourcesAlreadyExist = true
                    break
                else
                    log:Debugf("Deleting old monster resources deck %s (%s)", obj.getName(), obj.getGUID())
                    obj.destruct()
                end
            end
        end

        if not monsterResourcesAlreadyExist then
            local monsterResourcesDeck = Archive.Take({ name = monster.resourcesDeck, type = "Monster Resources", location = monsterResourcesLocation, rotation = { x = 0, y = 180, z = 180 }})
            monsterResourcesDeck.shuffle()
        end
    end

    -----------------------------------------------------------------------------------------------
    -- AI

    Archive.Take({ name = monster.info, type = "AI", location = "Monster Info" })
    Archive.Take({ name = monster.basicAction, type = "AI", location = "Basic Action" })

    local basicAiDeck = Container(Archive.Take({ name = monster.basicAiDeck, type = "AI", location = "Unused Basic AI", rotation = { x = 0, y = 180, z = 180 } }))
    basicAiDeck:Shuffle()

    local advancedAiDeck
    if monster.advancedAiDeck then
        advancedAiDeck = Container(Archive.Take({ name = monster.advancedAiDeck, type = "AI", location = "Unused Advanced AI", rotation = { x = 0, y = 180, z = 180 } }))
        advancedAiDeck:Shuffle()
    end

    local legendaryAiDeck
    if monster.legendaryAiDeck then
        legendaryAiDeck = Container(Archive.Take({ name = monster.legendaryAiDeck, type = "AI", location = "Unused Legendary AI", rotation = { x = 0, y = 180, z = 180 } }))
        legendaryAiDeck:Shuffle()
    end

    local specialAiDeck = Container(Archive.Take({ name = monster.specialAiDeck, type = "AI", location = "Unused Special AI", rotation = { x = 0, y = 180, z = 180 } }))

    local miscAiDeck = Container(Archive.Take({ name = "Misc AI", type = "AI", location = "Unused Misc AI", rotation = { x = 0, y = 180, z = 180 } }))

    local nextStartingLocation = 1
    local function NextStartingLocation()
        if nextStartingLocation <= Showdown.MAX_TRAITS_MOODS then
            local location = "Trait/Mood "..nextStartingLocation
            nextStartingLocation = nextStartingLocation + 1
            return location
        end
    end
    local function AddStartingCard(card, deck)
        local location = NextStartingLocation()
        if not location then
            return log:Errorf("Not enough trait/mood slots for starting card %s from deck %s; please place this card manually", card, deck)
        end
        return deck:Take({ name = card, type = "AI", location = location })
    end

    -- starting cards
    if showdownSetup.starting then
        for _, card in ipairs(showdownSetup.starting.basic or {}) do
            AddStartingCard(card, basicAiDeck)
        end
        for _, card in ipairs(showdownSetup.starting.advanced or {}) do
            AddStartingCard(card, advancedAiDeck)
        end
        for _, card in ipairs(showdownSetup.starting.legendary or {}) do
            AddStartingCard(card, legendaryAiDeck)
        end
        for _, card in ipairs(showdownSetup.starting.special or {}) do
            AddStartingCard(card, specialAiDeck)
        end
        for _, card in ipairs(showdownSetup.starting.misc or {}) do
            AddStartingCard(card, miscAiDeck)
        end
        -- special case life to the wound stack
        if showdownSetup.life then
            miscAiDeck:Take({ name = "Life", type = "AI", location = "Wound Stack" })
        end
    end

    -- survivor statuses
    if showdownSetup.survivorStatus then
        for i = 1, 4 do
            log:Debugf("Spawning survivor %d status %s", i, showdownSetup.survivorStatus[i])
            specialAiDeck:Take({ name = showdownSetup.survivorStatus[i], type = "AI", location = "Player "..i.." Status" })
        end
    end

    if showdownSetup.survivorStatus2 then
        for i = 1, 4 do
            log:Debugf("Spawning survivor %d status %s", i, showdownSetup.survivorStatus2[i])
            specialAiDeck:Take({ name = showdownSetup.survivorStatus2[i], type = "AI", location = "Player "..i.." Status" })
        end
    end

    -- build AI deck
    local sources = {}
    for _, card in ipairs(showdownSetup.customBasic or {}) do
        table.insert(sources, Archive.ContainerSource(basicAiDeck, card, "AI" ))
    end
    for _, card in ipairs(showdownSetup.customAdvanced or {}) do
        table.insert(sources, Archive.ContainerSource(advancedAiDeck, card, "AI" ))
    end
    for _, card in ipairs(showdownSetup.customLegendary or {}) do
        table.insert(sources, Archive.ContainerSource(legendaryAiDeck, card, "AI" ))
    end
    for _, card in ipairs(showdownSetup.customSpecial or {}) do
        table.insert(sources, Archive.ContainerSource(specialAiDeck, card, "AI" ))
    end
    for _, card in ipairs(showdownSetup.miscAI or {}) do
        table.insert(sources, Archive.ContainerSource(miscAiDeck, card, "AI" ))
    end
    for i = 1, (showdownSetup.basic or 0) do
        table.insert(sources, Archive.ContainerSource(basicAiDeck))
    end
    for i = 1, (showdownSetup.advanced or 0) do
        table.insert(sources, Archive.ContainerSource(advancedAiDeck))
    end
    for i = 1, (showdownSetup.legendary or 0) do
        table.insert(sources, Archive.ContainerSource(legendaryAiDeck))
    end
    local aiDeck = Archive.CreateDeckFromSources({ sources = sources, location = "AI", name = monster.name.." AI", type = "AI", rotation = { x = 0, y = 180, z = 180 } })
    aiDeck:Shuffle()

    if showdownSetup.topAiCards or showdownSetup.bottomAiCards then
        aiDeck:OrderDeck(showdownSetup.topAiCards, showdownSetup.bottomAiCards)
        -- TODO: hack to work around broken order deck...instead spawn the cards in a specific order
        aiDeck.object.setPositionSmooth(Location.Get("AI"):Center(), false, true)
        aiDeck.object.setRotation({ x = 0, y = 180, z = 180 })
    end

    -----------------------------------------------------------------------------------------------
    -- Hit Locations

    local sources = {
        Archive.ArchiveSource(monster.hitLocationsDeck, "Hit Locations")
    }
    for _, card in ipairs(showdownSetup.miscHitLocations or {}) do
        table.insert(sources, Archive.ContainerSource(miscAiDeck, card, "Hit Locations"))
    end
    local hitLocationsDeck = Archive.CreateDeckFromSources({ sources = sources, location = "HL", name = monster.hitLocationsDeck, type = "Hit Locations", rotation = { x = 0, y = 180, z = 180 } })
    hitLocationsDeck:Shuffle()
    if showdownSetup.removeHitLocations then
        log:Debugf("Taking %s from hit location deck and moving to Unused HL", showdownSetup.removeHitLocations)
        local sources = {}
        for _, hl in ipairs(showdownSetup.removeHitLocations) do
            table.insert(sources, Archive.ContainerSource(hitLocationsDeck, hl, "Hit Locations"))
        end
        Archive.CreateDeckFromSources({ sources = sources, location = "Unused HL", name = "Unused Hit Locations", type = "Hit Locations" })
    end
    if showdownSetup.topHitLocationCards then
        log:Debugf("Putting %s on top of hit location deck", showdownSetup.topHitLocationCards)
        hitLocationsDeck:OrderDeck(showdownSetup.topHitLocationCards)
    end

    -----------------------------------------------------------------------------------------------
    -- Terrain

    local nextTerrainLocation = 1
    local terrainOverflowCol = 2
    local terrainOverflowRow = 2
    local NextTerrainLocation = function()
        if nextTerrainLocation <= Showdown.MAX_TERRAIN then
            terrainLocation = "Terrain "..nextTerrainLocation
            miscLocation = "Misc "..nextTerrainLocation
            nextTerrainLocation = nextTerrainLocation + 1
            return terrainLocation, miscLocation
        else
            log:Errorf("Not enough terrain spaces!")
            location = string.format("(%d, %d)", terrainOverflowCol, terrainOverflowRow)
            terrainOverflowRow = terrainOverflowRow + 3
            if terrainOverflowRow >= 16 then
                terrainOverflowRow = 2
                terrainOverflowCol = terrainOverflowCol + 2
            end
            return location, location
        end
    end

    local terrainDeck = Container(Archive.Take({ name = "Terrain", type = "Terrain", location = "Terrain", rotation = { x = 0, y = 180, z = 180 } }))
    local terrainTilesBag = Container(Archive.Take({ name = "Terrain Tiles", type = "Terrain Tiles", location = "Terrain Tiles" }))

    terrainDeck:Shuffle()

    local terrainTileObjects = {}
    local SpawnTerrainTile = function(terrainTile, location, rotation)
        if not terrainTileObjects[terrainTile] then
            log:Debugf("Spawning new terrain tile %s to %s", terrainTile, location)
            terrainTileObjects[terrainTile] = terrainTilesBag:Take({ name = terrainTile, type = "Terrain Tiles", location = location, rotation = rotation })
        else
            log:Debugf("Cloning terrain tile %s to %s", terrainTile, location)
            local clonePosition = Location.Get(location):Center()
            clonePosition.y = clonePosition.y + 2
            local clonedObject = terrainTileObjects[terrainTile].clone({ position =  clonePosition })
            if rotation then
                Wait.frames(function() clonedObject.setRotation(rotation) end, 2)
            end
        end
    end
    local SpawnTerrain = function(terrain, locations, rotations)
        local terrainLocation, miscLocation = NextTerrainLocation()
        local terrainCard = terrainDeck:Take({ name = terrain, type = "Terrain", location = terrainLocation })
        if not terrainCard then
            return log:Errorf("Couldn't find terrain '%s'", terrain)
        end
        local descriptor
        if terrain then
            descriptor = locations and "fixed" or "unfixed"
        else
            descriptor = "random"
        end
        log:Debugf("Spawned %s %s terrain at %s", descriptor, terrainCard.getName(), location)

        local data = Terrain.Data(terrainCard.getName())
        if locations then
            for i, location in ipairs(locations) do
                SpawnTerrainTile(data.terrainTile, location, rotations[i])
            end
        else
            local count = data.count
            if count == "*" then
                count = level.level
            end

            for i = 1, count do
                SpawnTerrainTile(data.terrainTile, terrainLocation)
            end
        end

        if data.miscObject then
            log:Debugf("Spawning misc object %s/%s at %s", data.miscObject.name, data.miscObject.type, miscLocation)
            Archive.Take({ name = data.miscObject.name, type = data.miscObject.type, location = miscLocation })
        end

        for _, startingCard in ipairs(data.starting or {}) do
            local startingLocation = NextStartingLocation()
            log:Debugf("Spawning starting card %s at %s", startingCard, startingLocation)
            Archive.Take({ name = startingCard, type = "AI", location = startingLocation })
        end
    end

    -- special terrain
    for _, terrainSetup in ipairs(showdownSetup.specialTerrain or monster.specialTerrain or {}) do
        if terrainSetup.terrain then
            terrainLocation, miscLocation = NextTerrainLocation()
            log:Debugf("Spawning special terrain card %s at %s", terrainSetup.terrain, terrainLocation)
            Archive.Take({ name = terrainSetup.terrain, type = "Terrain", location = terrainLocation })
        end
        if terrainSetup.terrainTile then
            log:Debugf("Spawning special terrain tile %s at %s", terrainSetup.terrainTile, terrainSetup.position)
            Archive.Take({ name = terrainSetup.terrainTile, type = "Terrain Tiles", location = terrainSetup.position, rotation = terrainSetup.rotation })
        end
        if terrainSetup.miscObject then
            log:Debugf("Spawning special misc object %s/%s at %s", terrainSetup.miscObject.name, terrainSetup.miscObject.type, miscLocation)
            Archive.Take({ name = terrainSetup.miscObject.name, type = terrainSetup.miscObject.type, location = miscLocation })
        end
    end

    -- fixed terrain
    for _, terrainSetup in ipairs(showdownSetup.fixedTerrain or monster.fixedTerrain or {}) do
        SpawnTerrain(terrainSetup.terrain, terrainSetup.positions, terrainSetup.rotations)
    end

    -- unfixed terrain
    for _, terrain in ipairs(showdownSetup.unfixedTerrain or monster.unfixedTerrain or {}) do
        SpawnTerrain(terrain, nil, nil)
    end

    -- random terrain
    for i = 1, (showdownSetup.randomTerrain or monster.randomTerrain or 0) do
        SpawnTerrain(nil, nil, nil)
    end

    -----------------------------------------------------------------------------------------------
    -- misc object

    local miscObject = showdownSetup.miscObject or monster.miscObject
    if miscObject then
        log:Debugf("Spawning misc object %s", miscObject.name)
        Archive.Take({ name = miscObject.name, type = miscObject.type, location = "Misc" })
    end

    -----------------------------------------------------------------------------------------------
    -- monster

    Archive.Take({
        name = monster.name,
        type = "Monster Figurine",
        location = showdownSetup.position or monster.position,
        rotation = showdownSetup.rotation or monster.rotation,
    })

    -- stats
    for _, stat in ipairs({ "movement", "toughness", "speed", "damage", "accuracy", "evasion", "luck" }) do
        Monster.SetStat(stat, showdownSetup[stat] or 0)
    end

    -----------------------------------------------------------------------------------------------
    -- players
    local playerLocations = showdownSetup.playerPositions or monster.playerPositions
    local playerRotations = showdownSetup.playerRotations or monster.playerRotations or {{ x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 }, { x = 0, y = 0, z = 0 } }
    for i, player in ipairs(Player.Players()) do
        local figurine = player:FigurineObject()
        if figurine then
            figurine.setPositionSmooth(Location.Get(playerLocations[i]):Center(), false, true)
            figurine.setRotation(playerRotations[i])
        end
    end

    -----------------------------------------------------------------------------------------------

    Archive.Clean()

    Showdown.settingUp = false
    Wait.frames(function() log:Printf("Showdown ready. Adjust your survivor/terrain placement and prepare for death.") end, 120)

    --Location.Get("(11.5, 8.5)"):LookAt({ distance = 90 })

    EventManager.FireEvent(EventManager.ON_SHOWDOWN_STARTED)
end

---------------------------------------------------------------------------------------------------

function Showdown.CleanInternal()
    Archive.Clean()

    local types = {
        "AI",
        "Hit Locations",
        "Terrain",
        "Terrain Tiles",
        "Monster Figurine",
        "Minion Figurine",
        "Tokens",
        "Archive Bag",
    }
    local debug = false

    local blocking = {}
    blocking = Util.ConcatArrays(blocking, Location.Get("Terrain Board"):BoxClean({ types = types, debug = debug }))
    blocking = Util.ConcatArrays(blocking, Location.Get("Monster Board"):BoxClean({ tags = { "Deck" }, types = types, debug = debug }))

    -- don't block for the huge showdown board clean
    Location.Get("Showdown Board"):BoxClean({ types = types, debug = debug })

    for i, player in ipairs(Player.Players()) do
        local figurine = player:FigurineObject()
        if figurine then
            local playerPrefix = "Player "..player.ordinal
            local locationString = playerPrefix.." Marker"
            local location = Location.Get(locationString)
            local position = location:Center()
            position.y = position.y + 1
            figurine.setPositionSmooth(position, false, true)
        end
    end

    return blocking
end

---------------------------------------------------------------------------------------------------

function Showdown.Clean()
    Showdown.settingUp = false

    Showdown.CleanInternal()

    for _, stat in ipairs({ "movement", "toughness", "speed", "damage", "accuracy", "evasion", "luck" }) do
        Monster.SetStat(stat, 0)
    end

    log:Printf("Cleaned up showdown.")

    EventManager.FireEvent(EventManager.ON_SHOWDOWN_ENDED)
end

-------------------------------------------------------------------------------------------------

function Showdown.OnObjectPickUp(_, object)
    local type = object.getGMNotes()
    if type == "Player Figurine" then
        log:Debugf("Player figurine [%s] %s picked up", object.getGUID(), object.getName())

        local player = Player.ForFigurine(object)
        if not player or not player:SurvivorSheet() then
            return
        end
        local color = object.getColorTint()
        color[4] = 0.7
        Showdown.overlay:Show(object.getPosition(), 1, player:SurvivorSheet():Survivor():ModifiedMovement(), color)
        log(player:SurvivorSheet():Survivor():ModifiedMovement())

    elseif type == "Minion Figurine" then
        log:Debugf("Minion figurine [%s] %s picked up", object.getGUID(), object.getName())

        local minion = Showdown.minionsByName[object.getName()]
        if not minion then
            return log:Debugf("Unknown minion %s", object.getName())
        end

        Showdown.overlay:Show(object.getPosition(), 1, minion.movement, { r = 0.0, g = 0.0, b = 0.0, a = 0.9 })

    elseif type == "Monster Figurine" then
        log:Debugf("Monster figurine [%s] %s picked up", object.getGUID(), object.getName())

        local size = Showdown.sizesByMonsterName[object.getName()]
        if not size then
            log:Debugf("Monster %s has no registered size", object.getName())
            return
        end

        if Monster.Movement() == 0 then
            log:Debugf("Movement zero")
            return
        end

        Showdown.overlay:Show(object.getPosition(), size.x, Monster.Movement(), { r = 0.0, g = 0.0, b = 0.0, a = 0.9 })
    end
end

---------------------------------------------------------------------------------------------------

function Showdown.OnObjectDrop(_, object)
    local type = object.getGMNotes()
    if type == "Player Figurine" then
        log:Debugf("Player figurine [%s] %s picked up", object.getGUID(), object.getName())

        local player = Player.ForFigurine(object)
        if player then
            Showdown.overlay:Hide()
        end
        object.setPositionSmooth(Showdown.grid:Snap(object, { x = 1, y = 1 }), false, true)

    elseif type == "Monster Figurine" then
        log:Debugf("Monster figurine [%s] %s dropped", object.getGUID(), object.getName())

        local size = Showdown.sizesByMonsterName[object.getName()]
        if not size then
            return log:Debugf("Monster %s has no registered size", object.getName())
        end

        object.setPositionSmooth(Showdown.grid:Snap(object, size), false, true)
        Showdown.overlay:Hide()

    elseif type == "Minion Figurine" then
        log:Debugf("Minion figurine [%s] %s dropped", object.getGUID(), object.getName())

        local minion = Showdown.minionsByName[object.getName()]
        if not minion then
            return log:Debugf("Unrecognized minion: %s", object.getName())
        end

        object.setPositionSmooth(Showdown.grid:Snap(object, minion.size), false, true)
        Showdown.overlay:Hide()


    elseif type == "Terrain Tiles" then
        log:Debugf("Terrain tile [%s] %s dropped", object.getGUID(), object.getName())
        local size = Terrain.TileSize(object.getName())

        if not size then
            return log:Debugf("Terrain tile %s has no registered size", object.getName())
        end

        object.setPositionSmooth(Showdown.grid:Snap(object, size), false, true)
    end
end

---------------------------------------------------------------------------------------------------
return {

    Init = Showdown.Init,
    Setup = Showdown.Setup,
    ShowUi = Showdown.ShowUi,
    HideUi = Showdown.HideUi,
    IsUiOpen = Showdown.IsUiOpen,
    Clean = Showdown.Clean,
}

end)
__bundle_register("Kdm/Terrain", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Expansion = require("Kdm/Expansion")
local log = require("Kdm/Log").ForModule("Terrain")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Terrain = {}

---------------------------------------------------------------------------------------------------

function Terrain.Init()
    Terrain.dataByName = {}
    Terrain.tileSizesByName = {}
    for _, expansion in ipairs(Expansion.All()) do
        for name, data in pairs(expansion.terrain or {}) do
            assert(Check(not Terrain.dataByName[name], "Terrain %s is already registered", name))
            Terrain.dataByName[name] = data
        end

        for terrainTile, size in pairs(expansion.terrainTileSizes or {}) do
            assert(Check, not Terrain.tileSizesByName[terrainTile], "Terrain tile %s is already registered", terrainTile)
            Terrain.tileSizesByName[terrainTile] = size
        end
    end
end

---------------------------------------------------------------------------------------------------

function Terrain.Data(name)
    local data = Terrain.dataByName[name]
    assert(Check(data, "Unrecognized terrain '%s", name))
    return data
end

---------------------------------------------------------------------------------------------------

function Terrain.TileSize(name)
    local tileSize = Terrain.tileSizesByName[name]
    assert(Check(tileSize, "Unrecognized terrain tile '%s'", name))
    return tileSize
end

---------------------------------------------------------------------------------------------------

return {
    Init = Terrain.Init,
    Data = Terrain.Data,
    TileSize = Terrain.TileSize
}

end)
__bundle_register("Kdm/Rules", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local CircularArray = require("Kdm/Util/CircularArray")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Rules")
local NamedObject = require("Kdm/NamedObject")
local Trie = require("Kdm/Util/Trie")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Rules = {}

---------------------------------------------------------------------------------------------------

function Rules.Init()
    Rules.trie = Trie()
    Rules.history = CircularArray(100)
    Rules.index = {}
    Rules.searchResultButtons = {}

    for _, expansion in ipairs(Expansion.All()) do
        Rules.RegisterExpansion(expansion)
    end

    local rules = Rules.GetCurrentRules()
    if rules != nil then
        local currentState = rules.getStateId()
        local rulebookName = nil
        if currentState == -1 then
            rulebookName = rules.getName()
            if rules.Book ~= nil then
                currentState = rules.book.getPage()
            end
        elseif currentState == 1 then
            rulebookName = rules.getName()
        else
            for _, state in ipairs(rules.getStates()) do
                if state.id == 1 then
                    rulebookName = state.name
                end
            end
        end
        assert(Check(rulebookName, "No rules page with state 1 in %s (%s)", rules.getName(), rules.getGUID()))
        Rules.history:Push({ rulebookName, currentState})
    end

    -----------------------------------------------------------------------------------------------

    local xStart = 70+100+10+30+10
    local yStart = -10
    local ui = Ui.Get2d()
    local colors = "#ffffff|#dddddd|#dddddd|#ffffff"
    Rules.searchInput = ui:Input({ id = "RulesSearch", x = xStart, y = yStart, width = 240, height = 30, placeholder = "search rules/events...", workaroundNilColors = true, textColor = "#000000", colors = colors, textOffset = "5 5 0 0", fontSize = 16, onValueChanged = function(value)
        Rules.SetSearchResults(Rules.Search(value))
    end })
    ui:Button({ id = "RulesCancelSearch", x = xStart+240+5, y = yStart, width = 30, height = 30, text = "X", textAlignment = "MiddleCenter", textColor = "#000000", colors = colors, fontSize = 20, onClick = function()
        Rules.SetSearchResults({})
        Rules.searchInput:SetText(nil)
    end })
    Rules.searchResultsPanel = ui:Panel({ id = "RulesSearchResults", x = xStart, y = yStart - 40, width = 300, height = 160, color = "#00000088", active = false })

    Rules.searchResultButtons = {}
    for i = 1, 5 do
        Rules.searchResultButtons[i] = Rules.searchResultsPanel:Button({ id = "Result"..i, x = 5, y = -5 + (i - 1) * -30, width = 280, height = 30, fontSize = 16, colors = Ui.INVISIBLE_COLORS, textColor = "#dddddd" })
    end

    -----------------------------------------------------------------------------------------------

    local ui = Ui.Create3d("RulesNav", NamedObject.Get("Rules Navigation Board"), 0.11)

    local x1 = 7.762758
    local x1End = 6.705129
    local width = x1End - x1
    local x13 = -6.702875
    local dx = (x13 - x1) / 12

    local y1 = -0.401185
    local y1End = 0.047924
    local height = y1End - y1
    local y2 = 0.392804
    local dy = y2 - y1

    local createButton = function(name, col, row, onClick)
        local topLeft = { x =  x1 + ((col - 1) * dx), y = y1 + ((row - 1) * dy) }
        local bottomRight = { x = topLeft.x + width, y = topLeft.y + height }
        ui:Button({ id = name, topLeft = topLeft, bottomRight = bottomRight, onClick = onClick })
    end

    local buttons = {
        { "Core Rules", 1, 1 },
        { "Dragon King Rules", 2, 1 },
        { "Dung Beetle Knight Rules", 3, 1 },
        { "Flower Knight Rules", 4, 1 },
        { "Gorm Rules", 5, 1 },
        { "Lion God Rules", 6, 1 },
        { "Lion Knight Rules", 7, 1 },
        { "Lonely Tree Rules", 8, 1 },
        { "Manhunter Rules", 9, 1 },
        { "Slenderman Rules", 10, 1 },
        { "Spidicules Rules", 11, 1 },
        { "Sunstalker Rules", 12, 1 },
        { "White Gigalion Rules", 13, 1 },
    }
    for _, button in ipairs(buttons) do
        createButton(button[1], button[2], button[3], function() Rules.SpawnRules(button[1], 1) end)
    end

    createButton("Back", 6, 2, Rules.Back)
    createButton("Previous Page", 7, 2, function() Rules.ChangePage(-1) end )
    createButton("Next Page", 8, 2, function() Rules.ChangePage(1) end)

    ui:ApplyToObject()
end


---------------------------------------------------------------------------------------------------

function Rules.RegisterExpansion(expansion)
    for rulebookIndex, rulebook in ipairs(expansion.rulebooks or {}) do
        local rulebookName = rulebook.name
        assert(Check.Str(rulebookName, "rulebook.name"))

        local pages = rulebook.pages
        assert(Check.Table(rulebook.pages))

        for pageName, pageData in pairs(pages) do
            assert(Check.Str(pageName, "rulebooks[%s].pages[pageName]", rulebookName))
            local state = pageData.state
            assert(Check.Num(state, "rulebooks[%s].pages[%s].state", rulebookName, pageName))

            assert(Check(Rules.index[pageName] == nil, "Rulebook page %s is already registered to %s", pageName, Rules.index[pageName]))
            Rules.index[pageName] = { rulebook = rulebookName, state = state }

            local keywords = pageData.keywords
            assert(Check.Table(keywords, "rulebooks[%s].pages[%s].keywords", rulebookName, pageName))

            local entry = {
                rulebook = rulebookName,
                name = pageName,
                state = state,
                timelineEvent = pageData.timelineEvent,
                showdown = pageData.showdown,
            }

            for keywordIndex, keyword in ipairs(keywords) do
                assert(Check.Str(keyword, "rulebooks[%s].pages[%s].keywords[%d]", rulebookName, pageName, keywordIndex))
                Rules.trie:Set(keyword, entry)
            end

            if pageData.huntEventStart then
                local huntEventStart = pageData.huntEventStart
                assert(Check.Num(huntEventStart, "rulebooks[%s].pages[%s].huntEventStart", rulebookName, pageName, keywordIndex))

                local huntEventEnd = pageData.huntEventEnd
                assert(Check.Num(huntEventEnd, "rulebooks[%s].pages[%s].huntEventEnd", rulebookName, pageName, keywordIndex))

                for huntEventNumber = huntEventStart, huntEventEnd do
                    Rules.trie:Set(tostring(huntEventNumber), entry)
                end
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Rules.RulebookAndState(name)
    local data = Rules.index[name]
    assert(Check(data, "Unknown rule: %s", name))
    return data.rulebook, data.state
end

---------------------------------------------------------------------------------------------------

function Rules.Search(searchTerms)
    if searchTerms == nil or searchTerms == "" then
        return {}
    end

    -- only accept results that match all terms
    local matchIndex = {}
    local i = 1
    for term in string.gmatch(searchTerms, "%S+") do
        local termMatches = Rules.trie:Get(term)
        local termIndex = Util.Index(termMatches, "name")

        matchIndex = (i == 1) and termIndex or Util.Intersect(matchIndex, termIndex)
        i = i + 1
    end

    -- sort matches
    local sortedMatches = {}
    for _, m in pairs(matchIndex) do
        table.insert(sortedMatches, m)
    end
    table.sort(sortedMatches, function(x, y) return x.name < y.name end)

    return sortedMatches
end

---------------------------------------------------------------------------------------------------

function Rules.SetSearchResults(results)
    if #results == 0 then
        Rules.searchResultsPanel:Hide()
        return
    end

    Rules.searchResultsPanel:Show()
    local numResults = Util.Min(5, #results)
    Rules.searchResultsPanel:SetHeight(10 + (numResults * 30))

    for i = 1, numResults do
        local result = results[i]
        local button = Rules.searchResultButtons[i]
        button:Show()
        button:SetOnClick(function()
            Rules.searchInput:SetText(nil)
            Rules.SetSearchResults({})
            Rules.SpawnRules(result.rulebook, result.state)
            --Location.Get("Rules Board"):LookAt({ pitch = 90 })
        end)
        button:SetText(result.name)
    end

    for i = numResults + 1, 5 do
        local button = Rules.searchResultButtons[i]
        button:Hide()
        button:SetOnClick(nil)
        button:SetText(nil)
    end
end

---------------------------------------------------------------------------------------------------

function Rules.SpawnRules(rules, state, dontRecordHistory)
    assert(Check.Str(rules))
    assert(Check.Num(state))
    assert(Check.BooleanOrNil(dontRecordHistory))

    log:Debugf("Spawning rules %s[%d]", rules, state)

    local location = Location.Get("Rules Board")
    local blocking = location:BoxClean({ types = { "Rulebook" } })
    if #blocking > 0 then
        log:Broadcastf("Something is blocking the rules board. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    if not Archive.Take({
        name = rules,
        type = "Rulebook",
        location = location,
        spawnFunc = function(obj)
            if obj.Book ~= nil then
                Wait.frames(function()
                    if state > 1 then
                        obj.Book.setPage(state)
                    end
                    obj.setLock(true)
                end, 3)
            else
                if state > 1 then
                    obj = obj.setState(state)
                end
                Wait.frames(function() obj.setLock(true) end, 3)
            end
        end,
    }) then
        log:Errorf("Unrecognized rules: %s[%d]", rules, state)
    end
    Archive.Clean()

    if not dontRecordHistory then
        Rules.history:Push({ rules, state })
    end
end

---------------------------------------------------------------------------------------------------

function Rules.GetCurrentRules()
    return Location.Get("Rules Board"):FirstObject({ types = { "Rulebook" } })
end

---------------------------------------------------------------------------------------------------

function Rules.Back()
    local rules = Rules.GetCurrentRules()
    if not rules then
        return
    end

    if Rules.history:Size() <= 1 then
        log:Debugf("<= 1 history element, can't go back")
        return
    end

    Rules.history:Pop()
    local last = Rules.history:Top()
    log:Debugf("Going back to %s[%d]", last[1], last[2])
    Rules.SpawnRules(last[1], last[2], true)   -- dontRecordHistory
end

---------------------------------------------------------------------------------------------------

function Rules.ChangePage(dir)
    local rules = Rules.GetCurrentRules()
    if not rules then
        log:Debugf("No rules to change")
        return
    end

    local currentState = -1
    if rules.Book ~= nil then
        currentState = rules.Book.getPage()
    else
        currentState = rules.getStateId()
    end
    local nextState = currentState + dir

    log:Debugf("Found current rules %s (%s) at state %d, looking for state %d", rules.getName(), rules.getGUID(), currentState, nextState)

    local rulebookName = (currentState == 1) and rules.getName() or nil
    local hasNext = false

    if rules.Book ~= nil then
        rulebookName = rules.getName()
        hasNext = true
    else
        for _, state in ipairs(rules.getStates()) do
            if state.id == 1 then
                rulebookName = state.name
            end
            if state.id == nextState then
                log:Debugf("Found next state %d: %s", state.id, state.name)
                hasNext = true
            end
        end
    end

    if not hasNext then
        log:Debugf("No state %d", nextState)
        return
    end

    assert(Check(rulebookName, "No rulebook name (page with state 1) in %s (%s)", rules.getName(), rules.getGUID()))

    if rules.Book ~= nil then
        if rules.Book.setPage(nextState) then
            Rules.history:Push({ rulebookName, nextState})
        end
    else
            Rules.history:Push({ rulebookName, nextState })
        local finalObj = rules.setState(nextState)
        Wait.frames(function() finalObj.setLock(true) end, 3)
    end
end

---------------------------------------------------------------------------------------------------

return {
    Init = Rules.Init,
    RulebookAndState = Rules.RulebookAndState,
    Search = Rules.Search,
    SpawnRules = Rules.SpawnRules,
}

end)
__bundle_register("Kdm/NamedObject", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Console = require("Kdm/Console")
local EventManager = require("Kdm/Util/EventManager")
local Expansion = require("Kdm/Expansion")
local log = require("Kdm/Log").ForModule("NamedObject")

---------------------------------------------------------------------------------------------------

local NamedObject = {}

NamedObject.data = {
    ["0b2ed0"] = { name = "Table", noninteractible = true },
    ["bafa19"] = { name = "Top Table", noninteractible = true },
    ["8bf5e2"] = { name = "Left Table", noninteractible = true },
    ["dff000"] = { name = "Bottom Table", noninteractible = true },
    ["f7805a"] = { name = "Right Table", noninteractible = true },

    ["da72c5"] = { name = "Abilities Archive" },
    ["0dc4b8"] = { name = "Fighting Arts Archive" },
    ["13a43d"] = { name = "Secret Fighting Arts Archive" },
    ["590a4f"] = { name = "Disorders Archive" },
    ["1d3367"] = { name = "Severe Injuries Archive" },
    ["379dcf"] = { name = "Tactics Archive" },
    ["a80b96"] = { name = "Weapon Proficiencies Archive" },
    ["d843fb"] = { name = "Armor Sets Archive" },
    ["43ac01"] = { name = "Vermin Archive" },
    ["dd76f7"] = { name = "Strange Resources Archive" },
    ["57a8b5"] = { name = "Basic Resources Archive" },
    ["7223e1"] = { name = "Terrain Archive" },
    ["2551b1"] = { name = "Terrain Tiles Archive" },
    ["916de5"] = { name = "Settlement Events Archive" },
    ["7a04ec"] = { name = "Rare Gear Archive" },
    ["166a4f"] = { name = "Gear Archive" },
    ["26dc61"] = { name = "Monster Resources Archive" },
    ["5d72f3"] = { name = "Hunt Events Archive" },
    ["fdb47b"] = { name = "Survivor Sheets Archive" },
    ["174926"] = { name = "Survivor Boxes Archive" },
    ["54abe6"] = { name = "Dodge Tokens" },
    ["046b7f"] = { name = "Encourage Tokens" },
    ["692b54"] = { name = "Embolden Tokens" },
    ["417446"] = { name = "Dash Tokens" },
    ["64a148"] = { name = "Surge Tokens" },
    ["740242"] = { name = "Overcharge Tokens" },
    ["97f88b"] = { name = "Endure Tokens" },

    ["437cd7"] = { name = "Showdown Board", noninteractible = true }, --(make false to change image)
    ["51a21e"] = { name = "Hunt Board", noninteractible = true },
    ["226d8a"] = { name = "Settlement Board", noninteractible = true },
    ["456dc5"] = { name = "Rules Board", noninteractible = true },
    ["58f2b5"] = { name = "Rules Navigation Board", noninteractible = true },
    ["4ff505"] = { name = "Milestone Board", noninteractible = true },
    ["05e4ab"] = { name = "Export/Import Board", noninteractible = true },

    ["d2a564"] = { name = "Survivor Board", noninteractible = true },
    ["b9c2e9"] = { name = "Survivor Board Cell 1", noninteractible = true },
    ["a56349"] = { name = "Survivor Board Cell 2", noninteractible = true },
    ["89842b"] = { name = "Survivor Board Cell 3", noninteractible = true },
    ["e0af8f"] = { name = "Survivor Board Cell 4", noninteractible = true },
    ["951600"] = { name = "Survivor Board Cell 5", noninteractible = true },
    ["1d1ccc"] = { name = "Survivor Board Cell 6", noninteractible = true },
    ["bea4c0"] = { name = "Survivor Board Cell 7", noninteractible = true },
    ["142a23"] = { name = "Survivor Board Cell 8", noninteractible = true },
    ["8a4bfd"] = { name = "Survivor Board Cell 9", noninteractible = true },
    ["484be9"] = { name = "Survivor Board Cell 10", noninteractible = true },
    ["bf278c"] = { name = "Survivor Board Cell 11", noninteractible = true },
    ["076ed5"] = { name = "Survivor Board Cell 12", noninteractible = true },
    ["385d8a"] = { name = "Survivor Board Cell 13", noninteractible = true },
    ["efc41f"] = { name = "Survivor Board Cell 14", noninteractible = true },
    ["a98661"] = { name = "Survivor Board Cell 15", noninteractible = true },
    ["40baee"] = { name = "Survivor Board Cell 16", noninteractible = true },
    ["d57548"] = { name = "Survivor Board Cell 17", noninteractible = true },
    ["411c2f"] = { name = "Survivor Board Cell 18", noninteractible = true },
    ["fecd6f"] = { name = "Survivor Board Cell 19", noninteractible = true },
    ["a61dd0"] = { name = "Survivor Board Cell 20", noninteractible = true },

    ["34bfdb"] = { name = "Player 1 Board", noninteractible = true },
    ["61f946"] = { name = "Player 2 Board", noninteractible = true },
    ["4f139d"] = { name = "Player 3 Board", noninteractible = true },
    ["276ea7"] = { name = "Player 4 Board", noninteractible = true },

    ["9380cb"] = { name = "Player 1 Marker" },
    ["ed7b20"] = { name = "Player 2 Marker" },
    ["7f1cde"] = { name = "Player 3 Marker" },
    ["9a6e00"] = { name = "Player 4 Marker" },

    ["b07b40"] = { name = "Overlay", noninteractible = true },

    ["18a13f"] = { name = "Allister Archive" },
    ["590a94"] = { name = "Ezra Archive" },
    ["962317"] = { name = "Lucy Archive" },
    ["0a73fe"] = { name = "Zachary Archive" },
    ["966a53"] = { name = "Patterns Archive" },

}

---------------------------------------------------------------------------------------------------

function NamedObject.Init()
    NamedObject.objectsByName = {}
    NamedObject.guids = {}

    for guid, data in pairs(NamedObject.data) do
        NamedObject.Set(data.name, guid)
    end

    for _, expansion in ipairs(Expansion.All()) do
        for guid, name in pairs(expansion.guidNames or {}) do
            NamedObject.Set(name, guid)
        end
    end

    NamedObject.SetInteractable(false)

    EventManager.AddHandler("onObjectDestroy", function(object)
        if NamedObject.guids[object.getGUID()] then
            log:Broadcastf("A critical game component '%s' (GUID %s) was just deleted. This may cause the mod to malfunction. Please restore an earlier save game.", object.getName(), object.getGUID())
        end
    end)

    EventManager.AddHandler("tryObjectEnterContainer", function(container, object, previousReturnValue)
        if previousReturnValue == false then
            return false
        end

        if NamedObject.guids[object.getGUID()] then
            log:Broadcastf("%s (%s) is a critical game component. The mod will break if it's put in a container.", object.getName(), object.getGUID())
            return false
        end

        return true
    end)

    Console.AddCommand("interact", function(args)
        if #args != 2 or (args[2] != "on" and args[2] != "off") then
            Console.Printf("Usage: interact <on|off>")
            return
        end
        local interactible = args[2] == "on"
        NamedObject.SetInteractable(interactible)
        Console.Printf("Set critical game objects to %s", interactible and "interactible" or "non-interactible")
    end, "Toggles whether critical game objects are interactible")
end

---------------------------------------------------------------------------------------------------

function NamedObject.SetInteractable(interactible)
    for _, data in pairs(NamedObject.data) do
        if data.noninteractible then
            NamedObject.Get(data.name).interactable = interactible
        end
    end
end

---------------------------------------------------------------------------------------------------

function NamedObject.Set(name, guid)
    local object = getObjectFromGUID(guid)
    assert(Check(object != nil, "Couldn't find critical component '%s' with guid %s. If you accidentally deleted this object, then you may need to restore an earlier save.", name, guid))
    local existing = NamedObject.objectsByName[name]
    if existing then
        assert(Check.Fail("Tried to add object '%s' with guid %s, but already exists with guid %s", name, existing.getGUID(), guid))
    end

    NamedObject.objectsByName[name] = object
    NamedObject.guids[guid] = true
end

---------------------------------------------------------------------------------------------------

function NamedObject.Get(name)
    local object = NamedObject.objectsByName[name]
    assert(Check(object, "Unknown object '%s'", name))
    return object
end

---------------------------------------------------------------------------------------------------

return {
    Init = NamedObject.Init,
    Get = NamedObject.Get,
}

end)
__bundle_register("Kdm/Location", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Console = require("Kdm/Console")
local EventManager = require("Kdm/Util/EventManager")
local Expansion = require("Kdm/Expansion")
local LocationData = require("Kdm/LocationData")
local log = require("Kdm/Log").ForModule("Location")
local NamedObject = require("Kdm/NamedObject")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Location = {}
Location.__index = Location
function Location.Is(x) return getmetatable(x) == Location end

Location.CELL_SIZE = 1
Location.DEFAULT_CAST_HEIGHT = 20
Location.CLEAN_IGNORE_TAGS = { "Board", "Table" }

---------------------------------------------------------------------------------------------------

function Location.Init()
    Location.locationsByName = {}
    Location.locationsByCell = {}
    Location.locationsByObject = {}

    for name, data in pairs(LocationData) do
        local location = nil
        if data.fromObject then
            location = Location.CreateFromObject(NamedObject.Get(data.fromObject))
        else
            data.name = name
            if data.board then
                data.object = NamedObject.Get(data.board)
            end
            location = Location.Create(data)
        end
        Location.Add(location)
    end

    for _, expansion in ipairs(Expansion.All()) do
        for name, locationParams in pairs(expansion.locations or {}) do
            locationParams.object = NamedObject.Get(locationParams.board)
            Location.Add(Location.Create(locationParams))
        end
    end

    -- Initialize starting objects to their particular locations
    for _, object in ipairs(getAllObjects()) do
        if object.interactable then
            local locations = Location.LocationsAtPosition(object.getPosition())
            Location.locationsByObject[object] = locations
            for _, location in ipairs(locations) do
                log:Debugf("[%s] %s started in %s", object.getGUID(), object.getName(), location)
                location.objects[object] = object
                -- We specifically don't call dropHandlers here
                -- Users are responsible for performing initial location:AllObjects() queries
            end
        end
    end

    EventManager.AddHandler("onObjectDrop", function(_, object) Location.OnEnter(object) end)
    EventManager.AddHandler("onObjectSpawn", function(object) Location.OnEnter(object) end)

    EventManager.AddHandler("onObjectPickUp", function(_, object) Location.OnLeave(object) end)
    EventManager.AddHandler("onObjectEnterContainer", function(_, object) Location.OnLeave(object) end)
    EventManager.AddHandler("onObjectDestroy", function(object) Location.OnLeave(object) end)

    Console.AddCommand("showloc", function(args)
        if #args != 2 then
            return Console.Printf("Usage: showloc <location>")
        end

        local location = Location.locationsByName[args[2]:lower()]
        if not location then
            return Console.Printf("No such location: %s", args[2])
        end

        location:BoxCast({ debug = true })
    end, "Highlights a location")

    Console.AddCommand("locobjects", function(args)
        if #args != 2 then
            return Console.Printf("Usage: locobjects <location>")
        end

        local location = Location.locationsByName[args[2]:lower()]
        if not location then
            return Console.Printf("No such location: %s", args[2])
        end

        local objects = location:AllObjects()
        Console.Printf("%d objects at %s:", #objects, location:Name())
        for _, object in ipairs(objects) do
            Console.Printf("  [%s] %s", object.getGUID(), object.getName())
        end
    end, "Lists objects at a location")
end

---------------------------------------------------------------------------------------------------

function Location.CellIndex(col, row)
    return row.." "..col
end

---------------------------------------------------------------------------------------------------

function Location.Add(location)
    local name = location:Name()
    assert(Check(not Location.locationsByName[name], "Location %s already registered: %s", name, Location.locationsByName[name]))
    Location.locationsByName[name:lower()] = location

    local left, top, right, bottom = Location.CellRect(location)
    for row = top, bottom do
        for col = left, right do
            local index = Location.CellIndex(col, row)
            if not Location.locationsByCell[index] then
                Location.locationsByCell[index] = { location }
            else
                table.insert(Location.locationsByCell[index], location)
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Location.Get(locationOrName)
    if type(locationOrName) == "table" then
        assert(Location.Is(locationOrName))
        return locationOrName
    end

    assert(Check.Str(locationOrName))
    local location = Location.locationsByName[locationOrName:lower()]
    if not location then
        log:Debugf("Unknown location: %s", locationOrName)
    end
    return location
end

---------------------------------------------------------------------------------------------------

function Location.LocationsAtPosition(position)
    local results = {}

    local x, z = position.x, position.z
    local col, row = math.floor(x / Location.CELL_SIZE), math.floor(z / Location.CELL_SIZE)
    local locations = Location.locationsByCell[Location.CellIndex(col, row)] or {}
    for _, location in ipairs(locations) do
        local left, top, right, bottom = location:Rect()
        if x >= left and x <= right and z >= top and z <= bottom then
            table.insert(results, location)
        end
    end

    return results
end

---------------------------------------------------------------------------------------------------

function Location.ObjectLocations(object)
    assert(Check.Object(object))
    return Location.locationsByObject[object]
end

---------------------------------------------------------------------------------------------------

function Location.OnEnter(object)
    if object.held_by_color then
        log:Debugf("[%s] %s held by a player, ignoring", object.getGUID(), object.getName())
        return
    end

    local locations = Location.LocationsAtPosition(object.getPosition())

    -- Link the object with all locations *before* calling handlers, in case the handlers do their own queries
    Location.locationsByObject[object] = locations
    for _, location in ipairs(locations) do
        log:Debugf("[%s] %s entered %s", object.getGUID(), object.getName(), location)
        location.objects[object] = true
    end

    for _, location in ipairs(locations) do
        for _, dropHandler in ipairs(location.dropHandlers) do
            dropHandler(object)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Location.OnLeave(object)
    local locations = Location.locationsByObject[object] or {}

    -- Unlink the object with all locations *before* calling handlers, in case the handlers do their own queries
    for _, location in ipairs(locations) do
        log:Debugf("[%s] %s left %s", object.getGUID(), object.getName(), location)
        location.objects[object] = nil
    end

    for _, location in ipairs(locations) do
        for _, pickUpHandler in ipairs(location.pickUpHandlers) do
            pickUpHandler(object)
        end
    end

    Location.locationsByObject[object] = nil
end

---------------------------------------------------------------------------------------------------

function Location.Create(params)
    assert(Check.Table(params))
    assert(Check.ObjectOrNil(params.object))
    assert(Check.Str(params.name))

    local location = {
        name = params.name,
        objects = {},
        dropHandlers = {},
        pickUpHandlers = {},
    }
    setmetatable(location, Location)

    if params.center and params.size then
        if params.object then
            location.center = params.object.positionToWorld(params.center)
        else
            location.center = params.center
        end
        location.topLeft = {
            x = location.center.x - (params.size.x / 2),
            y = location.center.y - (params.size.y / 2),
            z = location.center.z - (params.size.z / 2),
        }
        location.bottomRight = {
            x = location.center.x + (params.size.x / 2),
            y = location.center.y + (params.size.y / 2),
            z = location.center.z + (params.size.z / 2),
        }

    elseif params.p1 and params.p2 then
        local p1 = params.p1
        local p2 = params.p2
        if params.object then
            p1 = params.object.positionToWorld(p1)
            p2 = params.object.positionToWorld(p2)
        end
        location.center = {
            x = (p1.x + p2.x) / 2,
            y = (p1.y + p2.y) / 2,
            z = (p1.z + p2.z) / 2,
        }
        location.topLeft = {
            x = Util.Min(p1.x, p2.x),
            y = Util.Min(p1.y, p2.y),
            z = Util.Min(p1.z, p2.z),
        }
        location.bottomRight = {
            x = Util.Max(p1.x, p2.x),
            y = Util.Max(p1.y, p2.y),
            z = Util.Max(p1.z, p2.z),
        }

    else
        assert(Check.Fail("Invalid params for Location.Create. Requires either center+size or p1+p2: %s", params))
    end

    return location
end

---------------------------------------------------------------------------------------------------

function Location.CreateFromObject(object)
    local bounds = object.getBounds()
    return Location.Create({ name = object.getName(), center = bounds.center, size = bounds.size })
end

---------------------------------------------------------------------------------------------------

function Location:__tostring()
    return Util.SafeFormat("Location{name=%s}", self.name)
end

---------------------------------------------------------------------------------------------------

function Location:CellRect()
    local left, top, bottom, right = self:Rect()
    return math.floor(left / Location.CELL_SIZE), math.floor(top / Location.CELL_SIZE), math.floor(bottom / Location.CELL_SIZE), math.floor(right / Location.CELL_SIZE)
end

---------------------------------------------------------------------------------------------------

function Location:Name()
    return self.name
end

---------------------------------------------------------------------------------------------------

function Location:Center()
    local c = self.center
    -- always return a copy
    return { x = c.x, y = c.y, z = c.z }
end

---------------------------------------------------------------------------------------------------

function Location:Size()
    local tl, br = self.topLeft, self.bottomRight
    return {
        x = math.abs(br.x - tl.x),
        y = math.abs(br.y - tl.y),
        z = math.abs(br.z - tl.z),
    }
end

---------------------------------------------------------------------------------------------------

function Location:Rect()
    local topLeft, bottomRight = self.topLeft, self.bottomRight
    local left = Util.Min(topLeft.x, bottomRight.x)
    local right = Util.Max(topLeft.x, bottomRight.x)
    local top = Util.Min(topLeft.z, bottomRight.z)
    local bottom = Util.Max(topLeft.z, bottomRight.z)
    return left, top, right, bottom
end

---------------------------------------------------------------------------------------------------

function Location:BoxCast(params)
    params = params or {}

    local center = self:Center()
    center.y = center.y + (params.height or Location.DEFAULT_CAST_HEIGHT)

    local size = nil
    if params.size then
        size = params.size
    else
        size = self:Size()
        size.y = size.x -- doesn't matter, just needs to be > epsilon for a top-down cast
    end

    return Physics.cast({
        origin    = center,
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = size,
        debug     = params.debug,
    })
end

---------------------------------------------------------------------------------------------------

function Location:RayCast(params)
    params = params or {}

    local center = self:Center()
    center.y = center.y + (params.height or Location.DEFAULT_CAST_HEIGHT)

    return Physics.cast({
        origin    = center,
        direction = { x = 0, y = -1, z = 0 },
        type      = 1,
        debug     = params.debug,
    })
end

---------------------------------------------------------------------------------------------------

function Location:FirstObject(params)
    for object, _ in pairs(self.objects) do
        if not object.held_by_color and object.interactable and Location.Matches(object, params.tags, params.types) then
            return object
        end
    end
    return nil
end

---------------------------------------------------------------------------------------------------

function Location:AllObjects(tag)
    local results = {}
    for object, _ in pairs(self.objects) do
        if not object.held_by_color and object.interactable and (tag == nil or object.getGMNotes() == tag) then
            table.insert(results, object)
        end
    end
    return results
end

---------------------------------------------------------------------------------------------------

function Location.Matches(obj, tags, types)
    local matchesTags = tags and Util.ArrayContains(tags, obj.tag)
    local matchesTypes = types and Util.ArrayContains(types, obj.getGMNotes())

    return matchesTags or matchesTypes
end

---------------------------------------------------------------------------------------------------

function Location:Clean(params, castFunc)
    tags, types, debug = params.tags, params.types, params.debug
    log:Debugf("Cleaning %s", self)

    local hits = castFunc(self, { size = params.size, debug = params.debug })
    local blocking = {}
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object

        log:Debugf("Hit object [%s]%s with type %s and tag %s", obj.getGUID(), obj.getName(), obj.getGMNotes(), obj.tag)

        if Location.Matches(obj, Location.CLEAN_IGNORE_TAGS, params.ignoreTypes) or not obj.interactable then
            -- ignore

        elseif Location.Matches(obj, tags, types) then
            log:Debugf("Destroying hit object [%s] %s with matching type %s/tag %s", obj.getGUID(), obj.getName(), obj.getGMNotes(), obj.tag)
            obj.destruct()

        else
            log:Debugf("Hit blocking object %s/%s (%s)", obj.getName(), obj.tag, obj.getGUID())
            table.insert(blocking, obj)
        end
    end

    return blocking
end

function Location:BoxClean(params) return self:Clean(params, Location.BoxCast) end
function Location:RayClean(params) return self:Clean(params, Location.RayCast) end

---------------------------------------------------------------------------------------------------

function Location:LookAt(params)
    params = params or {}
    Util.LookAt({ position = self:Center(), pitch = params.pitch, distance = params.distance })
end

---------------------------------------------------------------------------------------------------

function Location:AddDropHandler(handler)
    assert(Check.Func(handler))
    table.insert(self.dropHandlers, handler)
end

---------------------------------------------------------------------------------------------------

function Location:AddPickUpHandler(handler)
    assert(Check.Func(handler))
    table.insert(self.pickUpHandlers, handler)
end

---------------------------------------------------------------------------------------------------

return {
    Is = Location.Is,
    Init = Location.Init,
    Get = Location.Get,
    LocationsAtPosition = Location.LocationsAtPosition,
    ObjectLocations = Location.ObjectLocations,
}

end)
__bundle_register("Kdm/LocationData", function(require, _LOADED, __bundle_register, __bundle_modules)
local REFERENCE_SIZE = { x = 20, y = 10, z = 16 }
local SETTLEMENT_LOCATION_SIZE = { x = 4.5, y = 10, z = 9 }
local SETTLEMENT_EVENT_SIZE = { x = 3.5, y = 10, z = 6 }
local CARD_SIZE = { x = 2.695, y = 2, z = 4.1 }
local GEAR_SIZE = { x = 2.738, y = 10, z = 2.738 }
local TOKEN_SIZE = { x = 1.412567, y = 0.1, z = 1.405437 }
local SURVIVAL_TOKEN_SIZE = { x = 2.7, y = 0.1, z = 2.7 }

local locationData = {
    ["Rules Board"] = {
        p1 = { x = -8.277505, y = 5, z = 8.241768 },
        p2 = { x = 8.277505, y = -5, z = -8.241768 },
        board = "Rules Board",
    },

    -----------------------------------------------------------------------------------------------

    ["Showdown Board"] = {
        p1 = { x = 11.951257, y = 10.741001, z = -5.955478 },
        p2 = { x = -11.816689, y = 10.741001, z = 7.323251 },
        board = "Showdown Board",
    },

    -----------------------------------------------------------------------------------------------

    ["Deck Board"] = {
        p1 = { x = 6.607502, y = 10.741001, z = 4.154560 },
        p2 = { x = 9.370266, y = 10.741003, z = -2.04 },
        board = "Showdown Board",
    },
    ["Patterns"] = {
        center = { x = 9.015150, y = 10.741002, z = -2.020570 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Abilities"] = {
        center = { x = 9.015150, y = 10.741002, z = -0.620570 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Fighting Arts"] = {
        center = { x = 7.998055, y = 10.741000, z = -0.620570 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Secret Fighting Arts"] = {
        center = { x = 6.980959, y = 10.741003, z = -0.620570 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Disorders"] = {
        center = { x = 9.015150, y = 10.741000, z = 0.785908 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Severe Injuries"] = {
        center = { x = 7.998055, y = 10.741001, z = 0.785908 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Tactics"] = {
        center = { x = 6.980959, y = 10.741001, z = 0.785908 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Weapon Proficiencies"] = {
        center = { x = 9.015150, y = 10.741002, z = 2.192385 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Armor Sets"] = {
        center = { x = 7.998055, y = 10.741001, z = 2.192385 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Vermin"] = {
        center = { x = 6.980959, y = 10.741001, z = 2.192385 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Strange Resources"] = {
        center = { x = 9.015150, y = 10.741002, z = 3.598863 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Basic Resources"] = {
        center = { x = 7.998055, y = 10.741001, z = 3.598863 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Resources"] = {
        center = { x = 6.980959, y = 10.741002, z = 3.598863 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },

    -----------------------------------------------------------------------------------------------

    ["Terrain Board"] = {
        p1 = { x = 5.097445, y = 10.741002, z = -3.411523 },
        p2 = { x = -4.970578, y = 10.741001, z = -4.551477 },
        board = "Showdown Board",
    },
    ["Terrain"] = {
        center = { x = 4.741388, y = 10.741003, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 1"] = {
        center = { x = 3.904032, y = 10.741002, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 2"] = {
        center = { x = 3.066676, y = 10.741000, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 3"] = {
        center = { x = 2.229320, y = 10.741000, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 4"] = {
        center = { x = 1.391964, y = 10.741002, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 5"] = {
        center = { x = 0.554608, y = 10.741001, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 6"] = {
        center = { x = -0.282748, y = 10.741001, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 7"] = {
        center = { x = -1.120104, y = 10.741002, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 8"] = {
        center = { x = -1.957460, y = 10.741003, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 9"] = {
        center = { x = -2.794816, y = 10.741002, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain 10"] = {
        center = { x = -3.632172, y = 10.741000, z = -3.967755 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Terrain Tiles"] = {
        center = { x = -4.515556, y = 10.741003, z = -3.970696 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },

    -----------------------------------------------------------------------------------------------

    ["Misc"] = {
        center = { x = 4.741388, y = 10.741003, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 1"] = {
        center = { x = 3.904032, y = 10.741002, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 2"] = {
        center = { x = 3.066676, y = 10.741000, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 3"] = {
        center = { x = 2.229320, y = 10.741000, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 4"] = {
        center = { x = 1.391964, y = 10.741002, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 5"] = {
        center = { x = 0.554608, y = 10.741001, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 6"] = {
        center = { x = -0.282748, y = 10.741001, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 7"] = {
        center = { x = -1.120104, y = 10.741002, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 8"] = {
        center = { x = -1.957460, y = 10.741003, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 9"] = {
        center = { x = -2.794816, y = 10.741002, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Misc 10"] = {
        center = { x = -3.632172, y = 10.741000, z = -5.395621 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },

    -----------------------------------------------------------------------------------------------

    ["Monster Board"] = {
        p1 = { x = -6.927796, y = 10.741002, z = 5.043711 },
        p2 = { x = -11.358661, y = 10.741003, z = -2.601561 },
        board = "Showdown Board",
    },
    ["Monster Tokens"] = {
        p1 = { x = -6.236383, y = 10.750100, z = -2.637769 },
        p2 = { x = -6.632036, y = 10.750100, z = 1.044209 },
        board = "Showdown Board",
    },
    ["Monster Token 1"] = {
        center = { x = -6.446431, y = 10.741002, z = -2.413854 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 2"] = {
        center = { x = -6.446431, y = 10.741002, z = -1.945359 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 3"] = {
        center = { x = -6.446431, y = 10.741001, z = -1.476864 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 4"] = {
        center = { x = -6.446431, y = 10.741001, z = -1.008369 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 5"] = {
        center = { x = -6.446431, y = 10.741000, z = -0.539874 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 6"] = {
        center = { x = -6.446431, y = 10.741000, z = -0.071379 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 7"] = {
        center = { x = -6.446431, y = 10.741000, z = 0.397116 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Token 8"] = {
        center = { x = -6.446431, y = 10.741000, z = 0.865611 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    -- traits/moods aren't listed in top-down, left-to-right
    ["Trait/Mood 1"] = {
        center = { x = -7.280050, y = 10.741001, z = 0.415547 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 2"] = {
        center = { x = -7.280050, y = 10.741002, z = -0.812282 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 3"] = {
        center = { x = -7.280050, y = 10.741000, z = -2.040111 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 4"] = {
        center = { x = -8.116979, y = 10.741001, z = 0.415547 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 5"] = {
        center = { x = -8.116979, y = 10.741001, z = -0.812282 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 6"] = {
        center = { x = -8.116979, y = 10.741000, z = -2.040111 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 7"] = {
        center = { x = -8.953908, y = 10.741001, z = 1.643376 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 8"] = {
        center = { x = -8.953908, y = 10.741002, z = 0.415547 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 9"] = {
        center = { x = -8.953908, y = 10.741001, z = -0.812282 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 10"] = {
        center = { x = -8.953908, y = 10.741001, z = -2.040111 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 11"] = {
        center = { x = -9.790837, y = 10.741000, z = 1.643376 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 12"] = {
        center = { x = -9.790837, y = 10.741002, z = 0.415547 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 13"] = {
        center = { x = -9.790837, y = 10.741003, z = -0.812282 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Trait/Mood 14"] = {
        center = { x = -9.790837, y = 10.741002, z = -2.040111 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Basic Action"] = {
        center = { x = -7.280050, y = 10.741002, z = 1.643376 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Monster Info"] = {
        center = { x = -8.116979, y = 10.741001, z = 1.643376 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["AI"] = {
        center = { x = -7.458938, y = 10.741000, z = 3.058557 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["AI Discard"] = {
        center = { x = -8.625810, y = 10.741002, z = 3.058557 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Wound Stack"] = {
        center = { x = -9.786024, y = 10.741003, z = 3.058821 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["HL"] = {
        center = { x = -7.458938, y = 10.741002, z = 4.473865 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["HL Discard"] = {
        center = { x = -8.625810, y = 10.741003, z = 4.473865 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused HL"] = {
        center = { x = -9.786024, y = 10.741003, z = 4.475617 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused Basic AI"] = {
        center = { x = -10.986748, y = 10.741000, z = -2.038309 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused Advanced AI"] = {
        center = { x = -10.986748, y = 10.741002, z = -0.410267 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused Legendary AI"] = {
        center = { x = -10.986748, y = 10.741002, z = 1.217774 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused Special AI"] = {
        center = { x = -10.986748, y = 10.741003, z = 2.845815 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },
    ["Unused Misc AI"] = {
        center = { x = -10.986748, y = 10.741002, z = 4.473855 },
        size = CARD_SIZE,
        board = "Showdown Board",
    },

    -----------------------------------------------------------------------------

    ["Hunt Cards"] = {
        p1 = { x = 3.833936, y = 6, z = -7.537293 },
        p2 = { x = -3.839113, y = -4, z = -2.886444 },
        board = "Hunt Board",
    },
    ["Hunt Track"] = {
        p1 = { x = 7.85826, y = 6, z = -0.780489 },
        p2 = { x = -7.831961, y = -4, z = 6.639576 },
        board = "Hunt Board",
    },
    ["Hunt Events"] = {
        center = { x = 3.375038, y = 0.860623, z = -5.170869 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Monster Hunt Events"] = {
        center = { x = 2.357527, y = 0.860623, z = -5.170869 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["The Forest Gate"] = {
        center = { x = 1.340017, y = 0.860623, z = -5.170868 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Herb Gathering"] = {
        center = { x = -1.338467, y = 0.860623, z = -5.170869 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Mineral Gathering"] = {
        center = { x = -2.357022, y = 0.860623, z = -5.170869 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Sky Fishing"] = {
        center = { x = -3.375580, y = 0.860623, z = -5.170869 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track Start"] = {
        center = { x = 7.273605, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 1"] = {
        center = { x = 6.059363, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 2"] = {
        center = { x = 4.845125, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 3"] = {
        center = { x = 3.630886, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 4"] = {
        center = { x = 2.416644, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 5"] = {
        center = { x = 1.202405, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 6"] = {
        center = { x = -0.011834, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 7"] = {
        center = { x = -1.226075, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 8"] = {
        center = { x = -2.440314, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 9"] = {
        center = { x = -3.654553, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 10"] = {
        center = { x = -4.868794, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track 11"] = {
        center = { x = -6.083034, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },
    ["Hunt Track Starvation"] = {
        center = { x = -7.297274, y = 0.860623, z = 2.921042 },
        size = CARD_SIZE,
        board = "Hunt Board",
    },

    -----------------------------------------------------------------------------

    ["Settlement Board"] = {
        p1 = { x = 8.086164, y = 0.602996, z = -8.141978 },
        p2 = { x = -8.090731, y = 0.602995, z = 8.148751 },
        board = "Settlement Board",
    },
    ["Innovation Deck"] = {
        center = { x = 3.051355, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Principle: Death"] = {
        center = { x = 2.179312, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Principle: New Life"] = {
        center = { x = 1.307268, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Bookmark Archive"] = {
        center = { x = 0, y = 0.595169, z = -7.673294 },
        size = SETTLEMENT_EVENT_SIZE,
        board = "Settlement Board",
    },
    ["Principle: Society"] = {
        center = { x = -1.308862, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Principle: Conviction"] = {
        center = { x = -2.180904, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Innovation Archive"] = {
        center = { x = -3.052947, y = 0.595169, z = -7.423294 },
        size = CARD_SIZE,
        board = "Settlement Board",
    },
    ["Starting Gear"] = {
        center = { x = 7.415189, y = 0.595169, z = 4.248330 },
        size = GEAR_SIZE,
        board = "Settlement Board",
    },
    ["Rare Gear"] = {
        center = { x = 7.415191, y = 0.595169, z = 4.949259 },
        size = GEAR_SIZE,
        board = "Settlement Board",
    },
    ["Promo Gear"] = {
        center = { x = 7.415189, y = 0.595169, z = 5.650189 },
        size = GEAR_SIZE,
        board = "Settlement Board",
    },

    -----------------------------------------------------------------------------

    ["Survivor Box Spawn 1"] = {
        center = { x = -44.900000, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 2"] = {
        center = { x = -34.922222, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 3"] = {
        center = { x = -24.944444, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 4"] = {
        center = { x = -14.966667, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 5"] = {
        center = { x = -4.9888889, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 6"] = {
        center = { x = 4.9888889, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 7"] = {
        center = { x = 14.966667, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 8"] = {
        center = { x = 24.944444, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 9"] = {
        center = { x = 34.922222, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 10"] = {
        center = { x = 44.900000, y = 1.7, z = -61.12 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 11"] = {
        center = { x = -44.900000, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 12"] = {
        center = { x = -34.922222, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 13"] = {
        center = { x = -24.944444, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 14"] = {
        center = { x = -14.966667, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 15"] = {
        center = { x = -4.9888889, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 16"] = {
        center = { x = 4.9888889, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 17"] = {
        center = { x = 14.966667, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 18"] = {
        center = { x = 24.944444, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 19"] = {
        center = { x = 34.922222, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },
    ["Survivor Box Spawn 20"] = {
        center = { x = 44.900000, y = 1.7, z = -67.3 },
        size = { x = 6, y = 5, z = 6 },
    },

    ["Reference 1"] = {
        center = { x = 75.894806, y = 1.730176, z = -65.893570 },
        size = REFERENCE_SIZE,
    },
    ["Reference 2"] = {
        center = { x = 96.894814, y = 1.730182, z = -65.893570 },
        size = REFERENCE_SIZE,
    },
    ["Reference 3"] = {
        center = { x = 75.894806, y = 1.730211, z = -82.679756 },
        size = REFERENCE_SIZE,
    },
    ["Reference 4"] = {
        center = { x = 96.894806, y = 1.730218, z = -82.679756 },
        size = REFERENCE_SIZE,
    },
    ["Reference 5"] = {
        center = { x = 117.894814, y = 1.730189, z = -65.893570 },
        size = REFERENCE_SIZE,
    },

    -----------------------------------------------------------------------------

    ["Campaign Orb"] = {
        p1 = { x =  0.339170, y = 0.15, z = -0.166400 },
        p2 = { x = -0.342977, y = 0.15, z =  0.515850 },
        board = "Export/Import Board",
    },

    -----------------------------------------------------------------------------
    -- Temporary hacks until we get art locations for these
    ["Settlement Events"] = {
        center = { x = -14.360849, y = 10.801341, z = -4.955215 },
        size = SETTLEMENT_EVENT_SIZE,
        board = "Showdown Board",
    },
    ["Drawn Settlement Events"] = {
        center = { x = -13.125675, y = 10.801341, z = -4.955215 },
        size = SETTLEMENT_EVENT_SIZE,
        board = "Showdown Board",
    },
    ["Settlement Locations"] = {
        center = { x = -10.137783, y = -0.039099, z = 4.920703 },
        size = SETTLEMENT_LOCATION_SIZE,
        board = "Settlement Board",
    }
}

-----------------------------------------------------------------------------------------------
-- Showdown board grid locations

local MAX_SHOWDOWN_GRID_COLS = 22
local MAX_SHOWDOWN_GRID_ROWS = 16

local gridLeft   = 6.0804635
local gridRight  = -5.735014
local gridTop    = -2.8629885
local gridBottom =  5.5242755
local y = 10.741001
local cellWidth  = (gridRight - gridLeft) / (MAX_SHOWDOWN_GRID_COLS - 1)
local cellHeight = (gridBottom - gridTop) / (MAX_SHOWDOWN_GRID_ROWS - 1)
local size = { x = cellWidth, y = cellWidth, z = cellHeight }
for col = 1, 22 do
    for row = 1, 16 do
        local x = gridLeft + ((col - 1) * cellWidth)
        local xHalf = x + (cellWidth / 2)
        local z = gridTop + ((row - 1) * cellHeight)
        local zHalf = z + (cellHeight / 2)
        locationData[string.format("(%d, %d)", col, row)] = {
            center = { x = x, y = y, z = z },
            size = size,
            board = "Showdown Board",
        }
        locationData[string.format("(%d, %d.5)", col, row)] = {
            center = { x = x, y = y, z = zHalf },
            size = size,
            board = "Showdown Board",
        }
        locationData[string.format("(%d.5, %d)", col, row)] = {
            center = { x = xHalf, y = y, z = z },
            size = size,
            board = "Showdown Board",
        }
        locationData[string.format("(%d.5, %d.5)", col, row)] = {
            center = { x = xHalf, y = y, z = zHalf },
            size = size,
            board = "Showdown Board",
        }
    end
end

-----------------------------------------------------------------------------------------------

local locationGrids = {
    {
        name = "Innovation",
        cols = 18, rows = 2,
        topLeft     = { x = 7.414137, y = 0.602996, z = -6.384946 },
        bottomRight = { x = -7.412908, y = 0.602996, z = -5.344013 },
    },
    {
        name = "Weapon Mastery",
        cols = 12, rows = 1,
        topLeft     = { x = 4.794536, y = 0.602996, z = -4.306177 },
        bottomRight = { x = -4.799514, y = 0.602996, z = -4.306177 },
    },
    {
        name = "Settlement Gear",
        cols = 18, rows = 2,
        topLeft     = { x = 7.414486, y = 0.602996, z = -2.825781 },
        bottomRight = { x = -7.415930, y = 0.602996, z = -2.123120 },
    },
    {
        name = "Settlement Resource",
        cols = 18, rows = 3,
        topLeft     = { x = 7.410852, y = 0.602996, z = -1.253595 },
        bottomRight = { x = -7.411582, y = 0.602996, z = 0.829436 },
    },
    {
        name = "Settlement Location",
        cols = 10, rows = 2,
        topLeft     = { x = 6.054009, y = 0.595169, z = 3.801595 },
        bottomRight = { x = -7.115391, y = 0.595169, z = 6.102203 },
    },
    {
        name = "Settlement Location Gear",
        cols = 10, rows = 2,
        topLeft     = { x = 6.150475, y = 0.595169, z = 2.302748 },
        bottomRight = { x = -7.021307, y = 0.595168, z = 7.602671 },
    },
}

for _, locationGrid in ipairs(locationGrids) do
    local cols, rows = locationGrid.cols, locationGrid.rows
    local tl, br = locationGrid.topLeft, locationGrid.bottomRight

    local dx = (cols > 1) and ((br.x - tl.x) / (cols - 1)) or 0
    local dz = (rows > 1) and ((br.z - tl.z) / (rows - 1)) or 0
    local locationList = {}
    for col = 1, cols do
        for row = 1, rows do
            local i = (row - 1) * cols + col
            local name = locationGrid.name.." "..i
            locationData[name] = {
                center = {
                    x = tl.x + (col - 1) * dx,
                    y = tl.y,
                    z = tl.z + (row - 1) * dz,
                },
                size = CARD_SIZE,
                board = "Settlement Board",
            }
        end
    end
end

-----------------------------------------------------------------------------------------------
-- Player board locations

for playerNumber = 1, 4 do
    local prefix = "Player "..playerNumber
    local playerBoard = prefix.." Board"

    locationData[playerBoard] = {
        p1 = { x =  1, y = 0.15, z = -1 },
        p2 = { x = -1, y = 0.15, z =  1 },
        board = playerBoard,
    }

    locationData[prefix.." Survival Tokens"] = {
        p1 = { x = 0.933703, y = 0.048755, z = -0.973658 },
        p2 = { x = 0.682291, y = 0.123307, z = -0.451157 },
        board = playerBoard,
    }

    local survivalTokenPositions = {
        { x = 0.850232, y = 0.15, z = -0.891268 },
        { x = 0.761600, y = 0.15, z = -0.802621 },
        { x = 0.850232, y = 0.15, z = -0.714050 },
        { x = 0.761599, y = 0.15, z = -0.625594 },
        { x = 0.850232, y = 0.15, z = -0.536831 },
    }
    for i, pos in ipairs(survivalTokenPositions) do
        locationData[string.format("%s Survival Token %d", prefix, i)] = {
            center = pos,
            size = SURVIVAL_TOKEN_SIZE,
            board = playerBoard,
        }
    end

    locationData[prefix.." Marker"] = {
        fromObject = prefix.." Marker"
    }

    -- includes armor set as well
    locationData[prefix.." Gear"] = {
        p1 = { x = -0.118880, y = 0.15, z = -0.684474 },
        p2 = { x = -0.975374, y = 0.15, z = -0.05188 },
        board = playerBoard,
    }

    locationData[prefix.." Armor Set"] = {
        p1 = { x = -0.118880, y = 0.15, z = -0.582369 },
        p2 = { x = -0.324753, y = 0.15, z = -0.267203 },
        board = playerBoard,
    }

    local left1 = -0.340440
    local top1 = -0.684474
    local right1 = -0.541104
    local bottom1 = -0.484544
    local left9 = -0.774710
    local top9 = -0.251810
    local width = right1 - left1
    local height = bottom1 - top1
    local dx = (left9 - left1) / 2
    local dz = (top9 - top1) / 2
    for col = 1, 3 do
        for row = 1, 3 do
            local x = left1 + ((col - 1) * dx)
            local z = top1 + ((row - 1) * dz)
            local index = ((row - 1) * 3) + col
            locationData[prefix.." Gear "..index] = {
                p1 = { x = x,         y = 0.15, z = z },
                p2 = { x = x + width, y = 0.15, z = z + height },
                board = playerBoard,
            }
        end
    end

    locationData[prefix.." Fist & Tooth"] = {
        p1 = { x = -0.121898, y = 0.15, z = -0.251264 },
        p2 = { x = -0.324531, y = 0.15, z = -0.047824 },
        board = playerBoard,
    }

    locationData[prefix.." Cards"] = {
        p1 = { x = 0.965569, y = 0.15, z = 0.034588 },
        p2 = { x = -0.978594, y = 0.15, z = 0.611414 },
        board = playerBoard,
    }

    local cards = {
        { "Fighting Art 1", "Fighting Art 2", "Fighting Art 3", "Weapon Proficiency",   "Ability/Impairment 1", "Ability/Impairment 2", "Ability/Impairment 3", "Ability/Impairment 4",  "Ability/Impairment 5"  },
        { "Disorder 1",     "Disorder 2",     "Disorder 3",     "Ability/Impairment 6", "Ability/Impairment 7", "Ability/Impairment 8", "Ability/Impairment 9", "Ability/Impairment 10", "Ability/Impairment 11" },
    }

    local left1 = 0.965569
    local top1 = -0.034588
    local right1 = 0.763898
    local bottom1 = 0.281171
    local left18 = -0.776778
    local top18 = 0.296603
    local width = right1 - left1
    local height = bottom1 - top1
    local dx = (left18 - left1) / 8
    local dz = top18 - top1
    for col = 1, 9 do
        local x = left1 + ((col - 1) * dx)
        for row = 1, 2 do
            local z = top1 + ((row - 1) * dz)
            locationData[prefix.." "..cards[row][col]] = {
                p1 = { x = x,         y = 0.15, z = z },
                p2 = { x = x + width, y = 0.15, z = z + height },
                board = playerBoard,
            }
        end
    end

    locationData[prefix.." Temporary Tokens"] = {
        p1 = { x = 0.874169, y = 0.15, z = 0.756863 },
        p2 = { x = 0.118669, y = 0.15, z = 0.974659 },

        board = playerBoard,
    }

    locationData[prefix.." Permanent Tokens"] = {
        p1 = { x = -0.122188, y = 0.15, z = 0.762676 },
        p2 = { x = -0.878822, y = 0.15, z = 0.976487 },

        board = playerBoard,
    }

    locationData[prefix.." Survivor Sheet"] = {
        p1 = { x = 0.621183, y = 0.15, z = -0.996270 },
        p2 = { x = -0.107580, y = 0.15, z = -0.050389 },
        board = playerBoard,
    }

    locationData[prefix.." Status"] = {
        center = { x = 0, y = 0.5, z = -1.220065 },
        size = CARD_SIZE,
        board = playerBoard,
    }

    locationData[prefix.." Monster Controller"] = {
        center = { x = 0.805916, y = 0.5, z = -1.220065 },
        size = CARD_SIZE,
        board = playerBoard,
    }

    locationData[prefix.." Portrait"] = {
        center = { x = -0.802958, y = 0.5, z = -1.220065 },
        size = CARD_SIZE,
        board = playerBoard,
    }

    locationData[prefix.." Bingo"] = {
        center = { x = 0.302958, y = 0.5, z = -1.220065 },
        size = CARD_SIZE,
        board = playerBoard,
    }

    locationData[prefix.." Upper"] = {
        p1 = { x = -1, y = 0.5, z = -1 },
        p2 = { x = 1, y = 0.5, z = -1.45 },
        board = playerBoard,
    }
end

return locationData

end)
__bundle_register("Kdm/Util/CircularArray", function(require, _LOADED, __bundle_register, __bundle_modules)
local CircularArrayClass = {}
CircularArrayClass.__index = CircularArrayClass

---------------------------------------------------------------------------------------------------

local function CircularArray_Create(capacity)
    assert(capacity > 0)

    local circularArray = {
        tag = "CircularArray",
        head = 1,
        tail = 1,
        capacity = capacity,
        array = {}
    }
    setmetatable(circularArray, CircularArrayClass)
    return circularArray
end

---------------------------------------------------------------------------------------------------

function CircularArrayClass.Size(ca)
    if ca.head >= ca.tail then
        return (ca.head - ca.tail)
    else
        return(ca.tail - ca.head)
    end
end

---------------------------------------------------------------------------------------------------

function CircularArrayClass.Top(ca)
    assert(ca.head != ca.tail, "Circular array is empty")
    if ca.head > 1 then
        return ca.array[ca.head - 1]
    else
        return ca.array[ca.capacity]
    end
end

---------------------------------------------------------------------------------------------------

function CircularArrayClass.Push(ca, value)
    ca.array[ca.head] = value

    ca.head = ca.head + 1
    if ca.head == ca.capacity then
        ca.head = 1
    end

    if ca.head == ca.tail then
        ca.array[ca.tail] = nil
        ca.tail = ca.tail + 1
        if ca.tail == ca.capacity then
            ca.tail = 1
        end
    end
end

---------------------------------------------------------------------------------------------------

function CircularArrayClass.Pop(ca)
    assert(ca.head != ca.tail, "Circular array is empty")

    ca.head = ca.head - 1
    if ca.head == 0 then
        ca.head = ca.capacity
    end
    ca.array[ca.head] = nil
end

---------------------------------------------------------------------------------------------------

return CircularArray_Create

end)
__bundle_register("Kdm/Archive", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Archive")
local NamedObject = require("Kdm/NamedObject")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Archive = {}

Archive.data = {
    { "Abilities", "Abilities", "Abilities Archive" },
    { "Fighting Arts", "Fighting Arts", "Fighting Arts Archive" },
    { "Secret Fighting Arts", "Secret Fighting Arts", "Secret Fighting Arts Archive" },
    { "Disorders", "Disorders", "Disorders Archive" },
    { "Severe Injuries", "Severe Injuries", "Severe Injuries Archive" },
    { "Tactics", "Tactics", "Tactics Archive" },
    { "Weapon Proficiencies", "Weapon Proficiencies", "Weapon Proficiencies Archive" },
    { "Armor Sets", "Armor Sets", "Armor Sets Archive" },
    { "Vermin", "Vermin", "Vermin Archive" },
    { "Strange Resources", "Strange Resources", "Strange Resources Archive" },
    { "Basic Resources", "Basic Resources", "Basic Resources Archive" },
    { "Terrain", "Terrain", "Terrain Archive" },
    { "Terrain Tiles", "Terrain Tiles", "Terrain Tiles Archive" },
    { "Hunt Events", "Hunt Events", "Hunt Events Archive" },
    { "Settlement Events", "Settlement Events", "Settlement Events Archive" },
    { "Rare Gear", "Gear", "Rare Gear Archive" },
    { "All Gear", "Gear", "All Gear Archive" },
    { "Monster Resources", "Monster Resources", "Monster Resources Archive" },
    { "Survivor Sheet", "Survivor Sheet", "Survivor Sheets Archive" },
    { "Survivor Box", "Survivor Box", "Survivor Boxes Archive" },
    { "Dodge Tokens", "Survival Tokens", "Dodge Tokens" },
    { "Encourage Tokens", "Survival Tokens", "Encourage Tokens" },
    { "Embolden Tokens", "Survival Tokens", "Embolden Tokens" },
    { "Dash Tokens", "Survival Tokens", "Dash Tokens" },
    { "Surge Tokens", "Survival Tokens", "Surge Tokens" },
    { "Overcharge Tokens", "Survival Tokens", "Overcharge Tokens" },
    { "Endure Tokens", "Survival Tokens", "Endure Tokens" },
    { "Allister", "Player Figurine", "Allister Archive" },
    { "Ezra", "Player Figurine", "Ezra Archive" },
    { "Lucy", "Player Figurine", "Lucy Archive" },
    { "Zachary", "Player Figurine", "Zachary Archive" },
    { "Patterns", "Patterns", "Patterns Archive"},
}

---------------------------------------------------------------------------------------------------

function Archive.Init()
    Archive.index = {}
    Archive.direct = {}

    -- "Direct" entries are the items directly contained by the infinite container archive, such as the "Disorders" deck in the "Disorders Archive".
    -- For such items we just a flag telling us to take the item directly, no need to search inside it.
    for _, entry in ipairs(Archive.data) do
        local name, type, archive = entry[1], entry[2], entry[3]
        local key = Archive.Key(name, type)
        Archive.index[key] = archive
        Archive.direct[key] = true
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120

    for _, expansion in ipairs(Expansion.All()) do
        Archive.RegisterEntries(expansion.archiveEntries)
    end
end

---------------------------------------------------------------------------------------------------

function Archive.Key(name, type)
    return type.."."..name
end

---------------------------------------------------------------------------------------------------

function Archive.RegisterEntries(params)
    if not params then
        return
    end

    archive = params.archive
    assert(archive)
    for _, entry in ipairs(params.entries) do
        local name, type = entry[1], entry[2]
        assert(name)
        assert(type)
        local key = Archive.Key(name, type)
        if not params.allowOverrides then
            assert(Check(Archive.index[key] == nil, "Archive entry %s/%s for %s is already registered for %s", name, type, archive, Archive.index[key]))
        end
        Archive.index[key] = archive
    end
end

---------------------------------------------------------------------------------------------------

function Archive.NextContainerPosition()
    local position = { x = Archive.containerX, y = 15, z = Archive.containerZ }
    Archive.containerX = Archive.containerX + 10
    if Archive.containerX > 150 then
        Archive.containerX = -150
        Archive.containerZ = Archive.containerZ - 10
        if Archive.containerZ < 70 then
            Archive.containerZ = 120
        end
    end
    return position
end

---------------------------------------------------------------------------------------------------

function Archive.Take(params)
    local archive = params.archive
    local name = params.name
    local type = params.type
    local height = params.height or 2
    local location = params.location
    local position = params.position
    if location then
        location = Location.Get(location)
        position = location:Center()
        position.y = position.y + (height or 2)
    else
        assert(Check.Vec3(position, "Either location or position is required"))
    end
    local rotation = params.rotation or { x = 0, y = 180, z = 0 }
    local spawnFunc = params.spawnFunc
    assert(Check.StrOrNil(archive))
    assert(Check.Str(name))
    assert(Check.Str(type))
    assert(Check.NumOrNil(height))
    assert(Check.Vec3OrNil(rotation))
    assert(Check.FuncOrNil(spawnFunc))

    if not archive then
        local key = Archive.Key(name, type)
        archive = Archive.index[key]
        if not archive then
            log:Errorf("%s (%s) is not in the archive", name, type)
            return nil
        end

        if Archive.direct[key] then
            -- for single item archives no need to pull intermediate container
            log:Debugf("Using direct from archive %s for %s (%s)", archive, name, type)
            return NamedObject.Get(archive).takeObject({
                position = position,
                rotation = rotation,
                smooth = false,
                callback_function = spawnFunc,
            })
        end
    end

    if location then
        log:Debugf("Taking item %s (%s) in archive %s to %s +%f", name, type, archive, location:Name(), height)
    else
        log:Debugf("Taking item %s (%s) in archive %s to %s", name, type, archive, position)
    end

    local container = Archive.containers[archive]
    if container then
        log:Debugf("Re-using already-spawned archive container %s for %s (%s)", container:Guid(), name, type)

    else
        -- spawn new container and cache
        local archiveObject = NamedObject.Get(archive)
        local containerObject = archiveObject.takeObject({
            position = Archive.NextContainerPosition(),
            smooth = false,
        })
        container = Container(containerObject)
        if not container then
            log:Errorf("Couldn't take from archive [%s] %s. If you accidentally reset/cleared it, then you may need to restore an earlier save. If it's one of the deck archives (Disorders, Fighting Arts, etc), you can try reconstructing the deck then dropping it onto the archive box to restore it.", archiveObject.getGUID(), archiveObject.getName())
            Util.Highlight(archiveObject)
            return nil
        end

        --log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", container:Guid(), Archive.containerX, Archive.containerZ, name, type)
        log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", "", Archive.containerX, Archive.containerZ, name, type)

        container:Lock(true)
        Archive.containers[archive] = container
    end

    local object = container:Take({
        name = name,
        type = type,
        position = position,
        rotation = rotation,
        spawnFunc = spawnFunc,
    })
    if not object then
        log:Errorf("Couldn't find %s (%s) in archive %s. If you accidentally reset/cleared it, then you may need to restore an earlier save. If it's one of the deck archives (Disorders, Fighting Arts, etc), you can try reconstructing the deck then dropping it onto the archive box to restore it.", name, type, archive)
        Util.Highlight(NamedObject.Get(archive))
        return nil
    end

    log:Debugf("Spawned object %s (%s)", object.getName(), object.getGUID())

    return object
end

---------------------------------------------------------------------------------------------------

function Archive.ArchiveSource(name, type)
    return {
        source = "Archive",
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.ContainerSource(container, name, type)
    return {
        source = "Container",
        container = container,
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.CreateDeckFromSources(params)
    local sources, location, rotation = params.sources, Location.Get(params.location), params.rotation or { x = 0, y = 180, z = 0 }

    local objects = {}
    local missing = {}
    for i, source in ipairs(sources) do
        local takeParams = { name = source.name, type = source.type, location = location, height = (i - 1) * 0.5, rotation = rotation }
        local object = nil
        if source.source == "Archive" then
            object = Archive.Take(takeParams)
            if not object then
                log:Debugf("Couldn't find '%s' in archive", source.name)
                table.insert(missing, source)
            end
        elseif source.source == "Container" then
            object = source.container:Take(takeParams)
            if not object then
                log:Debugf("Couldn't find '%s' in container [%s] %s", source.name, source.container:Guid(), source.container:Name())
                table.insert(missing, source)
            end
        else
            assert(Check.Fail("Unrecognized source: %s", source))
        end
        if object then
            table.insert(objects, object)
        end
    end

    local deckObject
    if #objects > 1 then
        deckObject = group(objects)[1]
        assert(Check(deckObject))
    else
        log:Debugf("CreateDeck only asked for one object [%s] %s, so not grouping", objects[1].getGUID(), objects[1].getName())
        deckObject = objects[1]
    end

    deckObject.setName(params.name)
    deckObject.setGMNotes(params.type)
    deckObject.setPositionSmooth(location:Center(), false, true)
    deckObject.setRotation(rotation)

    log:Debugf("Created deck [%s] %s at %s", deckObject.getGUID(), deckObject.getName(), location)

    return Container(deckObject), missing
end

---------------------------------------------------------------------------------------------------

function Archive.Clean()
    for _, container in pairs(Archive.containers) do
        log:Debugf("Destroying archive container %s", container:Guid())
        container:Destruct()
    end

    -- scan and clean orphaned containers from a previous error
    local hits = Physics.cast({
        origin    = { x = 0, y = 100, z = 95 },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = 350, y = 50, z = 100 },
    })
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object
        if obj.tag == "Bag" and obj.getGMNotes() == "Archive Bag" then
            log:Debugf("Destroying leftover archive bag %s (%s)", obj.getName(), obj.getGUID())
            obj.destruct()
        end
        if obj.tag == "Deck" then
            local key = Archive.Key(obj.getName(), obj.getGMNotes())
            if Archive.direct[key] then
                log:Debugf("Destroying leftover archive deck %s (%s)", obj.getName(), obj.getGUID())
                obj.destruct()
            end
        end
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120
end

---------------------------------------------------------------------------------------------------

return {
    Init = Archive.Init,
    RegisterEntries = Archive.RegisterEntries,
    Take = Archive.Take,
    ArchiveSource = Archive.ArchiveSource,
    ContainerSource = Archive.ContainerSource,
    CreateDeckFromSources = Archive.CreateDeckFromSources,
    Clean = Archive.Clean,
}

end)
__bundle_register("Kdm/Util/Container", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Container")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Container = {}

Container.TAGS = {
    ["Deck"] = true,
    ["Bag"] = true,
    ["Infinite"] = true,
}

local ContainerClass = {}
ContainerClass.__index = ContainerClass
function ContainerClass.Is(instance) return getmetatable(instance) == ContainerClass end

---------------------------------------------------------------------------------------------------

function Container.Create(object)
    assert(Check.ObjectOrNil(object))

    local container  = {
        tag = "Container",
        object = object,
    }
    setmetatable(container, ContainerClass)

    return container
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Name()
    if self.object == nil then
        return "<self destroyed>"
    end

    return self.object.getName()
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Guid()
    if self.object == nil then
        return "<self destroyed>"
    end

    return self.object.getGUID()
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Object()
    return self.object
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Objects()
    if self.object == nil then
        return {}

    elseif Container.TAGS[self.object.tag] then
        return self.object.getObjects()

    else
        return {
            -- last object
            {
                name = self.object.getName(),
                guid = self.object.getGUID(),
                gm_notes = self.object.getGMNotes(),
            },
        }
    end
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Lock(lock)
    if self.object == nil then
        return log:Debugf("Container object destroyed, nothing to lock")
    end

    self.object.setLock(lock)
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Take(params)
    assert(Check.Table(self))
    assert(self.object != nil, "Container is empty or was destroyed")  -- "!= nil" is important for deleted TTS object comparison

    local guid = params.guid

    local name = params.name
    local type = params.type
    if name then
        assert(Check(type, "Name '%s' provided, but no type", name))
    end

    assert(Check(not guid or not name, "Can't have both guid (%s) and name (%s)", guid, name))

    local location = params.location
    local position = params.position
    if location then
        location = Location.Get(location)
        position = location:Center()
        position.y = position.y + (params.height or 2)
    else
        assert(position, "Either location or position is required")
    end

    local spawnFunc = params.spawnFunc
    local rotation = params.rotation or { x = 0, y = 180, z = 0 }

    log:Debugf("Taking %s/%s from self [%s] %s to (%f, %f, %f)", name or "<top>", type or "<???>", self.object.getGUID(), self.object.getName(), position.x, position.y, position.z)

    if not Container.TAGS[self.object.tag] then
        local lastObject = self.object
        if name then
            assert(Check(lastObject.getName() == name and lastObject.getGMNotes() == type, "Couldn't take %s/%s from self; last remaining object is %s/%s", name, type, lastObject.getName(), lastObject.getGMNotes()))
        end

        lastObject.setPositionSmooth(position, false, true)
        lastObject.setRotation(rotation)
        log:Debugf("Took last object [%s] %s", lastObject.getName(), lastObject.getGUID())

        self.object = nil

        if params.spawnFunc then
            params.spawnFunc(lastObject)
        end
        return lastObject
    end

    if name then
        assert(guid == nil)
        for _, entry in ipairs(self.object.getObjects()) do
            if entry.name == name and entry.gm_notes == type then
                guid = entry.guid
                break
            end
        end
        if not guid then
            log:Debugf("%s/%s not found in self [%s] %s", name, type, self.object.getGUID(), self.object.getName())
            return nil
        end
    end

    local object = self.object.takeObject({
        guid = guid,
        position = position,
        rotation = rotation,
        smooth = false,
        callback_function = params.spawnFunc,
    })
    assert(Check(object, "Couldn't take %s/%s from self [%s] %s", name or "<top>", type or "<???>", self.object.getGUID(), self.object.getName()))
    log:Debugf("Took [%s] %s from self [%s] %s", object.getName(), object.getGUID(), self.object.getGUID(), self.object.getName())

    if self.object.remainder then
        self.object = self.object.remainder
        log:Debugf("Container has only one object remaining, switching to [%s] %s", self.object.getGUID(), self.object.getName())
    end

    return object
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Shuffle()
    if Container.TAGS[self.object.tag] then
        self.object.Shuffle()
    end
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Delete(names)
    if #names == 0 then
        return
    end

    log:Debugf("Deleting %d objects from [%s] %s", #names, self.object.getGUID(), self.object.getName())


    local index = nil
    if Container.TAGS[self.object.tag] then
        index = Util.MultiIndex(self.object.getObjects(), "name")
    end

    for i, name in ipairs(names) do
        -- Single card
        if not Container.TAGS[self.object.tag] then
            assert(Check(i == #names))

            local lastObject = self.object
            assert(Check(lastObject.getName() == name, "Couldn't delete %s from self; last remaining object is %s", name, lastObject.getName()))

            log:Debugf("Deleted last object [%s] %s", lastObject.getName(), lastObject.getGUID())
            lastObject.destruct()
            self.object = nil

        -- Legit self (still possible with only one object)
        else
            assert(Check(index[name] and #index[name] >= 1, "%s not found in [%s] %s", name, self.object.getGUID(), self.object.getName()))
            local entry = table.remove(index[name])
            self.object.takeObject({
                guid = entry.guid,
                position = { x = -150, y = -100, z = 150 },
                smooth = false,
            }).destruct()

            log:Debugf("Deleted %s from self [%s] %s", name, self.object.getGUID(), self.object.getName())

            if self.object.remainder then
                self.object = self.object.remainder
                log:Debugf("Container has only one object remaining, switching to [%s] %s", self.object.getGUID(), self.object.getName())
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function ContainerClass:OrderDeck(top, bottom)
    assert(Check(self.object.tag == "Deck"))

    log:Debugf("Reordering [%s] %s with top=%s and bottom=%s", self.object.getGUID(), self.object.getName(), top, bottom)

    local data = self.object.getData()
    local oldSequence = data.ContainedObjects

    local index = {}
    for i, elem in ipairs(oldSequence) do
        if not index[elem.Nickname] then
            index[elem.Nickname] = { i }
        else
            table.insert(index[elem.Nickname], i)
        end
    end

    local newSequence = {}
    for _, card in ipairs(top or {}) do
        local t = index[card]
        assert(Check(t and #t > 0, "Deck [%s] %s doesn't have card %s", self.object.getGUID(), self.object.getName(), card))
        local i = t[#t]
        table.insert(newSequence, oldSequence[i])
        oldSequence[i] = "-"
        table.remove(t)
    end

    local newBottom = {}
    for _, card in ipairs(bottom or {}) do
        local t = index[card]
        assert(Check(t and #t > 0, "Deck [%s] %s doesn't have card %s", self.object.getGUID(), self.object.getName(), card))
        local i = t[#t]
        table.insert(newBottom, oldSequence[i])
        oldSequence[i] = "-"
        table.remove(t)
    end

    for _, elem in ipairs(oldSequence) do
        if elem != "-" then
            table.insert(newSequence, elem)
        end
    end

    for i = #newBottom, 1, -1 do
        table.insert(newSequence, newBottom[i])
    end

    data.DeckIDs = {}
    for _, elem in ipairs(newSequence) do
        table.insert(data.DeckIDs, elem.CardID)
    end
    data.ContainedObjects = newSequence

    self.object.destruct()
    local newObject = spawnObjectData({ data = data })
    log:Debugf("Reordered and respawned deck [%s] %s", newObject.getName(), newObject.getGUID())
    self.object = newObject
end

---------------------------------------------------------------------------------------------------

function ContainerClass:Destruct()
    if self.object then
        log:Debugf("Destroying conbtainer [%s] %s", self.object.getGUID(), self.object.getName())
        self.object.destruct()
        self.object = nil
    else
        log:Debugf("Cannot destroy self: already empty/destroyed")
    end
end

---------------------------------------------------------------------------------------------------

return Container.Create

end)
__bundle_register("Kdm/Player", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Armor = require("Kdm/Armor")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Player")
local NamedObject = require("Kdm/NamedObject")
local Survivor = require("Kdm/Survivor")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")
local Weapon = require("Kdm/Weapon")

---------------------------------------------------------------------------------------------------

local Player = {}
Player.__index = Player
function Player.Is(x) return getmetatable(x) == Player end

Player.HIT_LOCATIONS = { "head", "arms", "body", "waist", "legs" }

Player.TOKENS = {
    ["Movement Token"] = true,
    ["Speed Token"] = true,
    ["Accuracy Token"] = true,
    ["Strength Token"] = true,
    ["Evasion Token"] = true,
    ["Luck Token"] = true,
    ["Bleeding Token"] = true,
    ["Lunacy Token"] = true,
    ["Reroll Token"] = true,
}

Player.TOKEN_STATS = {
    ["Movement Token"] = "movement",
    ["Speed Token"] = "speed",
    ["Accuracy Token"] = "accuracy",
    ["Strength Token"] = "strength",
    ["Evasion Token"] = "evasion",
    ["Luck Token"] = "luck",
    ["Lunacy Token"] = "frenzy",
}

---------------------------------------------------------------------------------------------------

function Player.Init(saveState)
    Player.players = {}
    for ordinal = 1, 4 do
        Player.players[ordinal] = Player.Create(ordinal, saveState[ordinal] or {})
    end
end

---------------------------------------------------------------------------------------------------

function Player.PostInit()
    for _, player in ipairs(Player.players) do
        player:UpdateGear()
        player:UpdateStats()
    end

    EventManager.AddHandler("onObjectCollisionEnter", Player.OnObjectCollisionEnter)
    EventManager.AddHandler("onObjectEnterContainer", Player.OnObjectEnterContainer)
    EventManager.AddHandler("onObjectDestroy", Player.OnObjectDestroy)
    EventManager.AddHandler(EventManager.ON_SURVIVOR_STAT_CHANGED, Player.OnSurvivorChangeStat)
    EventManager.AddHandler(EventManager.ON_PLAYER_COLOR_CHANGED, Player.OnPlayerColorChanged)

    Wait.time(function()
        for ordinal, player in ipairs(Player.players) do
            local playerMarker = NamedObject.Get("Player "..ordinal.." Marker")
            if playerMarker then
                local colorTable = playerMarker.getColorTint()
                local colorStr = "#"..Color(colorTable):toHex()
                EventManager.FireEvent(EventManager.ON_PLAYER_COLOR_CHANGED, player, colorTable, colorStr)
            end
        end
    end, 2, -1)
end

---------------------------------------------------------------------------------------------------

function Player.Save()
    local saveState = {}
    for i, player in ipairs(Player.players) do
        local playerSaveState = {}

        if player.survivorSheet then
            playerSaveState.survivorSheetGuid = player.survivorSheet:Object().getGUID()
        end

        if player.figurineObject then
            playerSaveState.figurineGuid = player.figurineObject.getGUID()
        end

        playerSaveState.temporaryArmor = player.temporaryArmor
--        playerSaveState.injuries = player.injuries
        playerSaveState.lightInjuries = player.lightInjuries
        playerSaveState.heavyInjuries = player.heavyInjuries

        table.insert(saveState, playerSaveState)
    end
    return saveState
end

---------------------------------------------------------------------------------------------------

function Player.ForFigurine(figurineObject)
    for _, player in ipairs(Player.players) do
        if player.figurineObject == figurineObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.ForPortrait(portraitObject)
    for _, player in ipairs(Player.players) do
        if player.portraitObject == portraitObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.ForBingo(bingoObject)
    for _, player in ipairs(Player.players) do
        if player.bingoObject == bingoObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectCollisionEnter(object, collisionInfo)
    -- This is a hack to detect flipped tokens
    -- There's no onFlip event, and flipping doesn't trigger onPickUp, so we rely on this to detect flips
    -- of *already registered* tokens.

    local collisionObject = collisionInfo.collision_object

    local player = nil
    for _, p in ipairs(Player.players) do
        if p.boardObject == collisionObject then
            player = p
            break
        end
    end
    if not player then
        return
    end

    log:Debugf("[%s]%s collided with [%s]%s", object.getGUID(), object.getName(), collisionObject.getGUID(), collisionObject.getName())

    local playerPrefix = "Player "..player.ordinal
    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    local gearLocation = Location.Get(playerPrefix.." Gear")

    for _, location in ipairs(Location.ObjectLocations(object)) do
        if location == temporaryTokensLocation or location == permanentTokensLocation then
            log:Debugf("Token [%s]%s found in %s, updating stats", object.getGUID(), object.getName(), location)
            player:UpdateStats()
            break
        elseif location == gearLocation then
            log:Debugf("Token [%s]%s found in %s, updating gear", object.getGUID(), object.getName(), location)
            player:UpdateGear()
            player:UpdateStats()
            break
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectEnterContainer(container, object)
    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
    local player2 = Player.ForPortrait(object)
    if player2 then
        player2.survivorSheet:Survivor().SetPortraitJSON(object.getJSON())
        player2:UnlinkPortrait(object)
    end
    local player3 = Player.ForBingo(object)
    if player3 then
        player3.survivorSheet:Survivor().SetBingoJSON(object.getJSON())
        player3:UnlinkBingo(object)
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectDestroy(object)
    for _, player in ipairs(Player.players) do
        if player.survivorSheet and player.survivorSheet:Object() == object then
            player:UnlinkSurvivorSheet()
            break
        end
    end

    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
    local player2 = Player.ForPortrait(object)
    if player2 then
        player2.survivorSheet:Survivor().SetPortraitJSON(object.getJSON())
        player2:UnlinkPortrait(object)
    end
    local player3 = Player.ForBingo(object)
    if player3 then
        player3.survivorSheet:Survivor().SetBingoJSON(object.getJSON())
        player3:UnlinkBingo(object)
    end    
end

---------------------------------------------------------------------------------------------------

function Player.OnSurvivorChangeStat(survivor, stat, value)
    if stat == "name" then
        for _, player in ipairs(Player.players) do
            if player.survivorSheet and player.survivorSheet:Survivor() == survivor then
                if player.figurineObject then
                    log:Debugf("Updating figurine [%s] name for %s to %s", player.figurineObject.getGUID(), player, value)
                    player.figurineObject.setName(value)
                end
                if player.portraitObject then
                    log:Debugf("Updating portrait [%s] name for %s to %s", player.figurineObject.getGUID(), player, value)
                    player.portraitObject.setName(value)
                end
                if player.bingoObject then
                    log:Debugf("Updating bingo card [%s] name for %s to %s", player.bingoObject.getGUID(), player, value)
                    player.bingoObject.setName(value .. "'s Bingo")
                end
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnPlayerColorChanged(player, colorTable, colorStr)
    if player.figurineObject then
        player.figurineObject.setColorTint(colorTable)
    end
--    if player.portraitObject then
--        player.portraitObject.setColorTint(colorTable)
--    end
    if player.bingoObject then
        player.bingoObject.editButton({
            index = 24,
            color = colorTable,
        })
        player.bingoObject.call("onSave")
    end
end

---------------------------------------------------------------------------------------------------

function Player.Create(ordinal, params)
    local playerPrefix = "Player "..ordinal

    local player = {
        tag = "Player",
        ordinal = ordinal,
        boardObject = NamedObject.Get(playerPrefix.." Board"),
        markerObject = NamedObject.Get(playerPrefix.." Marker"),
        weapons = {},   -- purely a concession to make BattleUi updates easier
    }
    setmetatable(player, Player)

    local playerPrefix = "Player "..player.ordinal

    if params.survivorSheetGuid then
        local survivorSheetObject = getObjectFromGUID(params.survivorSheetGuid)
        if survivorSheetObject == nil then  -- compare nil for TTS objects
            log:Errorf("Can't find survivor sheet %s that %d was linked to! Try recreating the it from the Population screen and dropping it back onto the player board.", params.linkedSurvivorSheetGuid, ordinal)
        else
            player.survivorSheet = Survivor.SurvivorSheetForObject(survivorSheetObject)
            if not player.survivorSheet then
                log:Errorf("Survivor sheet %s on player board %d wasn't linked to any survivor.", survivorSheetObject.getGUID(), ordinal)
            else
                log:Debugf("Linked %s to %s", player.survivorSheet, player)
            end
        end
    end

    if params.figurineGuid then
        figurineObject = getObjectFromGUID(params.figurineGuid)
        if not figurineObject then
            log:Errorf("Player %s was linked to figurine %s, but that object was deleted.", ordinal, params.figurineGuid)
        else
            player:LinkFigurine(figurineObject)
        end
    end

    player.temporaryArmor = {}
    player.lightInjuries = {}
    player.heavyInjuries = {}
    local paramsTemporaryArmor = params.temporaryArmor or {}
    local paramsLightInjuries = params.lightInjuries or {}
    local paramsHeavyInjuries = params.heavyInjuries or {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        player.temporaryArmor[hitLocation] = paramsTemporaryArmor[hitLocation] or 0
        player.lightInjuries[hitLocation] = paramsLightInjuries[hitLocation]
        player.heavyInjuries[hitLocation] = paramsHeavyInjuries[hitLocation]
    end

    player.gear = {}
    local playerGearPrefix = playerPrefix.." Gear "
    for i = 1, 9 do
        player.gear[Location.Get(playerGearPrefix..i)] = {
            weapon = nil,
            armor = nil,
            tokens = {},
        }
    end
    player.gear[Location.Get(playerPrefix.." Fist & Tooth")] = {
        weapon = nil,
        armor = nil,
        tokens = {},
    }

    player:InitUi()

    local playerPrefix = "Player "..player.ordinal

    Location.Get(playerPrefix.." Survivor Sheet"):AddDropHandler(function(object)
        player:OnObjectDroppedOnSurvivorSheet(object)
    end)

    Location.Get(playerPrefix.." Marker"):AddDropHandler(function(object)
        local type = object.getGMNotes()
        if type == "Player Figurine" then
            player:LinkFigurine(object)
        end
        if type == "Portrait" then
            player:LinkPortrait(object)
        end
        if type == "Bingo Card" then
            player:LinkBingo(object)
        end
    end)

    local checkUnregisterCollisions = function(object)
        if object and object.getGMNotes() == "Tokens" and Player.TOKEN_STATS[object.getName()] then
            log:Debugf("Unregistering token [%s]%s for collisions", object.getGUID(), object.getName())
            object.unregisterCollisions()
        end
    end

    local gearLocation = Location.Get(playerPrefix.." Gear")
    gearLocation:AddDropHandler(function(object, location)
        player:UpdateGear(object)
    end)
    gearLocation:AddPickUpHandler(function(object, location)
        checkUnregisterCollisions(object)
        player:UpdateGear(object)
    end)

    local cardsLocation = Location.Get(playerPrefix.." Cards")
    cardsLocation:AddDropHandler(function(object)
        player:UpdateCards()
    end)
    cardsLocation:AddPickUpHandler(function(object)
        player:UpdateCards()
    end)

    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    temporaryTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    temporaryTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    permanentTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    permanentTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    return player
end

---------------------------------------------------------------------------------------------------

function Player.InitUi(player)
    local ui = Ui.Create3d("Player"..player.ordinal, player.boardObject, 0.11)
    player.ui = ui

    local x1 = -0.120503
    local y1 = -0.971472
    local x2 = -0.257252
    local y2 = -0.838162
    local xn = -0.842982
    local width = x2 - x1
    local dx = (xn - x1) / 4
    player.armorCounters = {}
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.armorCounters[hitLocation] = ui:Counter({ id = hitLocation.."Armor", topLeft = topLeft, bottomRight = bottomRight, fontSize = 95, onValueChanged = function(delta)
            player.temporaryArmor[hitLocation] = player.temporaryArmor[hitLocation] + delta
            player:UpdateGear()
        end })
    end

    player.lightInjuryCheckBoxes = {}
    local x1 = -0.314098
    local y1 = -0.775458
    local x2 = -0.363223
    local y2 = -0.723353
    local xn = -0.855320
    local width = x2 - x1
    local dx = (xn - x1) / 3
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.lightInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."LightInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.lightInjuries[hitLocation], onClick = function()
            local value = not player.lightInjuries[hitLocation]
            player.lightInjuries[hitLocation] = value
            player.lightInjuryCheckBoxes[hitLocation]:Check(value)
        end })
    end

    local x1 = -0.166245
    player.heavyInjuryCheckBoxes = {}
    player.heavyInjuryCheckBoxes.head = ui:CheckBox({ id = "headHeavyInjury", topLeft = { x = x1, y = y1 }, bottomRight = { x = x1 + width, y = y2 }, checked = player.heavyInjuries.head, onClick = function()
        local value = not player.heavyInjuries.head
        player.heavyInjuries.head = value
        player.heavyInjuryCheckBoxes.head:Check(value)
    end })
    local x1 = -0.376100
    local xn = -0.918347
    local dx = (xn - x1) / 3
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
         local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.heavyInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."HeavyInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.heavyInjuries[hitLocation], onClick = function()
            local value = not player.heavyInjuries[hitLocation]
            player.heavyInjuries[hitLocation] = value
            player.heavyInjuryCheckBoxes[hitLocation]:Check(value)
        end })
    end

    ui:Button({ id = "healAndReset", topLeft = { x = -0.124014, y = -0.687478 }, bottomRight = { x = -0.323673, y = -0.596463 }, onClick = function()
        player:HealAndReset()
    end })

    ui:Button({ id = "backToSettlement", topLeft = { x = 0.910594, y = -0.139250 }, bottomRight = { x = 0.707226, y = -0.048424 }, onClick = function()
        player:BackToSettlement()
    end })

    ui:ApplyToObject()

    return player
end

---------------------------------------------------------------------------------------------------

function Player:__tostring()
    return Util.SafeFormat("Player{ordinal=%s}", self.ordinal)
end

---------------------------------------------------------------------------------------------------

function Player:Ordinal() return self.ordinal end
function Player:SurvivorSheet() return self.survivorSheet end

---------------------------------------------------------------------------------------------------

function Player:UpdateGear()
    local weaponsAndModifiers = {}

    local armorTotals = {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        armorTotals[hitLocation] = self.temporaryArmor[hitLocation]
    end

    local playerPrefix = "Player "..self.ordinal
    for _, location in ipairs({
        playerPrefix.." Gear 1",
        playerPrefix.." Gear 2",
        playerPrefix.." Gear 3",
        playerPrefix.." Gear 4",
        playerPrefix.." Gear 5",
        playerPrefix.." Gear 6",
        playerPrefix.." Gear 7",
        playerPrefix.." Gear 8",
        playerPrefix.." Gear 9",
        playerPrefix.." Fist & Tooth",
        playerPrefix.." Armor Set",
    }) do
        local weaponAndModifiers = {
            weapon = nil,
            modifiers = {},
        }

        for _, object in ipairs(Location.Get(location):AllObjects()) do
            local objectName = object.GetName()
            if object.tag == "Card" then
                local armor = Armor.Get(objectName)
                if armor then
                    log:Debugf("Adding armor %s at %s", objectName, location)
                    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
                        armorTotals[hitLocation] = armorTotals[hitLocation] + armor[hitLocation]
                    end
                end

                local weapon = Weapon.Get(objectName)
                if weapon then
                    log:Debugf("Adding weapon %s at %s", objectName, location)
                    weaponAndModifiers.weapon = weapon
                end
            else
                local stat = Player.TOKEN_STATS[objectName]
                if stat then
                    log:Debugf("Adding token %s for weapon at %s", objectName, location)
                    weaponAndModifiers.modifiers[stat] = (weaponAndModifiers.modifiers[stat] or 0) + Util.TokenValue(object)
                    object.registerCollisions()
                end
            end
        end

        if weaponAndModifiers.weapon then
            table.insert(weaponsAndModifiers, weaponAndModifiers)
        end
    end

    log:Debugf("Final %s weapons: %s", self, Util.TabStr(weapons))
    log:Debugf("Final %s armor: %s", self, Util.TabStr(armorTotals))

    self.weaponsAndModifiers = weaponsAndModifiers    -- purely a concession to make BattleUi updates easier

    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.armorCounters[hitLocation]:SetText(armorTotals[hitLocation])
    end

    EventManager.FireEvent(EventManager.ON_PLAYER_WEAPONS_CHANGED, self, weapons)
end

function Player:WeaponsAndModifiers() return self.weaponsAndModifiers end

---------------------------------------------------------------------------------------------------

function Player:UpdateCards()
    if not self.survivorSheet then
        return
    end

    log:Debugf("Updating %s cards", self)

    local cards = {}
    local positionsByCardNameType = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            for _, card in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[card.gm_notes] then
                    table.insert(cards, {
                        name = card.name,
                        type = card.gm_notes,
                    })

                    local nameType = (card.name or "")..card.gm_notes
                    local worldPosition = container:Object().getPosition()
                    local localPosition = self.boardObject.positionToLocal(worldPosition)
                    log:Debugf("Found card %s at world (%f, %f %f), local (%f, %f, %f)", card.name, worldPosition.x, worldPosition.y, worldPosition.z, localPosition.x, localPosition.y, localPosition.z)
                    if positionsByCardNameType[nameType] then
                        table.insert(positionsByCardNameType[nameType], localPosition)
                    else
                        positionsByCardNameType[nameType] = { localPosition }
                    end
                end
            end
        end
    end

    self.survivorSheet:Survivor():SetCards(cards)
    self.survivorSheet:Survivor():SetPositionsByCardNameType(positionsByCardNameType)
end

---------------------------------------------------------------------------------------------------

function Player:UpdateStats()
    if not self.survivorSheet then
        return
    end

    local modifiers = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found temporary token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Permanent Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found permanent token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    local playerPrefix = "Player "..self.ordinal
    for _, location in ipairs({
        playerPrefix.." Gear 1",
        playerPrefix.." Gear 2",
        playerPrefix.." Gear 3",
        playerPrefix.." Gear 4",
        playerPrefix.." Gear 5",
        playerPrefix.." Gear 6",
        playerPrefix.." Gear 7",
        playerPrefix.." Gear 8",
        playerPrefix.." Gear 9",
        playerPrefix.." Fist & Tooth",
        playerPrefix.." Armor Set",
    }) do

        for _, object in ipairs(Location.Get(location):AllObjects()) do
            if object.tag != "Card" then
                local stat = Player.TOKEN_STATS[object.getName()]
                if stat == "evasion" then
                    local value = Util.TokenValue(object)
                    log:Debugf("Adding token %s from gear at %s", object.getName(), location)
                    modifiers[stat] = (modifiers[stat] or 0) + value
                    object.registerCollisions()
                end
            end
        end
    end

    self.survivorSheet:Survivor():SetModifiers(modifiers)
end

---------------------------------------------------------------------------------------------------

function Player:HealAndReset()
    -- Clear temporary armor
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.temporaryArmor[hitLocation] = 0
    end
    self:UpdateGear()

    -- Clear injuries
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
        self.lightInjuries[hitLocation] = nil
        self.lightInjuryCheckBoxes[hitLocation]:Check(nil)
    end
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.heavyInjuries[hitLocation] = nil
        self.heavyInjuryCheckBoxes[hitLocation]:Check(nil)
    end

    -- Clear temporary tokens
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects("Tokens")) do
        if object.getGMNotes() == "Tokens" and Player.TOKENS[object.getName()] then
            object.destruct()
        end
    end

    -- Reset survivor sheet
    if self.survivorSheet then
        local survivor = self.survivorSheet:Survivor()
        survivor:SetModifiers()
        survivor:SetBrainInjury(nil)
    end

    -- Recalculate stats to take permanent tokens into account (From @ScottMahoney on Github.com, Full name Scott Mahoney?)
    self:UpdateStats()
end


---------------------------------------------------------------------------------------------------

function Player:OnObjectDroppedOnSurvivorSheet(object)
    if object.getGMNotes() != "Survivor Box" then
        return
    end

    if self.survivorSheet then
        return log:Broadcastf("Player %d is already linked to a survivor. Click the 'Back to Settlement' button to unlink, then try dropping the survivor box again.", self.ordinal)
    end

    local survivorBox = Survivor.SurvivorBoxForObject(object)
    if not survivorBox then
        return log:Errorf("Survivor box %s isn't linked to any survivor. This usually means it was created by copying/pasting or importing from another save, which won't work. If this is the case, then you'll need to create the survivor from the 'Survivors' board.", object.getGUID())
    end

    self:UnpackSurvivorBox(survivorBox)
end

---------------------------------------------------------------------------------------------------

function Player:UnpackSurvivorBox(survivorBox)
    log:Debugf("Unpacking %s for %s", survivorBox, self)

    local playerPrefix = "Player "..self.ordinal

    local blockingObjects = Location.Get(playerPrefix.." Cards"):AllObjects()
    if #blockingObjects > 0 then
        log:Printf("Please clear the cards area then re-drop the survivor box.")
        Util.HighlightAll(blockingObjects)
        return false
    end

    local survivor = survivorBox:Survivor()

    local countsByCardNameType = {}
    for _, card in ipairs(survivor:Cards()) do
        local nameType = card.name..card.type
        countsByCardNameType[nameType] = (countsByCardNameType[nameType] or 0) + 1
    end

    -- make a copy since we'll modify this
    local positionsByCardNameType = {}
    for cardName, positions in pairs(survivor:PositionsByCardNameType()) do
        positionsByCardNameType[cardName] = Util.CopyArray(positions)
    end

    local availableLocations = {
        [Location.Get(playerPrefix.." Fighting Art 1")] = true,
        [Location.Get(playerPrefix.." Fighting Art 2")] = true,
        [Location.Get(playerPrefix.." Fighting Art 3")] = true,
        [Location.Get(playerPrefix.." Disorder 1")] = true,
        [Location.Get(playerPrefix.." Disorder 2")] = true,
        [Location.Get(playerPrefix.." Disorder 3")] = true,
        [Location.Get(playerPrefix.." Weapon Proficiency")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 1")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 2")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 3")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 4")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 5")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 6")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 7")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 8")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 9")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 10")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 11")] = true,
    }

    local survivorBoxContainer = Container(survivorBox:Object())

    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        if entry.gm_notes == "Player Figurine" then
            log:Debugf("Unpacking figurine %s to self marker", entry.guid)
            local figurineObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Marker",
                spawnFunc = function(figurineObj)
                    self:LinkFigurine(figurineObj)
                end,
            })
            
        elseif entry.gm_notes == "Bingo Card" then
            log:Debugf("Unpacking bingo card %s to self bingo card", entry.guid)
            local bingoCardObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Bingo",
                spawnFunc = function(bingoObj)
                    local waitId = nil
                    waitId = Wait.time(function()
                        if bingoObj.getButtons() then
                            Wait.stop(waitId)
                            self:LinkBingo(bingoObj)
                        end
                    end, 0.5, 5)
                end,
            })
        elseif entry.gm_notes == "Portrait" then
            log:Debugf("Unpacking portrait %s to self portrait", entry.guid)
            local portraitObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Portrait",
                spawnFunc = function(portraitObj)
                    self:LinkPortrait(portraitObj)
                    portraitObj.setLock(true)
                end,
            })
        else
            local nameType = (entry.name or "")..(entry.gm_notes or "")
            if (countsByCardNameType[nameType] or 0) > 0 then
                countsByCardNameType[nameType] = countsByCardNameType[nameType] - 1

                local position = nil
                local count = #(positionsByCardNameType[nameType] or {})
                if count > 0 then
                    position = self.boardObject.positionToWorld(positionsByCardNameType[nameType][count])
                    table.remove(positionsByCardNameType[nameType])

                    log:Debugf("Unpacking card %s/%s to (%f, %f, %f)", entry.name, entry.gm_notes, position.x, position.y, position.z)
                    survivorBoxContainer:Take({
                        guid = entry.guid,
                        position = position,
                        rotation = { x = 0, y = 180, z = 0 },
                    })

                    for _, location in ipairs(Location.LocationsAtPosition(position)) do
                        log:Debugf("Card %s/%s now occupies %s", entry.name, entry.gm_notes, location)
                        availableLocations[location] = nil
                    end
                else
                    log:Debugf("Card %s doesn't have position", entry.name)
                end
            else
                log:Debugf("Unrecognized object in %s: %s/%s", survivorBox, entry.name, entry.gm_notes)
            end
        end
    end

    local overflowLocation = Location.Get(playerPrefix.." Ability/Impairment 11")
    local extraObjects = false
    local height = 2 + 0.5
    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        local location = Player:TakeNextLocation(playerPrefix, entry.gm_notes, availableLocations)
        if not location then
            log:Errorf("No more space to place %s separately!", entry.name)
            location = overflowLocation
            extraObjects = true
        end

        log:Debugf("Taking %s (%s) to %s", entry.name, entry.guid, location)
        survivorBoxContainer:Take({
            guid     = entry.guid,
            location = location,
            height   = height,
        })
        height = height + 0.5
    end

    if extraObjects then
        log:Errorf("Some items couldn't be placed separately and have been stacked on the lower-right card slot of your survivor sheet.")
        overflowLocation:BoxCast({ debug = true })
    end

    local survivorSheet = Survivor.SurvivorSheetForSurvivor(survivorBox:Survivor())
    if survivorSheet then
        log:Debugf("%s already exists, destroying and recreating", survivorSheet)
        survivorSheet:Object().destruct()
    end

    Archive.Take({ name = "Survivor Sheet", type = "Survivor Sheet", location = playerPrefix.." Survivor Sheet", height = 0, rotation = { x = 0, y = 180, z = 0 }, spawnFunc = function(survivorSheetObject)
        -- We have to wait a single frame when taking from an infinite container or the objects will have the same equality/identity value as any other objects taken that frame
        Wait.frames(function()
            log:Debugf("Created survivor sheet for object %s and %s", survivorSheetObject.getGUID(), survivorBox:Survivor())
            local survivorSheet = Survivor.CreateSurvivorSheet(survivorBox:Survivor(), survivorSheetObject)
            survivorSheetObject.setLock(true)
            survivorBox:Object().destruct()
            self:LinkSurvivorSheet(survivorSheet)
        end, 1)
    end })

    EventManager.FireEvent(EventManager.ON_SURVIVOR_GETS_IN_PLAY, survivor)

    return true
end

---------------------------------------------------------------------------------------------------

function Player:TakeNextLocation(playerPrefix, gmNotes, availableLocations)
    if gmNotes == "Disorders" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Disorder "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Fighting Arts" or gmNotes == "Secret Fighting Arts" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Fighting Art "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Weapon Proficiencies" then
        local key = Location.Get(playerPrefix.." Weapon Proficiency")
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end

    for i = 1, 11 do
        local key = Location.Get(playerPrefix.." Ability/Impairment "..i)
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player:LinkSurvivorSheet(survivorSheet)
    assert(Check(self.survivorSheet == nil, "%s is already linked to %s", self, self.survivorSheet))

    log:Debugf("Linking %s to %s", survivorSheet, self)

    self.survivorSheet = survivorSheet
    if self.figurineObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked figurine %s name to %s", self.figurineObject.getGUID(), name)
        self.figurineObject.setName(name)
    end

    if self.portraitObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked portrait %s name to %s", self.portraitObject.getGUID(), name)
        self.portraitObject.setName(name)
    end

    if self.bingoObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked bingo %s name to %s", self.bingoObject.getGUID(), name)
        self.bingoObject.setName(name  ..  "'s Bingo")
    end

    Wait.frames(function()
        -- the survivor sheet object may have been created this turn, in which case we must wait X frames
        -- before updating any XML UI elements
        self:UpdateStats()
    end, 20)

    self:UpdateCards()

    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_LINKED, self, survivorSheet:Survivor())
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkSurvivorSheet()
    local survivorSheet = self.survivorSheet
    local survivor = survivorSheet:Survivor()
    log:Debugf("Unlinking %s from %s", survivorSheet, self)
    survivor:SetModifiers()
    self.survivorSheet = nil
    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_UNLINKED, self, survivor)
end

---------------------------------------------------------------------------------------------------

function Player:BackToSettlement()
    local survivorSheet = self.survivorSheet
    if survivorSheet == nil then
        return log:Debugf("No survivor linked with %s", self)
    end

    local survivor = survivorSheet:Survivor()

    log:Debugf("Returning %s on %s to settlement", survivorSheet, self)

    if self:PortraitObject() then
        self.survivorSheet:Survivor():SetPortraitJSON(self:PortraitObject().getJSON())
    end

    if self:BingoObject() then
        self.survivorSheet:Survivor():SetBingoJSON(self:BingoObject().getJSON())
    end

    self:UnlinkSurvivorSheet()

    local remainingObjects = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            local toDelete = {}
            for _, entry in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[entry.gm_notes] then
                    log:Debugf("Deleting %s/%s", entry.name, entry.gm_notes)
                    table.insert(toDelete, entry.name)
                end
            end
            container:Delete(toDelete)
        else
            table.insert(remainingObjects, object)
        end
    end

    if self:FigurineObject() then
        self:FigurineObject().destruct()
        self:UnlinkFigurine()
    end

    if self:PortraitObject() then
        self:PortraitObject().destruct()
        self:UnlinkPortrait()
    end

    if self:BingoObject() then
        self:BingoObject().destruct()
        self:UnlinkBingo()
    end

    if #remainingObjects > 0 then
        log:Errorf("Some cards or objects were not returned with the self to the settlement. Please record these manually.")
        Util.HighlightAll(remainingObjects)
    end

    survivorSheet:Object().destruct()

    EventManager.FireEvent(EventManager.ON_SURVIVOR_BACK_TO_SETTLEMENT, survivor)

    log:Printf("Returned %s to settlement", survivor:NameOrUnnamed())
end

---------------------------------------------------------------------------------------------------

function Player:LinkFigurine(figurineObject)
    self:UnlinkFigurine()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.figurineObject == figurineObject then
            otherPlayer:UnlinkFigurine()
        end
    end

    log:Debugf("Linking figurine [%s] %s to %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setColorTint(self.markerObject.getColorTint())
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        figurineObject.setName(name)
        self.survivorSheet:Survivor():SetFigurineJSON(figurineObject.getJSON())
        log:Printf("Linked figurine to player %s (%s)", self.ordinal, name)
    else
        log:Debugf("Linked figurine to player %s", self.ordinal)
    end

    self.figurineObject = figurineObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkFigurine()
    local figurineObject = self.figurineObject
    if not figurineObject then
        return
    end

    log:Debugf("Unlinking figurine [%s] %s) from %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setName("Unnamed Survivor")
    figurineObject.setColorTint({ r = 0, g = 0, b = 0 })
    self.figurineObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:LinkPortrait(portraitObject)
    self:UnlinkPortrait()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.portraitObject == portraitObject then
            otherPlayer:UnlinkPortrait()
        end
    end

    log:Debugf("Linking portrait [%s] %s to %s", portraitObject.getGUID(), portraitObject.getName(), self)
    --portraitObject.setColorTint(self.markerObject.getColorTint())
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        portraitObject.setName(name)
        self.survivorSheet:Survivor():SetPortraitJSON(portraitObject.getJSON())
        log:Printf("Linked portrait to player %s (%s)", self.ordinal, name)
    else
        log:Debugf("Linked portrait to player %s", self.ordinal)
    end

    self.portraitObject = portraitObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkPortrait()
    local portraitObject = self.portraitObject
    if not portraitObject then
        return
    end

    log:Debugf("Unlinking portrait [%s] %s) from %s", portraitObject.getGUID(), portraitObject.getName(), self)
    portraitObject.setName("Unnamed Survivor")
    --portraitObject.setColorTint({ r = 0, g = 0, b = 0 })
    self.portraitObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:LinkBingo(bingoObject)
    self:UnlinkBingo()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.bingoObject == bingoObject then
            otherPlayer:UnlinkBingo()
        end
    end

    log:Debugf("Linking bingo [%s] %s to %s", bingoObject.getGUID(), bingoObject.getName(), self)
    bingoObject.editButton({
            index = 24,
            color = self.markerObject.getColorTint(),
    })
    bingoObject.call("onSave")
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        bingoObject.setName(name.."'s Bingo")
        self.survivorSheet:Survivor():SetBingoJSON(bingoObject.getJSON())
    else
        log:Debugf("Linked bingo to player %s", self.ordinal)
    end
    self.bingoObject = bingoObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkBingo()
    local bingoObject = self.bingoObject
    if not bingoObject then
        return
    end

    log:Debugf("Unlinking bingo [%s] %s) from %s", bingoObject.getGUID(), bingoObject.getName(), self)
    bingoObject.setName("Unnamed Survivor's Bingo")
    bingoObject.editButton({
            index = 24,
            color = {0, 0, 0},
    })
    bingoObject.call("onSave")
    self.bingoObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:FigurineObject()
    return self.figurineObject
end

---------------------------------------------------------------------------------------------------

function Player:PortraitObject()
    return self.portraitObject
end

---------------------------------------------------------------------------------------------------

function Player:BingoObject()
    return self.bingoObject
end

---------------------------------------------------------------------------------------------------

return {
    Is = Player.Is,
    Create = Player.Create,
    Init = Player.Init,
    PostInit = Player.PostInit,
    Save = Player.Save,
    Players = function() return Player.players end,
    ForFigurine = Player.ForFigurine,
    ForPortrait = Player.ForPortrait,
    ForBingo = Player.ForBingo,
}

end)
__bundle_register("Kdm/Survivor", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Survivor")
local MessageBox = require("Kdm/MessageBox")
local NamedObject = require("Kdm/NamedObject")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

-------------------------------------------------------------------------------------------------

local Survivor = {}

local SurvivorClass = {}
SurvivorClass.__index = SurvivorClass
function SurvivorClass.Is(x) return getmetatable(x) == SurvivorClass end

local SurvivorSheetClass = {}
SurvivorSheetClass.__index = SurvivorSheetClass
function SurvivorSheetClass.Is(x) return getmetatable(x) == SurvivorSheetClass end

local SurvivorBoxClass = {}
SurvivorBoxClass.__index = SurvivorBoxClass
function SurvivorBoxClass.Is(x) return getmetatable(x) == SurvivorBoxClass end

-------------------------------------------------------------------------------------------------

Survivor.MODIFIED_STATS = {
    movement = "modifiedMovement",
    speed = "modifiedSpeed",
    accuracy = "modifiedAccuracy",
    strength = "modifiedStrength",
    evasion = "modifiedEvasion",
    luck = "modifiedLuck",
}

Survivor.CHECKBOX_SEQUENCE_MAXES = {
    ["huntXp"] = 16,
    ["courage"] = 9,
    ["understanding"] = 9,
    ["weaponProficiencyRank"] = 8,
}

Survivor.ALLOWED_CARD_TYPES = {
    ["Secret Fighting Arts"] = true,
    ["Fighting Arts"] = true,
    ["Disorders"] = true,
    ["Abilities"] = true,
    ["Severe Injuries"] = true,
    ["Weapon Proficiencies"] = true,
    ["Player Figurine"] = true,
    ["Portrait"] = true,
    ["Bingo Card"] = true,
}

Survivor.MARKER_EMPTY = "MarkerEmpty"
Survivor.MARKER_YELLOW_STAR = "MarkerYellowStar"
Survivor.MARKER_GREEN_TRIANGLE = "MarkerGreenTriangle"
Survivor.MARKER_BLUE_SQUARE = "MarkerBlueSquare"
Survivor.MARKER_RED_CIRCLE = "MarkerRedCircle"
Survivor.MARKER_PURPLE_DIAMOND = "MarkerPurpleDiamond"

Survivor.NEXT_MARKER = {
    [Survivor.MARKER_EMPTY] = Survivor.MARKER_YELLOW_STAR,
    [Survivor.MARKER_YELLOW_STAR] = Survivor.MARKER_GREEN_TRIANGLE,
    [Survivor.MARKER_GREEN_TRIANGLE] = Survivor.MARKER_BLUE_SQUARE,
    [Survivor.MARKER_BLUE_SQUARE] = Survivor.MARKER_RED_CIRCLE,
    [Survivor.MARKER_RED_CIRCLE] = Survivor.MARKER_PURPLE_DIAMOND,
    [Survivor.MARKER_PURPLE_DIAMOND] = Survivor.MARKER_EMPTY,
}

Survivor.PREV_MARKER = {
    [Survivor.MARKER_EMPTY] = Survivor.MARKER_PURPLE_DIAMOND,
    [Survivor.MARKER_PURPLE_DIAMOND] = Survivor.MARKER_RED_CIRCLE,
    [Survivor.MARKER_RED_CIRCLE] = Survivor.MARKER_BLUE_SQUARE,
    [Survivor.MARKER_BLUE_SQUARE] = Survivor.MARKER_GREEN_TRIANGLE,
    [Survivor.MARKER_GREEN_TRIANGLE] = Survivor.MARKER_YELLOW_STAR,
    [Survivor.MARKER_YELLOW_STAR] = Survivor.MARKER_EMPTY,
}

Survivor.CUSTOM_ASSETS = {
    {
        name = "CheckBoxFilled",
        url = "http://cloud-3.steamusercontent.com/ugc/1189461526463396506/7C8173ABCCC39B1FB8EB5FF188FAC0B5CF5A3F69/",
    },
    {
        name = Survivor.MARKER_EMPTY,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515064/9835893D92CE5B6B4C12FB4345E11184756578EE/",
    },
    {
        name = Survivor.MARKER_YELLOW_STAR,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515118/ADEC771A4BE98497CA7D73E8DAC54579ACF931C1/",
    },
    {
        name = Survivor.MARKER_GREEN_TRIANGLE,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515167/28CAFE231AB570185C9258E070DE650707EA6B79/",
    },
    {
        name = Survivor.MARKER_BLUE_SQUARE,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515209/10679F6E9244587F251864B6EED84FC9802FF93D/",
    },
    {
        name = Survivor.MARKER_RED_CIRCLE,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515252/2812E4FA09333A5D4DE768301D8F71291F0AD9FC/",
    },
    {
        name = Survivor.MARKER_PURPLE_DIAMOND,
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515296/0EC80660E45B8AAFB6B66F7CFD189DE0A39EC8D1/",
    },
    {
        name = "IconFightingArt",
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515347/18624B79B3DEB547755AE3EECFC219A4713F53B4/",
    },
    {
        name = "IconDisorder",
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515397/427B848EBAC81BC10C1610E90DC02F9654EEE994/",
    },
    {
        name = "IconAbility",
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515440/7E68C46CB68D455D29347172389E8F3BB0085BC0/",
    },
    {
        name = "IconSevereInjury",
        url = "http://cloud-3.steamusercontent.com/ugc/1790722535857515501/5DDEF532D75FEB02FC1DF5D924313E7A13ECE90A/",
    },
}

-------------------------------------------------------------------------------------------------

function Survivor.Init(saveState)
    Survivor.InitSaveState(saveState)
    Survivor.InitUi()
    Survivor.InitEvents()
end

---------------------------------------------------------------------------------------------------

function Survivor.InitSaveState(saveState)
    Survivor.nextSurvivorId = 1

    Survivor.survivors = {}
    Survivor.survivorsById = {}
    for _, survivorSaveState in ipairs(saveState.survivors or {}) do
        local survivor = SurvivorClass.Create(survivorSaveState)
        table.insert(Survivor.survivors, survivor)
        Survivor.survivorsById[survivor.id] = survivor
        Survivor.nextSurvivorId = Util.Max(Survivor.nextSurvivorId, survivor.id + 1)
    end

    Survivor.survivorBoxesBySurvivor = {}
    Survivor.survivorBoxesByObject = {}
    for _, survivorBoxSaveState in ipairs(saveState.survivorBoxes or {}) do
        local survivor = Survivor.survivorsById[survivorBoxSaveState.survivorId]
        if not survivor then
            return log:Errorf("Survivor box %s was saved with non-existant survivor %d", survivorBoxSaveState.objectGuid, survivorBoxSaveState.survivorId)
        end

        local object = getObjectFromGUID(survivorBoxSaveState.objectGuid)
        if not object then
            return log:Errorf("Survivor %s had saved survivor box GUID %s, but that object doesn't exist. Try re-creating this survivor's sheet from the Survivor Board.", survivor:NameOrUnnamed(), survivorBoxSaveState.objectGuid)
        end

        local survivorBox = SurvivorBoxClass.Create(survivor, object)
        Survivor.survivorBoxesBySurvivor[survivor] = survivorBox
        Survivor.survivorBoxesByObject[object] = survivorBox
    end

    Survivor.survivorSheetsBySurvivor = {}
    Survivor.survivorSheetsByObject = {}
    for _, survivorSheetSaveState in ipairs(saveState.survivorSheets or {}) do
        local survivor = Survivor.survivorsById[survivorSheetSaveState.survivorId]
        if not survivor then
            return log:Errorf("Survivor sheet %s was saved with non-existant survivor %d", survivorSheetSaveState.survivorSheetGuid, survivorSheetSaveState.survivorId)
        end

        local object = getObjectFromGUID(survivorSheetSaveState.objectGuid)
        if not object then
            return log:Errorf("Survivor %d had saved survivor sheet GUID %s, but that object doesn't exist. Try re-spawning this survivor's box from the survivor board.", survivor.id, survivorSheetSaveState.objectGuid)
        end

        local survivorSheet = SurvivorSheetClass.Create(survivor, object)
        Survivor.survivorSheetsBySurvivor[survivor] = survivorSheet
        Survivor.survivorSheetsByObject[object] = survivorSheet
    end

    Survivor.newSurvivorBonuses = saveState.newSurvivorBonuses
    Survivor.page = saveState.page or 1
    Survivor.hideLiving = saveState.hideLiving
    Survivor.hideDead = saveState.hideDead
    Survivor.hideSkipNextHunt = saveState.hideSkipNextHunt
    Survivor.hideRetired = saveState.hideRetired
    Survivor.hideYellowStar = saveState.hideYellowStar
    Survivor.hideGreenTriangle = saveState.hideGreenTriangle
    Survivor.hideBlueSquare = saveState.hideBlueSquare
    Survivor.hideRedCircle = saveState.hideRedCircle
    Survivor.hidePurpleDiamond = saveState.hidePurpleDiamond
    Survivor.hideFemales = saveState.hideFemales
    Survivor.hideMales = saveState.hideMales
end

---------------------------------------------------------------------------------------------------

function Survivor.InitUi()
    Survivor.boardObject = NamedObject.Get("Survivor Board")

    local ui = Ui.Create3d("survivorBoard", Survivor.boardObject, 0.6)
    Survivor.ui = ui

    Survivor.livingSurvivorsText = ui:Text({ id = "livingSurvivors", topLeft = { x = 5.284441, y = -7.640587 }, bottomRight = { x = 5.023291, y = -7.052870 }, fontSize = 220, alignment = "MiddleCenter" })

    Survivor.deadSurvivorsText = ui:Text({ id = "deadSurvivors", topLeft = { x = 4.319638, y = -7.642143 }, bottomRight = { x = 4.065874, y = -7.059141 }, fontSize = 220, alignment = "MiddleCenter" })

    Survivor.maleSurvivorsText = ui:Text({ id = "maleSurvivors", topLeft = { x = -6.780380, y = 7.134308 }, bottomRight = { x = -7.042556, y = 7.718416 }, fontSize = 220, alignment = "MiddleCenter" })

    Survivor.femaleSurvivorsText = ui:Text({ id = "femaleSurvivors", topLeft = { x = -7.769115, y = 7.134308 }, bottomRight = { x = -8.031291, y = 7.718416 }, fontSize = 220, alignment = "MiddleCenter" })

    Survivor.newSurvivorBonusesInput = ui:Input({ id = "newSurvivorBonuses", topLeft = { x = 3.778204, y = -7.33247 }, bottomRight = { x = 1.031039, y = -7.164494 }, fontSize = 80, alignment = "LowerLeft", text = Survivor.newSurvivorBonuses, onValueChanged = function(value)
        Survivor.newSurvivorBonuses = value
        Survivor.newSurvivorBonusesInput:SetText(value)
    end })

    Survivor.newSurvivorButton = ui:Button({ id = "newSurvivor", topLeft = { x = 0.756925, y = -7.658921 }, bottomRight = { x = -0.617333,y = -7.045891 }, onClick = function()
        local id = Survivor.nextSurvivorId
        Survivor.nextSurvivorId = Survivor.nextSurvivorId + 1
        local survivor = SurvivorClass.Create({ id = id })
        table.insert(Survivor.survivors, survivor)
        Survivor.survivorsById[survivor.id] = survivor

        Survivor.UpdateLivingDeadCounts()
        Survivor.UpdateSexCounts()
        Survivor.SetPageAndRefresh(Survivor.MaxPage())
    end })

    Survivor.clearSkipNextHuntButton = ui:Button({ id = "clearSkipNextHunt", topLeft = { x = -0.897427, y = -7.661951 }, bottomRight = { x = -2.819457, y = -7.049488 }, onClick = function()
        for _, survivor in ipairs(Survivor.survivors) do
            if survivor:SkipNextHunt() then
                survivor:SetSkipNextHunt(false)
                log:Printf("Cleared 'Skip Next Hunt' on %s", survivor:NameOrUnnamed())
            end
        end
    end })

    Survivor.previousPageButton = ui:Button({ id = "previousPage", topLeft = { x = -6.576738, y = -7.658603 }, bottomRight = { x = -6.846550, y = -7.060284 }, onClick = function()
        Survivor.SetPageAndRefresh(Survivor.page - 1)
    end })

    Survivor.pageText = ui:Text({ id = "page", topLeft = { x = -6.846550, y = -7.658603 }, bottomRight = { x = -7.783247, y = -7.040886 }, fontSize = 160, alignment = "MiddleCenter" })

    Survivor.nextPageButton = ui:Button({ id = "nextPage", topLeft = { x = -7.783247, y = -7.662317 }, bottomRight = { x = -8.049563, y = -7.040886 }, onClick = function()
        Survivor.SetPageAndRefresh(Survivor.page + 1)
    end })

    local width = 7.051640 - 7.260710
    local top = 7.231073
    local height = 7.696268 - top
    for suffix, left in pairs({
        Living = 7.260710,
        Dead = 6.436522,
        SkipNextHunt = 5.644810,
        Retired = 4.296477,
        YellowStar = 3.390988,
        GreenTriangle = 2.677092,
        BlueSquare = 1.925451,
        RedCircle = 1.205827,
        PurpleDiamond = 0.489192,
        Females = -0.230432,
        Males = -0.950056,
    }) do
        local attr = "hide"..suffix
        local cb = attr.."CheckBox"
        Survivor[cb] = ui:CheckBox({ id = attr, topLeft = { x = left, y = top }, bottomRight = { x = left + width, y = top + height }, checked = Survivor[attr], onClick = function()
            Survivor[attr] = not Survivor[attr]
            Survivor[cb]:Check(Survivor[attr])
            Survivor.SetPageAndRefresh(1)
        end })
    end

    Survivor.cells = {}
    for i = 1, 20 do
        local cell = {
            object = NamedObject.Get("Survivor Board Cell "..i),
            ordinal = i,
        }
        Survivor.InitSurvivorCellUi(cell)
        Survivor.cells[i] = cell
    end

    -- total hack because the board is so large and text get weird
    Survivor.livingSurvivorsText.attributes.scale = "0.1 0.2246487"
    Survivor.deadSurvivorsText.attributes.scale = "0.1 0.2246487"
    Survivor.maleSurvivorsText.attributes.scale = "0.1 0.2246487"
    Survivor.femaleSurvivorsText.attributes.scale = "0.1 0.2246487"
    Survivor.newSurvivorBonusesInput.attributes.scale = "0.1 0.2246487"
    Survivor.pageText.attributes.scale = "0.1 0.2246487"


    Survivor.boardObject.UI.setCustomAssets(Survivor.CUSTOM_ASSETS)
    Survivor.ui:ApplyToObject()
end

---------------------------------------------------------------------------------------------------

function Survivor.InitSurvivorCellUi(cell)
    local ui = Ui.Create3d("survivorCell"..cell.ordinal, cell.object, 0.11)
    cell.ui = ui

    cell.survivalCounter = ui:Counter({ id = "survival", topLeft = { x = 0.488679, y = -0.960464 }, bottomRight = { x = 0.294088, y = -0.766285 }, fontSize = 140, text = 0, onValueChanged = function(delta)
        cell.survivor:SetSurvival(cell.survivor:Survival() + delta)
    end })

    cell.insanityCounter = ui:Counter({ id = "insanity", topLeft = { x = -0.293847, y = -0.964120 }, bottomRight = { x = -0.489293, y = -0.764670 }, fontSize = 140, text = 0, onValueChanged = function(delta)
        local newValue = cell.survivor:Insanity() + delta
        cell.survivor:SetInsanity(newValue)
    end })

    for stat, data in pairs({
        ["movement"] = { topLeft = { x = 0.237461, y = -0.963491 }, bottomRight = { x = 0.098091, y = -0.824870 } },
        ["speed"] = { topLeft = { x = 0.070339, y = -0.964019 }, bottomRight = { x = -0.069972, y = -0.823512 } },
        ["accuracy"] = { topLeft = { x = -0.095285, y = -0.960736 }, bottomRight = { x = -0.235804, y = -0.823606 } },
        ["strength"] = { topLeft = { x = 0.238673, y = -0.745258 }, bottomRight = { x = 0.097487, y = -0.610387 } },
        ["evasion"] = { topLeft = { x = 0.068523, y = -0.746108 }, bottomRight = { x = -0.068570, y = -0.609721 } },
        ["luck"] = { topLeft = { x = -0.097451, y = -0.747023 }, bottomRight = { x = -0.236673, y = -0.608649 } },
    }) do
        cell[stat.."Counter"] = ui:Counter({ id = stat, topLeft = data.topLeft, bottomRight = data.bottomRight, fontSize = 90, onValueChanged = function(delta)
            cell.survivor:SetModified(stat, cell.survivor[stat] + delta)
        end })
    end

    cell.markerButton = ui:Button({ id = "marker", topLeft = { x = 0.490351, y = -0.667075 }, bottomRight = { x = 0.295514, y = -0.556129 }, colors = Ui.IMAGE_COLORS, onClick = function(button)
        local value = cell.survivor:Marker() or Survivor.MARKER_EMPTY
        if button == Ui.LEFT_MOUSE_BUTTON then
            value = Survivor.NEXT_MARKER[value]
        else
            value = Survivor.PREV_MARKER[value]
        end
        cell.survivor:SetMarker(value)
    end })

    cell.nameInput = ui:Input({ id = "name", topLeft = { x = 0.374686, y = -0.555475 }, bottomRight = { x = -0.492332, y = -0.471773 }, fontSize = 60, placeholder = "Unnamed Survivor", onValueChanged = function(value)
        cell.survivor:SetName(value)
    end })

    local smallCheckBoxSize = 0.0352955
    local bigCheckBoxSize = 0.04039

    for stat, topLeft in pairs({
        ["male"] = { x = 0.488708, y = -0.450130 },
        ["female"] = { x = 0.391058, y = -0.451183 },
        ["reroll"] = { x = 0.301735, y = -0.448962 },
        ["skipNextHunt"] = { x = 0.097530, y = -0.451439 },
        ["retired"] = { x = -0.156637, y = -0.451290 },
        ["dead"] = { x = -0.334745, y = -0.450177 },
    }) do
        cell[stat.."CheckBox"] = ui:CheckBox({ id = stat, topLeft = topLeft, bottomRight = { x = topLeft.x - smallCheckBoxSize, y = topLeft.y + smallCheckBoxSize }, onClick = function()
            cell.survivor:SetBool(stat, not cell.survivor[stat])
        end })
    end

    for stat, seq in pairs({
        ["huntXp"] = {
            { topLeft = { x = 0.312961, y = -0.358888 }, big = false },
            { topLeft = { x = 0.260530, y = -0.362141 }, big = true },
            { topLeft = { x = 0.205214, y = -0.358888 }, big = false },
            { topLeft = { x = 0.158189, y = -0.358888 }, big = false },
            { topLeft = { x = 0.111091, y = -0.358888 }, big = false },
            { topLeft = { x = 0.060947, y = -0.362141 }, big = true },
            { topLeft = { x = 0.004465, y = -0.358888 }, big = false },
            { topLeft = { x = -0.043838, y = -0.358888 }, big = false },
            { topLeft = { x = -0.089868, y = -0.358888 }, big = false },
            { topLeft = { x = -0.138367, y = -0.362141 }, big = true },
            { topLeft = { x = -0.195562, y = -0.358888 }, big = false },
            { topLeft = { x = -0.242767, y = -0.358888 }, big = false },
            { topLeft = { x = -0.290438, y = -0.358888 }, big = false },
            { topLeft = { x = -0.336773, y = -0.358888 }, big = false },
            { topLeft = { x = -0.386495, y = -0.362141 }, big = true },
            { topLeft = { x = -0.447584, y = -0.362141 }, big = true },
        },
        ["courage"] = {
            { topLeft = { x = 0.489029, y = -0.207650 }, big = false },
            { topLeft = { x = 0.440906, y = -0.207650 }, big = false },
            { topLeft = { x = 0.391424, y = -0.209982 }, big = true },
            { topLeft = { x = 0.335180, y = -0.207650 }, big = false },
            { topLeft = { x = 0.287784, y = -0.207650 }, big = false },
            { topLeft = { x = 0.240546, y = -0.207650 }, big = false },
            { topLeft = { x = 0.193479, y = -0.207650 }, big = false },
            { topLeft = { x = 0.146031, y = -0.207650 }, big = false },
            { topLeft = { x = 0.096573, y = -0.209982 }, big = true },
        },
        ["understanding"] = {
            { topLeft = { x = 0.489029 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.440906 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.391424 + -0.542864, y = -0.209982 }, big = true },
            { topLeft = { x = 0.335180 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.287784 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.240546 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.193479 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.146031 + -0.542864, y = -0.207650 }, big = false },
            { topLeft = { x = 0.096573 + -0.542864, y = -0.209982 }, big = true },
        },
        ["weaponProficiencyRank"] = {
            { topLeft = { x = 0.488380, y = -0.056321 }, big = false },
            { topLeft = { x = 0.441384, y = -0.056321 }, big = false },
            { topLeft = { x = 0.391489, y = -0.060015  }, big = true },
            { topLeft = { x = 0.335152, y = -0.056321 }, big = false },
            { topLeft = { x = 0.288189, y = -0.056321 }, big = false },
            { topLeft = { x = 0.240844, y = -0.056321 }, big = false },
            { topLeft = { x = 0.194179, y = -0.056321 }, big = false },
            { topLeft = { x = 0.143038, y = -0.060015  }, big = true },
        }
    }) do
        for i, data in ipairs(seq) do
            local bottomRight = { x = data.topLeft.x, y = data.topLeft.y }
            if data.big then
                bottomRight.x = bottomRight.x - bigCheckBoxSize
                bottomRight.y = bottomRight.y + bigCheckBoxSize
            else
                bottomRight.x = bottomRight.x - smallCheckBoxSize
                bottomRight.y = bottomRight.y + smallCheckBoxSize
            end

            local stati = stat..i
            cell[stati.."CheckBox"] = ui:CheckBox({ id = stati, topLeft = data.topLeft, bottomRight = bottomRight, onClick = function()
                local value = i
                if cell.survivor[stat] >= i then
                    value = value - 1
                end
                cell.survivor:SetNum(stat, value)
            end })
        end
    end

    cell.weaponProficiencyTypeInput = ui:Input({ id = "weaponProficiencyType", topLeft = { x = -0.054834, y = -0.064679 }, bottomRight = { x = -0.490963, y = -0.017972 }, fontSize = 40, onValueChanged = function(value)
        cell.survivor:SetWeaponProficiencyType(value)
    end })

    local image1TopLeft = { x = 0.492351, y = 0.091029 }
    local image1BottomRight = { x = 0.446708, y = 0.136740 }
    local image14TopLeft = { x = 0.001845, y = 0.426968 }
    local imageWidth = image1BottomRight.x - image1TopLeft.x
    local imageHeight = image1BottomRight.y - image1TopLeft.y
    local imageColDelta = image14TopLeft.x - image1TopLeft.x
    local imageRowDelta = (image14TopLeft.y - image1TopLeft.y) / 6
    local textOffset = -0.01
    for col = 1, 2 do
        local x = image1TopLeft.x + ((col - 1) * imageColDelta)
        for row = 1, 7 do
            local y = image1TopLeft.y + ((row - 1) * imageRowDelta)
            local i = ((col - 1) * 7) + row
            cell["card"..i.."Image"] = ui:Image({
                id = "card"..i,
                topLeft = { x = x , y = y },
                bottomRight = { x = x + imageWidth, y = y + imageHeight },
            })
            cell["card"..i.."Text"] = ui:Text({
                id = "card"..i,
                topLeft = { x = x + imageWidth + textOffset, y = y },
                bottomRight = { x = x + imageColDelta, y = y + imageHeight },
                fontSize = 40,
                alignment = "MiddleLeft",
            })
        end
    end

    for i, data in pairs({
        { topLeft = { x = 0.494516, y = 0.550233 }, bottomRight = { x = -0.491173, y = 0.594320 } },
        { topLeft = { x = 0.494516, y = 0.609200 }, bottomRight = { x = -0.491173, y = 0.654265 } },
        { topLeft = { x = 0.494516, y = 0.668215 }, bottomRight = { x = -0.491173, y = 0.713223 } },
        { topLeft = { x = 0.494516, y = 0.727703 }, bottomRight = { x = -0.491173, y = 0.773722 } },
        { topLeft = { x = 0.494516, y = 0.787172 }, bottomRight = { x = -0.491173, y = 0.833688 } },
    }) do
        cell["notes"..i.."Input"] = ui:Input({ id = "notes"..i, topLeft = data.topLeft, bottomRight = data.bottomRight, fontSize = 30, onValueChanged = function(value)
            cell.survivor["SetNotes"..i](cell.survivor, value)
        end })
    end

    cell.moveToBeginningButton = ui:Button({ id = "moveToBeginning", topLeft = { x = 0.490387, y = 0.862018 }, bottomRight = { x = 0.392043, y = 0.960771 }, onClick = function()
        Survivor.MoveBefore(cell.survivor, Survivor.SurvivorsMatchingCurrentFilters()[1])
        Survivor.SetPageAndRefresh(Survivor.page)
    end })

    cell.moveBackButton = ui:Button({ id = "moveBack", topLeft = { x = 0.368695, y = 0.863741 }, bottomRight = { x = 0.271971, y = 0.959538 }, onClick = function()
        local index = ((Survivor.page - 1) * 20) + cell.ordinal
        Survivor.MoveBefore(cell.survivor, Survivor.SurvivorsMatchingCurrentFilters()[index - 1])
        Survivor.SetPageAndRefresh(math.ceil((index - 1) / 20))
    end })

    cell.spawnButton = ui:Button({ id = "spawn", topLeft = { x = 0.246005, y = 0.862302 }, bottomRight = { x = 0.011954, y = 0.962470 }, onClick = function()
        Survivor.SpawnSurvivorBox(cell.survivor, "Survivor Box Spawn "..cell.ordinal)
    end })

    cell.deleteButton = ui:Button({ id = "delete", topLeft = { x = -0.013713, y = 0.860059 }, bottomRight = { x = -0.252386, y = 0.958966 }, onClick = function()
        Survivor.DestroySurvivor(cell.survivor)
    end })

    cell.moveForwardButton = ui:Button({ id = "moveForward", topLeft = { x = -0.274279, y = 0.857828 }, bottomRight = { x = -0.369863, y = 0.959786 }, onClick = function()
        local index = ((Survivor.page - 1) * 20) + cell.ordinal
        Survivor.MoveAfter(cell.survivor, Survivor.SurvivorsMatchingCurrentFilters()[index + 1])
        Survivor.SetPageAndRefresh(math.ceil((index + 1) / 20))
    end })

    cell.moveToEndButton = ui:Button({ id = "moveToEnd", topLeft = { x = -0.392412, y = 0.860326 }, bottomRight = { x = -0.492170, y = 0.961336 }, onClick = function()
        local survivors = Survivor.SurvivorsMatchingCurrentFilters()
        Survivor.MoveAfter(cell.survivor, survivors[#survivors])
        Survivor.SetPageAndRefresh(Survivor.page)
    end })

    cell.object.UI.setCustomAssets(Survivor.CUSTOM_ASSETS)
    cell.ui:ApplyToObject()
end

---------------------------------------------------------------------------------------------------

function Survivor.InitEvents()
    EventManager.AddHandler("onObjectDestroy", function(object)
        local survivorBox = Survivor.survivorBoxesByObject[object]
        if survivorBox then
            log:Debugf("%s was destroyed", survivorBox)
            Survivor.survivorBoxesBySurvivor[survivorBox.survivor] = nil
            Survivor.survivorBoxesByObject[object] = nil
            return
        end

        local survivorSheet = Survivor.survivorSheetsByObject[object]
        if survivorSheet then
            log:Debugf("%s was destroyed", survivorSheet)
            Survivor.survivorSheetsBySurvivor[survivorSheet.survivor] = nil
            Survivor.survivorSheetsByObject[object] = nil
            return
        end
    end)

    EventManager.AddHandler("onObjectEnterContainer", function(container, object)
        local survivorBox = Survivor.survivorBoxesByObject[container]
        if survivorBox then
            survivorBox:UpdateCards()
        end
    end)

    EventManager.AddHandler("onObjectLeaveContainer", function(container, object)
        local survivorBox = Survivor.survivorBoxesByObject[container]
        if survivorBox then
            survivorBox:UpdateCards()
        end
    end)

    EventManager.AddHandler("tryObjectEnterContainer", function(container, object, previousReturnValue)
        if previousReturnValue == false then
            return false
        end

        if Survivor.survivorBoxesByObject[object]  then
            log:Printf("Survivor boxes cannot be put into containers.")
            return false
        end

        if Survivor.survivorBoxesByObject[container] and not Survivor.ALLOWED_CARD_TYPES[object.getGMNotes()] then
            log:Printf("Only Fighting Arts, Disorders, Abilities, and Impairments can go into survivor boxes.")
            return false
        end

        return true
    end)

    EventManager.AddHandler(EventManager.ON_SURVIVOR_STAT_CHANGED, function(survivor, stat, value)
        if stat == "name" then
            local survivorBox = Survivor.survivorBoxesBySurvivor[survivor]
            if survivorBox then
                survivorBox:SetName(value)
            end
        end

        if stat == "dead" then
            Survivor.UpdateLivingDeadCounts()
        end

        if stat == "male" or stat == "female" then
            Survivor.UpdateSexCounts()
        end

        if stat == "dead" or stat == "retired" or stat == "skipNextHunt" or stat == "marker" or stat == "male" or stat == "female" then
            Survivor.SetPageAndRefresh(Util.Min(Survivor.MaxPage(), Survivor.page))
        end

        local survivorSheet = Survivor.survivorSheetsBySurvivor[survivor]
        if survivorSheet then
            local updater = Survivor.statUpdaters[stat]
            if updater then
                log:Debugf("%s %s changed to %s", survivor, stat, value)
                updater(survivorSheet, stat, value)
            end
        end

        for _, cell in ipairs(Survivor.cells) do
            if cell.survivor == survivor then
                local updater = Survivor.statUpdaters[stat]
                if updater then  -- some stats don't have UI
                    updater(cell, stat, value)
                    break
                end
            end
        end
    end)

    EventManager.AddHandler(EventManager.ON_SURVIVOR_GETS_IN_PLAY, function(survivor)
        for _, cell in ipairs(Survivor.cells) do
            if cell.survivor == survivor then
                cell.nameInput:SetTextColor(Ui.DARK_RED)
                cell.survivor:SetInPlay(true)
            end
        end
    end)

    EventManager.AddHandler(EventManager.ON_SURVIVOR_BACK_TO_SETTLEMENT, function(survivor)
        for _, cell in ipairs(Survivor.cells) do
            if cell.survivor == survivor then
                cell.nameInput:SetTextColor(Ui.DARK_BROWN)
                cell.survivor:SetInPlay(false)
            end
        end
    end)

    EventManager.AddHandler(EventManager.ON_SURVIVOR_CARDS_CHANGED, function(survivor)
        for _, cell in ipairs(Survivor.cells) do
            if cell.survivor == survivor then
                Survivor.UpdateCellCards(cell)
            end
        end
    end)
end

-------------------------------------------------------------------------------------------------

function Survivor.PostInit()
    Survivor.UpdateLivingDeadCounts()
    Survivor.UpdateSexCounts()
    Survivor.SetPageAndRefresh(Survivor.page)
end

---------------------------------------------------------------------------------------------------

function Survivor.Save()
    local survivors = {}
    for _, survivor in ipairs(Survivor.survivors) do
        table.insert(survivors, survivor:Save())
    end

    local survivorBoxes = {}
    for _, survivorBox in pairs(Survivor.survivorBoxesBySurvivor) do
        table.insert(survivorBoxes, survivorBox:Save())
    end

    local survivorSheets = {}
    for _, survivorSheet in pairs(Survivor.survivorSheetsBySurvivor) do
        table.insert(survivorSheets, survivorSheet:Save())
    end

    return {
        survivors = survivors,
        survivorBoxes = survivorBoxes,
        survivorSheets = survivorSheets,

        newSurvivorBonuses = Survivor.newSurvivorBonuses,
        page = Survivor.page,
        hideLiving = Survivor.hideLiving,
        hideDead = Survivor.hideDead,
        hideSkipNextHunt = Survivor.hideSkipNextHunt,
        hideRetired = Survivor.hideRetired,
        hideYellowStar = Survivor.hideYellowStar,
        hideGreenTriangle = Survivor.hideGreenTriangle,
        hideBlueSquare = Survivor.hideBlueSquare,
        hideRedCircle = Survivor.hideRedCircle,
        hidePurpleDiamond = Survivor.hidePurpleDiamond,
        hideFemales = Survivor.hideFemales,
        hideMales = Survivor.hideMales,
    }
end

---------------------------------------------------------------------------------------------------

function Survivor.Import(data)
    for object, _ in pairs(Survivor.survivorBoxesByObject) do
        object.destruct()
    end
    Survivor.survivorBoxesBySurvivor = {}
    Survivor.survivorBoxesByObject = {}

    for object, survivorSheet in pairs(Survivor.survivorSheetsByObject) do
        object.destruct()
    end
    Survivor.survivorSheetsBySurvivor = {}
    Survivor.survivorSheetsByObject = {}

    Survivor.InitSaveState(data)

    Survivor.UpdateLivingDeadCounts()
    Survivor.UpdateSexCounts()
    Survivor.SetPageAndRefresh(Survivor.page)
end

-------------------------------------------------------------------------------------------------

-- same as save except we don't include physical objects: sheets and boxes
function Survivor.Export()
    local survivors = {}
    for _, survivor in ipairs(Survivor.survivors) do
        table.insert(survivors, survivor:Save())
    end

    return {
        survivors = survivors,

        newSurvivorBonuses = Survivor.newSurvivorBonuses,
        page = Survivor.page,
        hideLiving = Survivor.hideLiving,
        hideDead = Survivor.hideDead,
        hideSkipNextHunt = Survivor.hideSkipNextHunt,
        hideRetired = Survivor.hideRetired,
        hideYellowStar = Survivor.hideYellowStar,
        hideGreenTriangle = Survivor.hideGreenTriangle,
        hideBlueSquare = Survivor.hideBlueSquare,
        hideRedCircle = Survivor.hideRedCircle,
        hidePurpleDiamond = Survivor.hidePurpleDiamond,
        hideFemales = Survivor.hideFemales,
        hideMales = Survivor.hideMales,
    }
end

-------------------------------------------------------------------------------------------------

function Survivor.UpdateLivingDeadCounts()
    local numLiving = 0
    local numDead = 0
    for _, survivor in ipairs(Survivor.survivors) do
        if survivor:Dead() then
            numDead = numDead + 1
        else
            numLiving = numLiving + 1
        end
    end

    Survivor.livingSurvivorsText:SetText(numLiving)
    Survivor.deadSurvivorsText:SetText(numDead)
end

-------------------------------------------------------------------------------------------------

function Survivor.UpdateSexCounts()
    local numMales = 0
    local numFemales = 0
    for _, survivor in ipairs(Survivor.survivors) do
        if survivor:Male() then
            numMales = numMales + 1
        end
        if survivor:Female() then
            numFemales = numFemales + 1
        end
    end

    Survivor.maleSurvivorsText:SetText(numMales)
    Survivor.femaleSurvivorsText:SetText(numFemales)
end

---------------------------------------------------------------------------------------------------

function Survivor.SurvivorsMatchingCurrentFilters()
    local survivors = {}

    for i, survivor in ipairs(Survivor.survivors) do
        local hideSurvivor = (
            (Survivor.hideLiving and not survivor:Dead()) or
            (Survivor.hideDead and survivor:Dead()) or
            (Survivor.hideSkipNextHunt and survivor:SkipNextHunt()) or
            (Survivor.hideRetired and survivor:Retired()) or
            (Survivor.hideYellowStar and survivor:Marker() == Survivor.MARKER_YELLOW_STAR) or
            (Survivor.hideGreenTriangle and survivor:Marker() == Survivor.MARKER_GREEN_TRIANGLE) or
            (Survivor.hideBlueSquare and survivor:Marker() == Survivor.MARKER_BLUE_SQUARE) or
            (Survivor.hideRedCircle and survivor:Marker() == Survivor.MARKER_RED_CIRCLE) or
            (Survivor.hidePurpleDiamond and survivor:Marker() == Survivor.MARKER_PURPLE_DIAMOND) or
            (Survivor.hideFemales and survivor:Female()) or
            (Survivor.hideMales and survivor:Male())
        )
        if not hideSurvivor then
            table.insert(survivors, survivor)
        end
    end

    return survivors
end

---------------------------------------------------------------------------------------------------

function Survivor.MaxPage()
    return Util.Max(1, math.ceil(#Survivor.SurvivorsMatchingCurrentFilters() / 20))
end

---------------------------------------------------------------------------------------------------

function Survivor.SetPageAndRefresh(page)
    local survivors = Survivor.SurvivorsMatchingCurrentFilters()

    local maxPage = Util.Max(1, math.ceil(#survivors / 20))
    if page < 1 then
        log:Debugf("Capping page to 1")
        page = 1
    elseif page > maxPage then
        log:Debugf("Capping page to maxPage=%d", maxPage)
        page = maxPage
    end

    Survivor.page = page

    local baseIndex = (page - 1) * 20
    local numSurvivorsOnPage = Util.Min(baseIndex + 20, #survivors) - baseIndex

    log:Debugf("Found %d survivors on page %d", numSurvivorsOnPage, page)

    for i = 1, numSurvivorsOnPage do
        Survivor.ShowCell(Survivor.cells[i], survivors[baseIndex + i])
    end
    for i = numSurvivorsOnPage + 1, 20 do
        Survivor.HideCell(Survivor.cells[i])
    end

    Survivor.pageText:SetText("Page "..page.."/"..maxPage)
end

---------------------------------------------------------------------------------------------------

function Survivor.MoveBefore(survivor, beforeSurvivor)
    if not beforeSurvivor or survivor == beforeSurvivor then
        return
    end

    local survivorIndex = nil
    local beforeSurvivorIndex = nil
    for i, s in ipairs(Survivor.survivors) do
        if s == survivor then
            survivorIndex = i
        elseif s == beforeSurvivor then
            beforeSurvivorIndex = i
        end
    end

    assert(Check(survivorIndex != nil))
    assert(Check(beforeSurvivorIndex != nil))

    table.insert(Survivor.survivors, beforeSurvivorIndex, Survivor.survivors[survivorIndex])
    if survivorIndex < beforeSurvivorIndex then
        table.remove(Survivor.survivors, survivorIndex)
    else
        table.remove(Survivor.survivors, survivorIndex + 1)
    end
end

---------------------------------------------------------------------------------------------------

function Survivor.MoveAfter(survivor, afterSurvivor)
    if not afterSurvivor or survivor == afterSurvivor then
        return
    end

    local survivorIndex = nil
    local afterSurvivorIndex = nil
    for i, s in ipairs(Survivor.survivors) do
        if s == survivor then
            survivorIndex = i
        elseif s == afterSurvivor then
            afterSurvivorIndex = i
        end
    end

    assert(Check(survivorIndex != nil))
    assert(Check(afterSurvivorIndex != nil))

    table.insert(Survivor.survivors, afterSurvivorIndex + 1, Survivor.survivors[survivorIndex])
    if survivorIndex < afterSurvivorIndex then
        table.remove(Survivor.survivors, survivorIndex)
    else
        table.remove(Survivor.survivors, survivorIndex + 1)
    end
end

---------------------------------------------------------------------------------------------------

function Survivor.CanDestroySurvivor(survivor)
    local survivorBox = Survivor.survivorBoxesBySurvivor[survivor]
    if survivorBox then
        log:Broadcastf("Please delete survivor box first.")
        Util.Highlight(survivorBox.object)
        return
    end

    local survivorSheet = Survivor.survivorSheetsBySurvivor[survivor]
    if survivorSheet then
        log:Broadcastf("Please return survivor to settlement first.")
        Util.Highlight(survivorSheet.object)
        return
    end

    return true
end

---------------------------------------------------------------------------------------------------

function Survivor.DestroySurvivor(survivor)
    if not Survivor.CanDestroySurvivor(survivor) then
        return
    end

    MessageBox.Show(Util.SafeFormat("Are you sure you want to delete '%s'", survivor:NameOrUnnamed()), function()
        -- We have to check again for the pathological case of spawning a box/sheet while the message box is up
        if not Survivor.CanDestroySurvivor(survivor) then
            return
        end

        for i, s in ipairs(Survivor.survivors) do
            if s == survivor then
                table.remove(Survivor.survivors, i)
                Survivor.survivorsById[survivor.id] = nil

                log:Printf("Deleted survivor %s", survivor:NameOrUnnamed())

                Survivor.UpdateLivingDeadCounts()
                Survivor.UpdateSexCounts()
                Survivor.SetPageAndRefresh(Util.Min(Survivor.MaxPage(), Survivor.page))

                EventManager.FireEvent(EventManager.ON_SURVIVOR_DESTROYED, survivor)
            end
        end

        log:Debugf("Survivor %s not found, it must have already been deleted", survivor)
    end)
end

---------------------------------------------------------------------------------------------------

-- to generate cell positions:
-- local notes = ""
-- for i = 1, 20 do
--     local pos = Survivor.cells[i].object.getPosition()
--     notes = notes..string.format("{ x = %f, y = %f, z = %f },
", pos.x, pos.y, pos.z)
-- end
-- setNotes(notes)

Survivor.CELL_POSITIONS = {
    { x = -44.897339, y = 3.424418, z = -87.435417 },
    { x = -34.916607, y = 3.424421, z = -87.436218 },
    { x = -24.935480, y = 3.424424, z = -87.436760 },
    { x = -14.954360, y = 3.424428, z = -87.437302 },
    { x = -4.973239, y = 3.424431, z = -87.437851 },
    { x = 5.007882, y = 3.424434, z = -87.438400 },
    { x = 14.989003, y = 3.424437, z = -87.438942 },
    { x = 24.970661, y = 3.424440, z = -87.439453 },
    { x = 34.951500, y = 3.424444, z = -87.440254 },
    { x = 44.932381, y = 3.424447, z = -87.440941 },
    { x = -44.898739, y = 3.424458, z = -105.875778 },
    { x = -34.917610, y = 3.424461, z = -105.876328 },
    { x = -24.936489, y = 3.424464, z = -105.876877 },
    { x = -14.955368, y = 3.424467, z = -105.877419 },
    { x = -4.974248, y = 3.424470, z = -105.877968 },
    { x = 5.006873, y = 3.424474, z = -105.878510 },
    { x = 14.987995, y = 3.424477, z = -105.879059 },
    { x = 24.969114, y = 3.424480, z = -105.879601 },
    { x = 34.950699, y = 3.424483, z = -105.880150 },
    { x = 44.931355, y = 3.424486, z = -105.880692 },
}

function Survivor.ShowCell(cell, survivor)
    log:Debugf("Showing cell %d with survivor %s", cell.ordinal, survivor)

    if cell.survivor == survivor then
        log:Debugf("Cell %d already has survivor %s", cell.ordinal, survivor)
        return
    end

    cell.survivor = survivor

    cell.markerButton:SetImage(survivor:Marker() or Survivor.MARKER_EMPTY)

    -- counters
    cell.survivalCounter:SetText(survivor:Survival())
    cell.insanityCounter:SetText(survivor:Insanity())
    cell.movementCounter:SetText(survivor:Movement())
    cell.speedCounter:SetText(survivor:Speed())
    cell.accuracyCounter:SetText(survivor:Accuracy())
    cell.strengthCounter:SetText(survivor:Strength())
    cell.evasionCounter:SetText(survivor:Evasion())
    cell.luckCounter:SetText(survivor:Luck())

    -- inputs
    cell.nameInput:SetText(survivor:Name())
    if survivor:InPlay() then
        cell.nameInput:SetTextColor(Ui.DARK_RED)
    else
        cell.nameInput:SetTextColor(Ui.DARK_BROWN)
    end
    cell.weaponProficiencyTypeInput:SetText(survivor:WeaponProficiencyType())
    cell.notes1Input:SetText(survivor:Notes1())
    cell.notes2Input:SetText(survivor:Notes2())
    cell.notes3Input:SetText(survivor:Notes3())
    cell.notes4Input:SetText(survivor:Notes4())
    cell.notes5Input:SetText(survivor:Notes5())

    -- checkboxes
    cell.maleCheckBox:Check(survivor:Male())
    cell.femaleCheckBox:Check(survivor:Female())
    cell.rerollCheckBox:Check(survivor:Reroll())
    cell.skipNextHuntCheckBox:Check(survivor:SkipNextHunt())
    cell.retiredCheckBox:Check(survivor:Retired())
    cell.deadCheckBox:Check(survivor:Dead())

    -- checkbox sequences
    for stat, max in pairs(Survivor.CHECKBOX_SEQUENCE_MAXES) do
        local value = Util.Min(survivor[stat], max)
        for i = 1, value do
            cell[stat..i.."CheckBox"]:Check(true)
        end
        for i = value + 1, max do
            cell[stat..i.."CheckBox"]:Check(false)
        end
    end

    Survivor.UpdateCellCards(cell)

    cell.object.setScale({ x = 9.01, y = 1, z = 9.01 })
    cell.object.setRotation({ x = 0, y = 180, z = 0 })
    cell.object.setPosition(Survivor.CELL_POSITIONS[cell.ordinal])
end

---------------------------------------------------------------------------------------------------
Survivor.ICONS_BY_TYPE = {
    ["Secret Fighting Arts"] = "IconFightingArt",
    ["Fighting Arts"] = "IconFightingArt",
    ["Disorders"] = "IconDisorder",
    ["Abilities"] = "IconAbility",
    ["Severe Injuries"] = "IconSevereInjury",
}

function Survivor.UpdateCellCards(cell)
    local cardsByType = {
        ["Abilities"] = {},
        ["Disorders"] = {},
        ["Fighting Arts"] = {},
        ["Secret Fighting Arts"] = {},
        ["Severe Injuries"] = {},
    }
    for _, card in ipairs(cell.survivor:Cards()) do
        if cardsByType[card.type] then
            table.insert(cardsByType[card.type], card)
        end
    end

    for i = 1, 14 do
        cell["card"..i.."Text"]:Hide()
        cell["card"..i.."Image"]:Hide()
    end

    local function PickIndex(list1, list2)
        local i = nil
        if #list1 > 0 then
            i = list1[#list1]
            table.remove(list1)
        elseif #list2 > 0 then
            i = list2[#list2]
            table.remove(list2)
        end
        return i
    end

    -- we pick starting from the end
    local left = { 7, 6, 5, 4, 3, 2, 1 }
    local right = { 14, 13, 12, 11, 10, 9, 8 }

    -- prefer left
    for _, type in ipairs({ "Fighting Arts", "Secret Fighting Arts", "Abilities" }) do
        for _, card in ipairs(cardsByType[type]) do
            local i = PickIndex(left, right)
            if i then
                log:Debugf("Picked %d for %s/%s", i, card.name, card.type)

                local text = cell["card"..i.."Text"]
                text:SetText(card.name)
                text:Show()

                local image = cell["card"..i.."Image"]
                image:SetImage(Survivor.ICONS_BY_TYPE[card.type])
                image:Show()
            end
        end
    end

    -- prefer right
    for _, type in ipairs({ "Disorders", "Severe Injuries" }) do
        for _, card in ipairs(cardsByType[type]) do
            local i = PickIndex(right, left)
            if i then
                log:Debugf("Picked %d for %s/%s", i, card.name, card.type)

                local text = cell["card"..i.."Text"]
                text:SetText(card.name)
                text:Show()

                local image = cell["card"..i.."Image"]
                image:SetImage(Survivor.ICONS_BY_TYPE[card.type])
                image:Show()
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Survivor.HideCell(cell)
    log:Debugf("Hiding cell %d", cell.ordinal)
    cell.object.setScale({ x = 0.01, y = 0.01, z = 0.01 })
    cell.object.setRotation({ x = 0, y = 180, z = 0 })
    local pos = Survivor.CELL_POSITIONS[cell.ordinal]
    cell.object.setPosition({ x = pos.x, y = 0, z = pos.z })
    cell.survivor = nil
end

---------------------------------------------------------------------------------------------------

function Survivor.UpdateInputStat(thing, stat, value)
    thing[stat.."Input"]:SetText(value)
end

function Survivor.UpdateCheckBoxStat(thing, stat, value)
    local checkBox = thing[stat.."CheckBox"]
    if checkBox then
        checkBox:Check(value)
    end
end

function Survivor.UpdateCounterStat(thing, stat, value)
    -- pure hack since sheets update on modified stats while cells update on regular stats
    local counter = thing[stat.."Counter"]
    if counter then
        thing[stat.."Counter"]:SetText(value)
        if stat == "insanity" then
            if value >= 3 then
                thing[stat.."Counter"]:SetColor(Ui.LIGHT_RED)
            else
                thing[stat.."Counter"]:SetColor(Ui.LIGHT_BROWN)
            end
        end
    end
end

function Survivor.UpdateCheckBoxSequenceStat(thing, stat, value)
    for i = 1, value do
        thing[stat..i.."CheckBox"]:Check(true)
    end
    for i = value + 1, Survivor.CHECKBOX_SEQUENCE_MAXES[stat] do
        thing[stat..i.."CheckBox"]:Check(false)
    end
end

Survivor.statUpdaters = {
    ["name"] = Survivor.UpdateInputStat,
    ["weaponProficiencyType"] = Survivor.UpdateInputStat,
    ["notes1"] = Survivor.UpdateInputStat,
    ["notes2"] = Survivor.UpdateInputStat,
    ["notes3"] = Survivor.UpdateInputStat,
    ["notes4"] = Survivor.UpdateInputStat,
    ["notes5"] = Survivor.UpdateInputStat,

    ["brainInjury"] = Survivor.UpdateCheckBoxStat,
    ["male"] = Survivor.UpdateCheckBoxStat,
    ["female"] = Survivor.UpdateCheckBoxStat,
    ["reroll"] = Survivor.UpdateCheckBoxStat,
    ["skipNextHunt"] = Survivor.UpdateCheckBoxStat,
    ["retired"] = Survivor.UpdateCheckBoxStat,
    ["dead"] = Survivor.UpdateCheckBoxStat,

    ["survival"] = Survivor.UpdateCounterStat,
    ["insanity"] = Survivor.UpdateCounterStat,
    ["movement"] = Survivor.UpdateCounterStat,
    ["speed"] = Survivor.UpdateCounterStat,
    ["accuracy"] = Survivor.UpdateCounterStat,
    ["strength"] = Survivor.UpdateCounterStat,
    ["evasion"] = Survivor.UpdateCounterStat,
    ["luck"] = Survivor.UpdateCounterStat,
    ["modifiedMovement"] = Survivor.UpdateCounterStat,
    ["modifiedSpeed"] = Survivor.UpdateCounterStat,
    ["modifiedAccuracy"] = Survivor.UpdateCounterStat,
    ["modifiedStrength"] = Survivor.UpdateCounterStat,
    ["modifiedEvasion"] = Survivor.UpdateCounterStat,
    ["modifiedLuck"] = Survivor.UpdateCounterStat,

    ["huntXp"] = Survivor.UpdateCheckBoxSequenceStat,
    ["courage"] = Survivor.UpdateCheckBoxSequenceStat,
    ["understanding"] = Survivor.UpdateCheckBoxSequenceStat,
    ["weaponProficiencyRank"] = Survivor.UpdateCheckBoxSequenceStat,

    ["marker"] = function(thing, _, value)
        thing.markerButton:SetImage(value or Survivor.MARKER_EMPTY)
    end,
}

---------------------------------------------------------------------------------------------------

function Survivor.SpawnSurvivorBox(survivor, location)
    location = Location.Get(location)

    local survivorBox = Survivor.survivorBoxesBySurvivor[survivor]
    if survivorBox then
        Util.Highlight(survivorBox.object)
        --Util.LookAt({ object = survivorBox.object })
        return
    end

    local survivorSheet = Survivor.survivorSheetsBySurvivor[survivor]
    if survivorSheet then
        Util.Highlight(survivorSheet.object)
        --Util.LookAt({ object = survivorSheet.object })
        return
    end

    local blocking = location:BoxClean({ size = { x = 6, y = 5, z = 6 } })
    if #blocking > 0 then
        log:Broadcastf("Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        --location:LookAt()
        return
    end

    Archive.Take({
        name = "Survivor Box",
        type = "Survivor Box",
        location = location,
        rotation = { x = 0, y = 180, z = 0 },
        spawnFunc = function(survivorBoxObject)
            local survivorBox = SurvivorBoxClass.Create(survivor, survivorBoxObject)
            Survivor.survivorBoxesBySurvivor[survivor] = survivorBox
            Survivor.survivorBoxesByObject[survivorBoxObject] = survivorBox


            log:Debugf("Created survivor box %s for survivor %s", survivorBoxObject.getGUID(), survivor)

            -- Custom model boxes are mad sketchy the turn they come into play: they're treated as "Generic" not "Boxes" for 1 frame
            Wait.frames(function()
                -- Copy the cards table since we need to clear survivor cards before putting them into the box
                local cardsToSpawn = {}
                for _, card in ipairs(survivor:Cards()) do
                    table.insert(cardsToSpawn, card)
                end
                log:Debugf("%s cards to spawn: %s", survivor, cardsToSpawn)


                log:Debugf("Clearing %s cards", survivor)
                survivor:SetCards({})

                -- Spawn all cards
                local height = 3
                for _, card in ipairs(cardsToSpawn) do
                    Archive.Take({ archive = card.type.." Archive", name = card.name, type = card.type, location = location, height = height, spawnFunc = function(cardObject)
                        survivorBoxObject.putObject(cardObject)
                    end})
                    height = height + 0.5

                    -- Must clean up after each Take() since a survivor could have more than one of the same card
                    Archive.Clean()
                end

                --Util.LookAt({ object = survivorBoxObject })
            end, 1)

            Wait.frames(function()
                if survivor:FigurineJSON() then
                    local boxPosition = survivorBoxObject.getPosition()
                    boxPosition.y = boxPosition.y + 1
                    local figurineObject = spawnObjectJSON({json = survivor:FigurineJSON(), position = boxPosition})
                    survivorBoxObject.putObject(figurineObject)
                end
            end, 1)

            Wait.frames(function()
                if survivor:PortraitJSON() then
                    local boxPosition = survivorBoxObject.getPosition()
                    boxPosition.y = boxPosition.y + 1
                    local portraitObject = spawnObjectJSON({json = survivor:PortraitJSON(), position = boxPosition})
                    survivorBoxObject.putObject(portraitObject)
                end
            end, 1)

            Wait.frames(function()
                if survivor:BingoJSON() then
                    local boxPosition = survivorBoxObject.getPosition()
                    boxPosition.y = boxPosition.y + 1
                    local bingoObject = spawnObjectJSON({json = survivor:BingoJSON(), position = boxPosition})
                    survivorBoxObject.putObject(bingoObject)
                end
            end, 1)
        end,
    })
end

---------------------------------------------------------------------------------------------------

function SurvivorClass.Create(params)
    assert(Check.Num(params.id))

    local survivor = {
        id = params.id,
        name = params.name,
        marker = params.marker,
        male = params.male,
        female = params.female,
        reroll = params.reroll,
        skipNextHunt = params.skipNextHunt,
        inPlay = params.inPlay or false,
        retired = params.retired,
        dead = params.dead,
        survival = params.survival or 0,
        movement = params.movement or 5,
        speed = params.speed or 0,
        accuracy = params.accuracy or 0,
        strength = params.strength or 0,
        evasion = params.evasion or 0,
        modifiers = {
            movement = 0,
            speed = 0,
            accuracy = 0,
            strength = 0,
            evasion = 0,
            luck = 0,
        },
        luck = params.luck or 0,
        huntXp = params.huntXp or 0,
        insanity = params.insanity or 0,
        brainInjury = params.brainInjury,
        courage = params.courage or 0,
        understanding = params.understanding or 0,
        weaponProficiencyType = params.weaponProficiencyType,
        weaponProficiencyRank = params.weaponProficiencyRank or 0,
        notes1 = params.notes1,
        notes2 = params.notes2,
        notes3 = params.notes3,
        notes4 = params.notes4,
        notes5 = params.notes5,
        cards = params.cards or {},
        figurineJSON = params.figurineJSON,
        portraitJSON = params.portraitJSON,
        bingoJSON = params.bingoJSON,
        positionsByCardNameType = params.positionsByCardNameType or {},
    }
    setmetatable(survivor, SurvivorClass)

    log:Debugf("Created new %s", survivor)

    return survivor
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:__tostring()
    return Util.SafeFormat("SurvivorClass{id=%s,name=%s}", self.id, self:NameOrUnnamed())
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:Save()
    return {
        id = self.id,
        name = self.name,
        male = self.male,
        female = self.female,
        reroll = self.reroll,
        skipNextHunt = self.skipNextHunt,
        inPlay = self.inPlay,
        retired = self.retired,
        dead = self.dead,
        marker = self.marker,
        survival = self.survival,
        movement = self.movement,
        speed = self.speed,
        accuracy = self.accuracy,
        strength = self.strength,
        evasion = self.evasion,
        luck = self.luck,
        huntXp = self.huntXp,
        insanity = self.insanity,
        brainInjury = self.brainInjury,
        courage = self.courage,
        understanding = self.understanding,
        weaponProficiencyType = self.weaponProficiencyType,
        weaponProficiencyRank = self.weaponProficiencyRank,
        notes1 = self.notes1,
        notes2 = self.notes2,
        notes3 = self.notes3,
        notes4 = self.notes4,
        notes5 = self.notes5,
        cards = self.cards,
        figurineJSON = self.figurineJSON,
        portraitJSON = self.portraitJSON,
        bingoJSON = self.bingoJSON,
        positionsByCardNameType = self.positionsByCardNameType,
    }
end

-------------------------------------------------------------------------------------------------

function SurvivorClass:Id() return self.id end

---------------------------------------------------------------------------------------------------

function SurvivorClass:FireStatChangeEvent(stat, value)
    log:Debugf("Firing self stat change event for %s", stat)
    EventManager.FireEvent(EventManager.ON_SURVIVOR_STAT_CHANGED, self, stat, value)
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:SetStr(stat, value)
    assert(Check.Str(value))
    log:Debugf("Setting %s to %s for %s", stat, value, self)
    self[stat] = value
    self:FireStatChangeEvent(stat, value)
end

function SurvivorClass:Name() return self.name end
function SurvivorClass:NameOrUnnamed() return (self.name and self.name != "") and self.name or "Unnamed Survivor" end
function SurvivorClass:SetName(value) self:SetStr("name", value) end

function SurvivorClass:Marker() return self.marker end
function SurvivorClass:SetMarker(value) self:SetStr("marker", value) end

function SurvivorClass:WeaponProficiencyType() return self.weaponProficiencyType end
function SurvivorClass:SetWeaponProficiencyType(value) self:SetStr("weaponProficiencyType", value) end

function SurvivorClass:Notes1() return self.notes1 end
function SurvivorClass:SetNotes1(value) self:SetStr("notes1", value) end

function SurvivorClass:Notes2() return self.notes2 end
function SurvivorClass:SetNotes2(value) self:SetStr("notes2", value) end

function SurvivorClass:Notes3() return self.notes3 end
function SurvivorClass:SetNotes3(value) self:SetStr("notes3", value) end

function SurvivorClass:Notes4() return self.notes4 end
function SurvivorClass:SetNotes4(value) self:SetStr("notes4", value) end

function SurvivorClass:Notes5() return self.notes5 end
function SurvivorClass:SetNotes5(value) self:SetStr("notes5", value) end

---------------------------------------------------------------------------------------------------

function SurvivorClass:GetModified(stat) return self[stat] + self.modifiers[stat] end
function SurvivorClass:GetUnmodified(stat) return self[stat] end
function SurvivorClass:SetModified(stat, value)
    assert(Check.Num(value))
    log:Debugf("Setting %s to %d for %s", stat, value, self)
    self[stat] = value
    self:FireStatChangeEvent(stat, value)
    self:FireStatChangeEvent(Survivor.MODIFIED_STATS[stat], self[stat] + self.modifiers[stat])
end

function SurvivorClass:Movement() return self:GetUnmodified("movement") end
function SurvivorClass:ModifiedMovement() return self:GetModified("movement") end
function SurvivorClass:SetMovement(value) self:SetModified("movement", value) end

function SurvivorClass:Speed() return self:GetUnmodified("speed") end
function SurvivorClass:ModifiedSpeed() return self:GetModified("speed") end
function SurvivorClass:SetSpeed(value) self:SetModified("speed", value) end

function SurvivorClass:Accuracy() return self:GetUnmodified("accuracy") end
function SurvivorClass:ModifiedAccuracy() return self:GetModified("accuracy") end
function SurvivorClass:SetAccuracy(value) self:SetModified("accuracy", value) end

function SurvivorClass:Strength() return self:GetUnmodified("strength") end
function SurvivorClass:ModifiedStrength() return self:GetModified("strength") end
function SurvivorClass:SetStrength(value) self:SetModified("strength", value) end

function SurvivorClass:Evasion() return self:GetUnmodified("evasion") end
function SurvivorClass:ModifiedEvasion() return self:GetModified("evasion") end
function SurvivorClass:SetEvasion(value) self:SetModified("evasion", value) end

function SurvivorClass:Luck() return self:GetUnmodified("luck") end
function SurvivorClass:ModifiedLuck() return self:GetModified("luck") end
function SurvivorClass:SetLuck(value) self:SetModified("luck", value) end

---------------------------------------------------------------------------------------------------

function SurvivorClass:SetNum(stat, value, min, max)
    assert(Check.Num(value))
    if min != nil and value < min then
        value = min
    end
    if max != nil and value > max then
        value = max
    end
    log:Debugf("Setting %s to %s for %s", stat, value, self)
    self[stat] = value
    self:FireStatChangeEvent(stat, value)
end

function SurvivorClass:Survival() return self.survival end
function SurvivorClass:SetSurvival(value) self:SetNum("survival", value, 0) end

function SurvivorClass:Insanity() return self.insanity end
function SurvivorClass:SetInsanity(value) self:SetNum("insanity", value, 0) end

function SurvivorClass:HuntXp() return self.huntXp end
function SurvivorClass:SetHuntXp(value) self:SetNum("huntXp", value, 0, 16) end

function SurvivorClass:Courage() return self.courage end
function SurvivorClass:SetCourage(value) self:SetNum("courage", value, 0, 9) end

function SurvivorClass:Understanding() return self.understanding end
function SurvivorClass:SetUnderstanding(value) self:SetNum("understanding", value, 0, 9) end

function SurvivorClass:WeaponProficiencyRank() return self.weaponProficiencyRank end
function SurvivorClass:SetWeaponProficiencyRank(value) self:SetNum("weaponProficiencyRank", value, 0, 8) end

---------------------------------------------------------------------------------------------------

function SurvivorClass:SetBool(stat, value)
    assert(Check.BooleanOrNil(value))
    log:Debugf("Setting %s to %s for %s", stat, value and "true" or "false", self)
    self[stat] = value
    self:FireStatChangeEvent(stat, value)
end

function SurvivorClass:Dead() return self.dead end
function SurvivorClass:SetDead(value) self:SetBool("dead", value) end

function SurvivorClass:Retired() return self.retired end
function SurvivorClass:SetRetired(value) self:SetBool("retired", value) end

function SurvivorClass:BrainInjury() return self.brainInjury end
function SurvivorClass:SetBrainInjury(value) self:SetBool("brainInjury", value) end

function SurvivorClass:Male() return self.male end
function SurvivorClass:SetMale(value) self:SetBool("male", value) end

function SurvivorClass:Female() return self.female end
function SurvivorClass:SetFemale(value) self:SetBool("female", value) end

function SurvivorClass:Reroll() return self.reroll end
function SurvivorClass:SetReroll(value) self:SetBool("reroll", value) end

function SurvivorClass:SkipNextHunt() return self.skipNextHunt end
function SurvivorClass:SetSkipNextHunt(value) self:SetBool("skipNextHunt", value) end

function SurvivorClass:InPlay() return self.inPlay or false end
function SurvivorClass:SetInPlay(value) self.inPlay = value end

---------------------------------------------------------------------------------------------------

function SurvivorClass:Cards() return self.cards end
function SurvivorClass:SetCards(cards)
    self.cards = cards
    EventManager.FireEvent(EventManager.ON_SURVIVOR_CARDS_CHANGED, self)
end

function SurvivorClass:PositionsByCardNameType() return self.positionsByCardNameType end
function SurvivorClass:SetPositionsByCardNameType(positionsByCardNameType) self.positionsByCardNameType = positionsByCardNameType end

---------------------------------------------------------------------------------------------------

function SurvivorClass:FigurineJSON() return self.figurineJSON end
function SurvivorClass:SetFigurineJSON(value)
    self.figurineJSON = value
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:PortraitJSON() return self.portraitJSON end
function SurvivorClass:SetPortraitJSON(value)
    self.portraitJSON = value
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:BingoJSON() return self.bingoJSON end
function SurvivorClass:SetBingoJSON(value)
    self.bingoJSON = value
end

---------------------------------------------------------------------------------------------------

function SurvivorClass:SetModifiers(modifiers)
    modifiers = modifiers or {}

    for _, stat in ipairs({ "movement", "speed", "accuracy", "strength", "evasion", "luck" }) do
        local oldValue = self:GetModified(stat)
        self.modifiers[stat] = modifiers[stat] or 0
        local newValue = self:GetModified(stat)
        log:Debugf("Changed modified %s from %d to %d for %s", stat, oldValue, newValue, self)
        if newValue != oldValue then
            EventManager.FireEvent(EventManager.ON_SURVIVOR_STAT_CHANGED, self, Survivor.MODIFIED_STATS[stat], newValue)
        end
    end
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass.Create(survivor, object)
    assert(SurvivorClass.Is(survivor))
    assert(Check.Object(object))

    log:Debugf("Creating SurvivorBoxClass for %s", survivor)

    local survivorBox = {
        survivor = survivor,
        object = object,
    }
    setmetatable(survivorBox, SurvivorBoxClass)

    survivorBox.object.setName(survivor:NameOrUnnamed())

    survivorBox.ui = Ui.Create3d("survivorBox"..object.getGUID(), object, 0.22)
    survivorBox.nameText = survivorBox.ui:Text({ id = "Name", topLeft = { x = 0.946971, y = -0.948742 }, bottomRight = { x = -0.946971, y = -0.52 }, text = Util.TruncateString(survivor:NameOrUnnamed(), 20), fontSize = 180, alignment = "MiddleCenter" })
    survivorBox.ui:ApplyToObject()


    return survivorBox
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:__tostring()
    return Util.SafeFormat("SurvivorBoxClass{survivor=%s,object=%s}", self.survivor:NameOrUnnamed(), self.object.getGUID())
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:Save()
    return {
        survivorId = self.survivor:Id(),
        objectGuid = self.object.getGUID(),
    }
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:Survivor()
    return self.survivor
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:Object()
    return self.object
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:SetName(name)
    self.object.setName(name)
    self.nameText:SetText(Util.TruncateString(name, 20))
end

---------------------------------------------------------------------------------------------------

function SurvivorBoxClass:UpdateCards()
    local cards = {}
    for _, objectInBox in ipairs(self.object.getObjects()) do
        if Survivor.ALLOWED_CARD_TYPES[objectInBox.gm_notes] then
            table.insert(cards, { name = objectInBox.name, type = objectInBox.gm_notes })
        end
    end
    log:Debugf("Updated %s cards", self)
    self.survivor:SetCards(cards)
end

---------------------------------------------------------------------------------------------------

function SurvivorSheetClass.Create(survivor, object)
    log:Debugf("Creating survivor sheet for %s and object %s", survivor, object.getGUID())

    local survivorSheet = {
        survivor = survivor,
        object = object,
    }
    setmetatable(survivorSheet, SurvivorSheetClass)

    local ui = Ui.Create3d("survivorSheet"..object.getGUID(), survivorSheet.object, 0.11)
    survivorSheet.ui = ui

    survivorSheet.survivalCounter = ui:Counter({ id = "survival", topLeft = { x = 0.711521, y = -0.936434 }, bottomRight = { x = 0.426820, y = -0.659977 }, fontSize = 190, text = survivor:Survival(), onValueChanged = function(delta)
        survivorSheet.survivor:SetSurvival(survivorSheet.survivor:Survival() + delta)
    end })

    survivorSheet.insanityCounter = ui:Counter({ id = "insanity", topLeft = { x = -0.430935, y = -0.938893 }, bottomRight = { x = -0.709772, y = -0.663436 }, fontSize = 190, text = survivor:Insanity(), onValueChanged = function(delta)
        local newValue = survivorSheet.survivor:Insanity() + delta
        survivorSheet.survivor:SetInsanity(newValue)
    end })

    for stat, data in pairs({
        ["movement"] = { topLeft = { x =  0.340122, y = -0.938595 }, bottomRight = { x =  0.140848, y = -0.748847 } },
        ["speed"]    = { topLeft = { x =  0.096356, y = -0.938595 }, bottomRight = { x = -0.094326, y = -0.748847 } },
        ["accuracy"] = { topLeft = { x = -0.146921, y = -0.938595 }, bottomRight = { x = -0.340642, y = -0.748847 } },
        ["strength"] = { topLeft = { x =  0.340122, y = -0.628745 }, bottomRight = { x =  0.140848, y = -0.438532 } },
        ["evasion"]  = { topLeft = { x =  0.096356, y = -0.628745 }, bottomRight = { x = -0.094326, y = -0.438532 } },
        ["luck"]    = { topLeft = { x =  -0.146921, y = -0.628745 }, bottomRight = { x = -0.340642, y = -0.438532 } },
    }) do
        survivorSheet["modified"..Util.Capitalize(stat).."Counter"] = ui:Counter({ id = stat, topLeft = data.topLeft, bottomRight = data.bottomRight, fontSize = 130, text = survivor:GetModified(stat), onValueChanged = function(delta)
            survivorSheet.survivor:SetModified(stat, survivorSheet.survivor[stat] + delta)
        end })
    end

    survivorSheet.markerButton = ui:Button({ id = "marker", topLeft = { x = 0.711521, y = -0.535331 }, bottomRight = { x = 0.426820, y = -0.366424 }, image = survivor.marker or Survivor.MARKER_EMPTY, onClick = function(button)
        local value = survivorSheet.survivor:Marker() or Survivor.MARKER_EMPTY
        if button == Ui.LEFT_MOUSE_BUTTON then
            value = Survivor.NEXT_MARKER[value]
        else
            value = Survivor.PREV_MARKER[value]
        end
        survivorSheet.survivor:SetMarker(value)
    end })

    survivorSheet.brainInjuryCheckBox = ui:CheckBox({ id = "brainInjury", topLeft = { x = -0.520929, y = -0.527068 }, bottomRight = { x = -0.628231, y = -0.419554 }, checked = survivor.brainInjury, onClick = function()
        local value = survivorSheet.survivor:BrainInjury()
        survivorSheet.survivor:SetBrainInjury(not value)
    end })

    survivorSheet.nameInput = ui:Input({ id = "name", topLeft = { x = 0.532309, y = -0.344423 }, bottomRight = { x = -0.713491, y = -0.238286 }, fontSize = 80, placeholder = "Unnamed Survivor", text = survivor:Name(), onValueChanged = function(value)
        survivorSheet.survivor:SetName(value)
    end })

    local smallCheckBoxSize = 0.055
    local bigCheckBoxSize = 0.0623

    for stat, topLeft in pairs({
        ["male"] = { x = 0.714648, y = -0.203562 },
        ["female"] = { x = 0.570787, y = -0.203562 },
        ["reroll"] = { x = 0.438556, y = -0.203562 },
        ["skipNextHunt"] = { x = 0.145875, y = -0.203562 },
        ["retired"] = { x = -0.227551, y = -0.203562 },
        ["dead"] = { x = -0.484378, y = -0.203562 },
    }) do
        survivorSheet[stat.."CheckBox"] = ui:CheckBox({ id = stat, topLeft = topLeft, bottomRight = { x = topLeft.x - smallCheckBoxSize, y = topLeft.y + smallCheckBoxSize }, checked = survivor[stat], onClick = function()
            survivorSheet.survivor:SetBool(stat, not survivorSheet.survivor[stat])
        end })
    end

    for stat, seq in pairs({
        ["huntXp"] = {
            { topLeft = { x = 0.453219, y = -0.068927 }, big = false },
            { topLeft = { x = 0.382765, y = -0.073718 }, big = true },
            { topLeft = { x = 0.299559, y = -0.068927 }, big = false },
            { topLeft = { x = 0.230707, y = -0.068927 }, big = false },
            { topLeft = { x = 0.160401, y = -0.068927 }, big = false },
            { topLeft = { x = 0.091089, y = -0.073718 }, big = true },
            { topLeft = { x = 0.005319, y = -0.068927 }, big = false },
            { topLeft = { x = -0.061338, y = -0.068927 }, big = false },
            { topLeft = { x = -0.132377, y = -0.068927 }, big = false },
            { topLeft = { x = -0.202206, y = -0.073718 }, big = true },
            { topLeft = { x = -0.287922, y = -0.068927 }, big = false },
            { topLeft = { x = -0.356490, y = -0.068927 }, big = false },
            { topLeft = { x = -0.421105, y = -0.068927 }, big = false },
            { topLeft = { x = -0.489654, y = -0.068927 }, big = false },
            { topLeft = { x = -0.559425, y = -0.073718 }, big = true },
            { topLeft = { x = -0.646168, y = -0.073718 }, big = true },
        },
        ["courage"] = {
            { topLeft = { x = 0.710780, y = 0.150083 }, big = false },
            { topLeft = { x = 0.640421, y = 0.150083 }, big = false },
            { topLeft = { x = 0.570907, y = 0.146450 }, big = true },
            { topLeft = { x = 0.490000, y = 0.150083 }, big = false },
            { topLeft = { x = 0.420000, y = 0.150083 }, big = false },
            { topLeft = { x = 0.353000, y = 0.150083 }, big = false },
            { topLeft = { x = 0.285000, y = 0.150083 }, big = false },
            { topLeft = { x = 0.213460, y = 0.150083 }, big = false },
            { topLeft = { x = 0.142766, y = 0.146450 }, big = true },
        },
        ["understanding"] = {
            { topLeft = { x = -0.073370, y = 0.150083 }, big = false },
            { topLeft = { x = -0.145900, y = 0.150083 }, big = false },
            { topLeft = { x = -0.219752, y = 0.146450 }, big = true },
            { topLeft = { x = -0.297472, y = 0.150083 }, big = false },
            { topLeft = { x = -0.366772, y = 0.150083 }, big = false },
            { topLeft = { x = -0.436125, y = 0.150083 }, big = false },
            { topLeft = { x = -0.501339, y = 0.150083 }, big = false },
            { topLeft = { x = -0.572758, y = 0.150083 }, big = false },
            { topLeft = { x = -0.646109, y = 0.146450 }, big = true },
        },
        ["weaponProficiencyRank"] = {
            { topLeft = { x = 0.710780, y = 0.370248 }, big = false },
            { topLeft = { x = 0.640421, y = 0.370248 }, big = false },
            { topLeft = { x = 0.570907, y = 0.364543 }, big = true },
            { topLeft = { x = 0.490000, y = 0.370248 }, big = false },
            { topLeft = { x = 0.420000, y = 0.370248 }, big = false },
            { topLeft = { x = 0.353000, y = 0.370248 }, big = false },
            { topLeft = { x = 0.285000, y = 0.370248 }, big = false },
            { topLeft = { x = 0.210000, y = 0.364543 }, big = true },
        }
    }) do
        local value = survivorSheet.survivor[stat]
        for i, data in ipairs(seq) do
            local bottomRight = { x = data.topLeft.x, y = data.topLeft.y }
            if data.big then
                bottomRight.x = bottomRight.x - bigCheckBoxSize
                bottomRight.y = bottomRight.y + bigCheckBoxSize
            else
                bottomRight.x = bottomRight.x - smallCheckBoxSize
                bottomRight.y = bottomRight.y + smallCheckBoxSize
            end

            local stati = stat..i
            survivorSheet[stati.."CheckBox"] = ui:CheckBox({ id = stati, topLeft = data.topLeft, bottomRight = bottomRight, checked = (value >= i), onClick = function()
                local value = i
                if survivorSheet.survivor[stat] >= i then
                    value = value - 1
                end
                survivorSheet.survivor:SetNum(stat, value)
            end })
        end
    end

    survivorSheet.weaponProficiencyTypeInput = ui:Input({ id = "weaponProficiencyType", topLeft = { x = -0.074150, y = 0.357813 }, bottomRight = { x = -0.714426, y = 0.422490 }, fontSize = 50, text = survivor.weaponProficiencyType, onValueChanged = function(value)
        survivorSheet.survivor:SetWeaponProficiencyType(value)
    end })

    for i, data in pairs({
        { topLeft = { x = 0.715, y = 0.558 }, bottomRight = { x = -0.708, y = 0.626 } },
        { topLeft = { x = 0.715, y = 0.650 }, bottomRight = { x = -0.708, y = 0.718 } },
        { topLeft = { x = 0.715, y = 0.736 }, bottomRight = { x = -0.708, y = 0.804 } },
        { topLeft = { x = 0.715, y = 0.825 }, bottomRight = { x = -0.708, y = 0.893 } },
        { topLeft = { x = 0.715, y = 0.913 }, bottomRight = { x = -0.708, y = 0.981 } },
    }) do
        local notesi = "notes"..i
        survivorSheet[notesi.."Input"] = ui:Input({ id = notesi, topLeft = data.topLeft, bottomRight = data.bottomRight, fontSize = 50, text = survivor[notesi], onValueChanged = function(value)
            survivorSheet.survivor["SetNotes"..i](survivorSheet.survivor, value)
        end })
    end

    survivorSheet.object.UI.setCustomAssets(Survivor.CUSTOM_ASSETS)
    survivorSheet.ui:ApplyToObject()

    return survivorSheet
end

---------------------------------------------------------------------------------------------------

function SurvivorSheetClass:__tostring()
    return Util.SafeFormat("SurvivorSheet{survivor=%s,object=%s}", self.survivor:NameOrUnnamed(), self.object.getGUID())
end

---------------------------------------------------------------------------------------------------

function SurvivorSheetClass:Save()
    return {
        survivorId = self.survivor.id,
        objectGuid = self.object.getGUID(),
    }
end

---------------------------------------------------------------------------------------------------

function SurvivorSheetClass:Survivor() return self.survivor end
function SurvivorSheetClass:Object() return self.object end

---------------------------------------------------------------------------------------------------

return {
    Init = Survivor.Init,
    PostInit = Survivor.PostInit,
    Save = Survivor.Save,
    Import = Survivor.Import,
    Export = Survivor.Export,

    Survivors = function() return Survivor.survivors end,

    SurvivorForId = function(id) return Survivor.survivorsById[id] end,
    SurvivorBoxForSurvivor = function(survivor) return Survivor.survivorBoxesBySurvivor[survivor] end,
    SurvivorBoxForObject = function(object) return Survivor.survivorBoxesByObject[object] end,
    SurvivorSheetForSurvivor = function(survivor) return Survivor.survivorSheetsBySurvivor[survivor] end,
    SurvivorSheetForObject = function(object) return Survivor.survivorSheetsByObject[object] end,

    CreateSurvivorSheet = function(survivor, object)
        local survivorSheet = SurvivorSheetClass.Create(survivor, object)
        Survivor.survivorSheetsBySurvivor[survivor] = survivorSheet
        Survivor.survivorSheetsByObject[object] = survivorSheet
        EventManager.FireEvent(EventManager.ON_SURVIVOR_GETS_IN_PLAY, survivor)
        return survivorSheet
    end,

    ALLOWED_CARD_TYPES = Survivor.ALLOWED_CARD_TYPES,
}

end)
__bundle_register("Kdm/MessageBox", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Ui = require("Kdm/Ui")

---------------------------------------------------------------------------------------------------

local MessageBox = {}

MessageBox.func = nil

---------------------------------------------------------------------------------------------------

function MessageBox.Init()
    local ui = Ui.Get2d()
    MessageBox.ui = ui

    local panel = ui:Panel({ id = "Main", rectAlignment = "MiddleCenter", x = 0, y = 0, z = -10, width = 300, height = 150, active = false })
    MessageBox.panel = panel

    panel:Image({ id = "Main", x = 0, y = 0, width = 300, height = 150, image = "MessageBox" })

    MessageBox.messageText = panel:Text({ id = "Message", rectAlignment = "LowerCenter", x = 0, y = 60, width = 220, height = 85, alignment = "MiddleCenter", fontSize = 18, horizontalOverflow = "Truncate", verticalOverflow = "Truncate" })

    panel:Button({ id = "OK", rectAlignment = "LowerLeft", x = 33, y = 20, width = 100, height = 30, onClick = function()
        MessageBox.Hide()
        if MessageBox.func then
            MessageBox.func()
        end
    end })

    panel:Button({ id = "Cancel", rectAlignment = "LowerLeft", x = 167, y = 20, width = 100, height = 30, onClick = function()
        MessageBox.Hide()
    end })
end

---------------------------------------------------------------------------------------------------

function MessageBox.Show(text, func)
    assert(Check.Str(text))
    assert(Check.Func(func))

    MessageBox.func = func
    MessageBox.messageText:SetText(text)
    MessageBox.panel:Show()
end

---------------------------------------------------------------------------------------------------

function MessageBox.Hide()
    MessageBox.panel:Hide()
end

---------------------------------------------------------------------------------------------------

return {
    Init = MessageBox.Init,
    Show = MessageBox.Show,
    Hide = MessageBox.Hide,
}

end)
__bundle_register("Kdm/Armor", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Expansion = require("Kdm/Expansion")

---------------------------------------------------------------------------------------------------

local Armor = {}
Armor.__index = Armor

---------------------------------------------------------------------------------------------------

function Armor.Init(saveState)
    Armor.armor = {}
    for _, expansion in ipairs(Expansion.All()) do
        for name, stats in pairs(expansion.armorStats or {}) do
            if Armor.armor[name] then
                assert(false, string.format("Armor %s was already registered by expansion %s", name, Armor.armor[name].expansion))
            end
            Armor.armor[name] = Armor.Create(name, expansion.name, stats)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Armor.Get(armor)
    return Armor.armor[armor]
end

---------------------------------------------------------------------------------------------------

function Armor.Create(name, expansion, stats)
    assert(Check.Str(name))
    assert(Check.Str(expansion))
    assert(Check.Num(stats.head))
    assert(Check.Num(stats.arms))
    assert(Check.Num(stats.body))
    assert(Check.Num(stats.waist))
    assert(Check.Num(stats.legs))

    local armor = {
        name = name,
        expansion = expansion,
        head = stats.head,
        arms = stats.arms,
        body = stats.body,
        waist = stats.waist,
        legs = stats.legs,
        modifier = stats.modifier,
    }
    setmetatable(armor, Armor)

    return armor
end

---------------------------------------------------------------------------------------------------

function Armor:__tostring()
    return string.format("%s (%d/%d/%d/%d/%d)", self.name, self.head, self.arms, self.body, self.waist, self.legs)
end

---------------------------------------------------------------------------------------------------

return {
    Init = Armor.Init,
    Get = Armor.Get,
}

end)
__bundle_register("Kdm/Util/Overlay", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local Grid = require("Kdm/Util/Grid")
local log = require("Kdm/Log").ForModule("Overlay")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local OverlayClass = {}
OverlayClass.__index = OverlayClass

---------------------------------------------------------------------------------------------------

function OverlayClass.Create(params)
    assert(Check.Object(params.object))
    assert(Grid.Is(params.grid))
    assert(Check.Num(params.height))

    local overlay = {
        object = params.object,
        grid = params.grid,
        height = params.height,
    }
    setmetatable(overlay, OverlayClass)

    return overlay
end

---------------------------------------------------------------------------------------------------

local function Overlay_Dud() end

function OverlayClass:ClampAndAddRect(left, top, width, height, color)
    local grid = self.grid

    -- inclusive
    local right = left + width - 1
    local bottom = top + height - 1

    if left < 0 then left = 0 end
    if right >= grid:Cols() then right = grid:Cols() - 1 end
    if top < 0 then top = 0 end
    if bottom >= grid:Rows() then bottom = grid:Rows() - 1 end

    width = right - left + 1
    height = bottom - top + 1
    if width <= 0 or height <= 0 then
        return
    end

    local centerCol = left + (right - left) / 2
    local centerRow = top + (bottom - top) / 2
    local x, z = grid:XZ(centerCol, centerRow)
    local l = self.object.positionToLocal(grid:Object().positionToWorld({ x, self.height, z }))
    local squareSize = 10900    -- this depends on the size/scale of the underlying object, it should be a parameter not hard-coded
    self.object.createButton({
        function_owner = self,
        position = { x = -l.x, y = l.y, z = l.z },
        scale = { x = 0.1, y = 0.1, z = 0.1 },
        width = squareSize * width,
        height = squareSize * height,
        color = color,
        hover_color = color,
        press_color = color,
        click_function = "Overlay_Dud",
    })
end

---------------------------------------------------------------------------------------------------

function OverlayClass:Show(position, baseSize, radius, color)
    assert(Check.Vec3(position, "position"))
    assert(Check.Num(baseSize, "baseSize"))
    assert(Check.Num(radius, "radius"))
    assert(Check.Color(color, "color"))

    self:Hide()

    -- the movement overlay looks like a diamond
    -- we want to draw this diamond using as few squares as possible, since each square must be represented by a button
    -- and they're slow to create and destroy (pickup/drop will lag)
    -- all of the following math is to construct the smallest number of squares for a given movement overlay.
    -- there's one big central square, then rectangles on the top/bottom/left/right that get progressively smaller and taper off to zero.

    local localPosition = self.object.positionToLocal(position)
    local centerCol, centerRow = self.grid:ColRow(localPosition)
    log:Debugf("center: %d, %d", centerCol, centerRow)
    local baseLeft, baseTop  -- left-top corner of the figurine's base (1x1, 2x2, 3x3, etc)
    if baseSize % 2 == 0 then
        local offset = math.floor(baseSize / 2) - 1
        baseLeft = math.floor(centerCol) - offset
        baseTop = math.floor(centerRow) - (baseSize / 2) + 1
    else
        local offset = math.floor(baseSize / 2)
        baseLeft = math.floor(centerCol + 0.5) - offset
        baseTop = math.floor(centerRow + 0.5) - offset
    end
    log:Debugf("base LT: %d, %d", baseLeft, baseTop)

    local halfRadius = math.floor(radius / 2)

    -- "big" is the big central square of the movement overlay
    local bigLeft = baseLeft - halfRadius
    local bigRight = baseLeft + (baseSize - 1) + halfRadius
    local bigTop = baseTop - halfRadius
    local bigBottom = baseTop + (baseSize - 1) + halfRadius

    local size = baseSize + (2 * halfRadius)

    self:ClampAndAddRect(bigLeft, bigTop, size, size, color)

    local distance = 1
    local offset = 0
    if radius % 2 == 0 then
        size = size - 2
        offset = 1
    end
    while size >= baseSize do
        -- left
        self:ClampAndAddRect(bigLeft - distance, bigTop + offset, 1, size, color)
        -- top
        self:ClampAndAddRect(bigLeft + offset, bigTop - distance, size, 1, color)
        -- right
        self:ClampAndAddRect(bigRight + distance, bigTop + offset, 1, size, color)
        -- bottom
        self:ClampAndAddRect(bigLeft + offset, bigBottom + distance, size, 1, color)

        size = size - 2
        distance = distance + 1
        offset = offset + 1
    end
end

---------------------------------------------------------------------------------------------------

function OverlayClass:Hide()
    self.object.clearButtons()
end

---------------------------------------------------------------------------------------------------

return {
    Create = OverlayClass.Create,
    Is = function(x) return getmetatable(x) == OverlayClass end,
}

end)
__bundle_register("Kdm/Util/Grid", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")

---------------------------------------------------------------------------------------------------

local GridClass = {}
GridClass.__index = GridClass

---------------------------------------------------------------------------------------------------

function GridClass.Create(params)
    local object, left, right, top, bottom, cols, rows = params.object, params.left, params.right, params.top, params.bottom, params.cols, params.rows
    assert(Check.Object(object))
    assert(Check.Num(left))
    assert(Check.Num(right))
    assert(Check.Num(top))
    assert(Check.Num(bottom))
    assert(Check.Num(cols))
    assert(Check.Num(rows))

    local grid = {
        object = object,

        left = left,
        right = right,
        top = top,
        bottom = bottom,

        cols = cols,
        rows = rows,

        colSize = (right - left) / (cols - 1),
        rowSize = (bottom - top) / (rows - 1),
    }
    setmetatable(grid, GridClass)

    return grid
end


---------------------------------------------------------------------------------------------------

function GridClass:Cols() return self.cols end
function GridClass:Rows() return self.rows end
function GridClass:Object() return self.object end

---------------------------------------------------------------------------------------------------

function GridClass:ColRow(position)
    local col = (position.x - self.left) / self.colSize
    local row = (position.z - self.top) / self.rowSize
    return col, row
end

---------------------------------------------------------------------------------------------------

function GridClass:XZ(col, row)
    local x = self.left + (col * self.colSize)
    local z = self.top + (row * self.rowSize)
    return x, z
end

---------------------------------------------------------------------------------------------------

function GridClass:Snap(object, size)
    assert(Check.Object(object))
    assert(Check.Vec2(size))

    local width, height = size.x, size.y

    local y = object.getRotation().y
    -- sideways = swap width/height
    if (y > 45 and y < 135) or (y > 225 and y < 315) then
        width, height = height, width
    end

    local wpos = object.getPosition()
    local lpos = self.object.positionToLocal(wpos)
    local col, row = self:ColRow(lpos)

    -- even size, snap to grid intersections (0.5, 1.5, 2.5, ...)
    -- odd size, snap to grid cell centers (1.0, 2.0, 3.0, ...)
    local snapCol = (width % 2 == 0) and math.floor(col) + 0.5 or math.floor(col + 0.5)
    local snapRow = (height % 2 == 0) and math.floor(row) + 0.5 or math.floor(row + 0.5)

    local epsilon = 0.001
    local wradius = width / 2
    local hradius = height / 2
    if
        (snapCol - wradius) < -0.5 - epsilon or
        (snapCol + wradius) >= self.cols + epsilon or
        (snapRow - hradius) < -0.5 - epsilon or
        (snapRow + hradius) >= self.rows + epsilon then
        return wpos
    end

    local snapX, snapZ = self:XZ(snapCol, snapRow)

    return self.object.positionToWorld({
        x = snapX,
        y = lpos.y,
        z = snapZ,
    })
end

---------------------------------------------------------------------------------------------------

return {
    Create = GridClass.Create,
    Is = function(x) return getmetatable(x) == GridClass end,
}

end)
__bundle_register("Kdm/Monster", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Monster")
local NamedObject = require("Kdm/NamedObject")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Monster = {}

Monster.STATS = {
    ["movement"] = true,
    ["toughness"] = true,
    ["damage"] = true,
    ["speed"] = true,
    ["accuracy"] = true,
    ["evasion"] = true,
    ["luck"] = true,
}

Monster.TOKEN_STATS = {
    ["Movement Token"] = "movement",
    ["Toughness Token"] = "toughness",
    ["Damage Token"] = "damage",
    ["Speed Token"] = "speed",
    ["Accuracy Token"] = "accuracy",
    ["Evasion Token"] = "evasion",
    ["Luck Token"] = "luck",
}

---------------------------------------------------------------------------------------------------


function Monster.Init(saveState)
    Monster.boardObject = NamedObject.Get("Showdown Board")

    Monster.stats = {}
    Monster.tokenStats = {}
    for stat, _ in pairs(Monster.STATS) do
        Monster.stats[stat] = saveState[stat] or 0
        Monster.tokenStats[stat] = 0
    end

    -----------------------------------------------------------------------------------------------

    local ui = Ui.Create3d("Monster", Monster.boardObject, 10.74)
    Monster.ui = ui

    Monster.statCounters = {}
    local x = -6.264187
    local xEnd = -6.628941
    local width = xEnd - x
    local y1 = 1.288212
    local y1End = 1.649527
    local height = y1End - y1
    local y7 = 4.921028
    local dy = (y7 - y1) / 6
    for i, stat in ipairs({
        "movement",
        "toughness",
        "damage",
        "speed",
        "accuracy",
        "evasion",
        "luck",
    }) do
        local y = y1 + (i - 1) * dy
        Monster.statCounters[stat] = ui:Counter({ id = stat, topLeft = { x = x, y = y }, bottomRight = { x = x + width, y = y + height }, fontSize = 260, text = Monster.Stat(stat), onValueChanged = function(delta)
            Monster.SetStat(stat, Monster.stats[stat] + delta)
        end })
    end

    ui:ApplyToObject()

    -----------------------------------------------------------------------------------------------

    local monsterTokensLocation = Location.Get("Monster Tokens")
    monsterTokensLocation:AddDropHandler(function(object)
        Monster.UpdateStats()
    end)
    monsterTokensLocation:AddPickUpHandler(function(object)
        if object and object.getGMNotes() == "Tokens" and Monster.TOKEN_STATS[object.getName()] then
            log:Debugf("Unregistering token [%s]%s for collisions", object.getGUID(), object.getName())
            object.unregisterCollisions()
        end
        Monster.UpdateStats()
    end)

    EventManager.AddHandler("onObjectCollisionEnter", Monster.OnObjectCollisionEnter)
end

---------------------------------------------------------------------------------------------------

function Monster.PostInit()
    Monster.UpdateStats()
end

---------------------------------------------------------------------------------------------------

function Monster.Save()
    local saveState = {}
    for stat, _ in pairs(Monster.STATS) do
        saveState[stat] = Monster.stats[stat] or 0
    end
    return saveState
end

---------------------------------------------------------------------------------------------------

function Monster.Stat(stat)
    assert(Check(Monster.STATS[stat]))
    return Monster.stats[stat] + Monster.tokenStats[stat]
end

---------------------------------------------------------------------------------------------------

function Monster.SetStat(stat, value)
    assert(Check(Monster.STATS[stat], "Unrecognized stat %s", stat))
    assert(Check.Num(value))

    log:Debugf("Setting monster stat %s to %d", stat, value)

    if Monster.stats[stat] != value then
        Monster.stats[stat] = value
        local newValue = Monster.Stat(stat)
        Monster.statCounters[stat]:SetText(newValue)
        EventManager.FireEvent(EventManager.ON_MONSTER_STAT_CHANGED, stat, newValue)
    end
end

---------------------------------------------------------------------------------------------------

function Monster.UpdateStats()
    local tokenStats = {}

    for _, object in ipairs(Location.Get("Monster Tokens"):AllObjects()) do
        local stat = Monster.TOKEN_STATS[object.getName()]
        if object.getGMNotes() == "Tokens" and stat then
            local value = Util.TokenValue(object)
            log:Debugf("Found token [%s]%s with value %d", object.getGUID(), object.getName(), value)
            tokenStats[stat] = (tokenStats[stat] or 0) + value
            object.registerCollisions()
        end
    end

    Monster.UpdateTokenStats(tokenStats)
end

---------------------------------------------------------------------------------------------------

function Monster.UpdateTokenStats(tokenStats)
    for stat, _ in pairs(Monster.STATS) do
        local tokenStat = tokenStats[stat] or 0
        if Monster.tokenStats[stat] != tokenStat then
            Monster.tokenStats[stat] = tokenStat
            local newValue = Monster.Stat(stat)
            log:Debugf("Updating monster stat %s to %d", stat, newValue)
            Monster.statCounters[stat]:SetText(newValue)
            EventManager.FireEvent(EventManager.ON_MONSTER_STAT_CHANGED, stat, newValue)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Monster.OnObjectCollisionEnter(object, collisionInfo)
    -- This is a hack to detect flipped tokens
    -- There's no onFlip event, and flipping doesn't trigger onPickUp, so we rely on this to detect flips
    -- of *already registered* tokens.

    local collisionObject = collisionInfo.collision_object
    if collisionObject != Monster.boardObject then
        return
    end

    log:Debugf("[%s]%s collided with [%s]%s", object.getGUID(), object.getName(), collisionObject.getGUID(), collisionObject.getName())

    local monsterTokensLocation = Location.Get("Monster Tokens")
    for _, location in ipairs(Location.ObjectLocations(object)) do
        if location == monsterTokensLocation then
            log:Debugf("Token [%s]%s found in %s, updating stats", object.getGUID(), object.getName(), location)
            Monster.UpdateStats()
        end
    end
end

---------------------------------------------------------------------------------------------------

return {
    Init      = Monster.Init,
    PostInit  = Monster.PostInit,
    Save      = Monster.Save,
    Movement  = function() return Monster.Stat("movement") end,
    Toughness = function() return Monster.Stat("toughness") end,
    Damage    = function() return Monster.Stat("damage") end,
    Speed     = function() return Monster.Stat("speed") end,
    Accuracy  = function() return Monster.Stat("accuracy") end,
    Evasion   = function() return Monster.Stat("evasion") end,
    Luck      = function() return Monster.Stat("luck") end,
    SetStat   = Monster.SetStat,
}

end)
__bundle_register("Kdm/Hunt", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Hunt")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Hunt = {}

---------------------------------------------------------------------------------------------------

function Hunt.Init()
    Hunt.monsters = {}
    Hunt.expansionsByMonsterName = {}
    Hunt.monstersByMonsterName = {}
    Hunt.levelsByMonsterLevelName = {}
    for _, expansion in ipairs(Expansion.All()) do
        for _, monster in ipairs(expansion.monsters or {}) do
            Hunt.monstersByMonsterName[monster.name] = monster
            if monster.huntTrack then
                local levels = {}
                for _, level in ipairs(monster.levels) do
                    if level.monsterHuntPosition then
                        table.insert(levels, level)
                    end
                    Hunt.levelsByMonsterLevelName[monster.name..level.name] = level
                end
                local huntSetup = {
                    name = monster.name,
                    huntTrack = monster.huntTrack,
                    huntEventsDeck = monster.huntEventsDeck or monster.name.." Hunt Events",
                    levels = levels,
                    levelMap = levelMap,
                }
                if monster.resourcesDeck != false then
                    huntSetup.resourcesDeck = monster.resourcesDeck or monster.name.." Resources"
                end
                table.insert(Hunt.monsters, huntSetup)
                Hunt.expansionsByMonsterName[monster.name] = expansion
            end
        end
    end
    table.sort(Hunt.monsters, function(x, y) return x.name < y.name end)

    -----------------------------------------------------------------------------------------------

    Hunt.uiOpen = false

    local ui = Ui.Get2d()

    local panel = ui:Panel({ id = "Hunt", rectAlignment = "MiddleCenter", x = 0, y = 0, width = 667, height = 632, active = false })
    Hunt.panel = panel
    panel:Image({ id = "Hunt", image = "Hunt", x = 0, y = 0, width = 667, height = 632 })

    panel:Button({ id = "Close", x = 627, y = -10, width = 30, height = 30, onClick = function(mouseButton, player) Hunt.HideUi(player) end })

    local monsterScroll = panel:VerticalScroll({ id = "V", x = 20+3, y = -(109+3), width = 306-6, height = 216-6 })
    local monsterPanel = monsterScroll:Panel({ id = "Monster", x = 0, y = 0, width = 280, height = #Hunt.monsters * 30 })
    Hunt.monsterButtonGroup = monsterPanel:OptionButtonGroup({ id = "Monster", textAlignment = "MiddleLeft", fontSize = 16, onClick = Hunt.SelectMonsterInternal })
    Hunt.monsterOptionButtons = {}
    local y = 0
    for i, monster in ipairs(Hunt.monsters) do
        Hunt.monsterOptionButtons[monster.name] = Hunt.monsterButtonGroup:OptionButton({ x = 0, y = y, width = 280, height = 30, text = monster.name, optionValue = monster })
        y = y - 30
    end

    local levelPanel = panel:Panel({ id = "Level", x = 341+3, y = -(109+3), width = 306-6, height = 216-6 })
    Hunt.levelButtonGroup = levelPanel:OptionButtonGroup({ id = "Level", textAlignment = "MiddleLeft", fontSize = 16, onClick = function(option)
        local level = option:OptionValue()
        log:Debugf("Selected %s, %s", Hunt.monster.name, level.name)
        Hunt.level = level
        option:Select()
    end })
    Hunt.levelOptionButtons = {}
    local y = 0
    for i = 1, 7 do
        Hunt.levelOptionButtons[i] = Hunt.levelButtonGroup:OptionButton({ x = 0, y = y, width = 300, height = 30, active = false })
        y = y - 30
    end

    panel:Button({ id = "Begin", x = 183, y = -345, width = 301, height = 60, onClick = function(mouseButton, player)
        if not Hunt.monster or not Hunt.level then
            log:Broadcastf("Please select a monster and level")
            return
        end

        --log:Printf("Checking if isUnlockedMode")
        if Expansion.IsUnlockedMode() != true then
            local expansion = Hunt.expansionsByMonsterName[Hunt.monster.name]
            if not Expansion.IsEnabled(expansion.name) then
                return log:Broadcastf("Requires %s expansion.", expansion.name)
            end
        end


        log:Debugf("Begin hunt clicked for monster %s, level %s", Hunt.monster.name, Hunt.level.level)
        Hunt.HideUi(player)
        Hunt.Setup(Hunt.monster, Hunt.level)
    end })

    panel:Button({ id = "Cleanup", x = 183, y = -552, width = 301, height = 60, onClick = function(mouseButton, player)
        log:Debugf("Cleanup hunt clicked")
        Hunt.Clean()
        Hunt.HideUi(player)
    end })
end

---------------------------------------------------------------------------------------------------

function Hunt.CleanInternal()
    Archive.Clean()

    local blocking = Location.Get("Hunt Cards"):BoxClean({ types = {
        "Hunt Events",
        "Monster Hunt Events",
        "Special Hunt Events",
    } })
    blocking = Util.ConcatArrays(blocking, Location.Get("Hunt Track"):BoxClean({ types = {
        "Hunt Events",
        "Monster Hunt Events",
        "Special Hunt Events",
        "Monster Figurine",
        "Minion Figurine",
        "Hunt Party",
    } }))

    return blocking
end

---------------------------------------------------------------------------------------------------

function Hunt.Clean()
    Hunt.CleanInternal()
    log:Printf("Cleaned up hunt.")
end

---------------------------------------------------------------------------------------------------

function Hunt.MonsterByNameForHunt(monsterName)
    for _, monster in ipairs(Hunt.monsters) do
        if monster.name == monsterName then
            return monster
        end
    end
end

---------------------------------------------------------------------------------------------------

function Hunt.Setup(monsterOrName, levelOrName)
    if Hunt.settingUpHunt == true then
        log:Errorf("Hunt setup currently in progress, please wait until finished before setting up another hunt. If the hunt appears to be stuck, click 'Cleanup Hunt' from the 'Cleanup' menu to reset.")
        return 1
    end

    local monster = nil
    if type(monsterOrName) == "string" then
--        monster = Hunt.monstersByMonsterName[monsterOrName]
        monster = Hunt.MonsterByNameForHunt(monsterOrName)
        assert(Check(monster, "Unknown monster %s", monsterOrName))
    else
        monster = monsterOrName
    end

    local level = nil
    if type(levelOrName) == "string" then
        level = Hunt.levelsByMonsterLevelName[monster.name..levelOrName]
        assert(Check(level, "Unknown level %s for monster %s", levelOrName, monster.name))
    else
        level = levelOrName
    end

    local blocking = Hunt.CleanInternal()
    blocking = Util.ConcatArrays(blocking, Location.Get("Monster Resources"):RayClean({ types = { "Monster Resources" } }))
    if #blocking > 0 then
        log:Broadcastf("Something is blocking hunt setup. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    log:Printf("Setting up hunt for %s %s...", monster.name, level.name)

    Hunt.settingUpHunt = true

    local huntEventsDeck = Container(Archive.Take({ name = "Hunt Events", type = "Hunt Events", location = "Hunt Events", rotation = { x = 0, y = 180, z = 180 } }))
    huntEventsDeck:Shuffle()
    local monsterHuntEventsDeck = Container(Archive.Take({ name = monster.huntEventsDeck, type = "Monster Hunt Events",  location = "Monster Hunt Events", rotation = { x = 0, y = 180, z = 180 } }))
    monsterHuntEventsDeck:Shuffle()
    Archive.Take({ name = "Herb Gathering", type = "Special Hunt Events", location = "Herb Gathering" })
    Archive.Take({ name = "Mineral Gathering", type = "Special Hunt Events", location = "Mineral Gathering" })
    Archive.Take({ name = "Sky Fishing", type = "Special Hunt Events", location = "Sky Fishing" })

    if monster.resourcesDeck then
        local monsterResourcesDeck = Archive.Take({ name = monster.resourcesDeck, type = "Monster Resources", location = "Monster Resources", rotation = { x = 0, y = 180, z = 180 } })
        monsterResourcesDeck.shuffle()
    end

    for i, c in ipairs(monster.huntTrack) do
        if c == 'H' then
            huntEventsDeck:Take({ location = "Hunt Track "..i, rotation = { x = 0, y = 180, z = 180 } })
        elseif c == 'M' then
            monsterHuntEventsDeck:Take({ location = "Hunt Track "..i, rotation = { x = 0, y = 180, z = 180 } })
        elseif c == 'O' then
            -- Overwhelming Darkness, no card
        elseif c == 'F' then
            Archive.Take({ name = "The Forest Gate", type = "Special Hunt Events", location = "Hunt Track "..i })
        elseif c == 'L' then
            Archive.Take({ name = "Underground Labyrinth", type = "Special Hunt Events", location = "Hunt Track "..i })
        else
            assert(Check.Fail("Unrecognized setup element %s at position %d in hunt setup %s %s", c, i, monster.name, level.name))
        end
    end

    local monsterFigurine = Archive.Take({
        name = monster.name,
        type = "Monster Figurine",
        location = "Hunt Track "..level.monsterHuntPosition,
        rotation = { x = 0, y = -90, z = 0 },
    })
    monsterFigurine.use_snap_points = true

    Archive.Take({
        name = "Hunt Party",
        type = "Hunt Party",
        location = level.partyHuntPosition and "Hunt Track "..level.partyHuntPosition or "Hunt Track Start",
        rotation = { x = 0, y = 90, z =0 },
    })

    Archive.Clean()

    log:Printf("Hunt ready. May your lanterns guide you in the darkness.")

    Hunt.settingUpHunt = false

    --Location.Get("Hunt Track"):LookAt({ distance = 30 })
end

---------------------------------------------------------------------------------------------------

function Hunt.ShowUi(player)
    log:Debugf("Showing Hunt UI for " .. player.steam_name)

    str = Hunt.panel:ShowForPlayer(player.color)

    if str == player.color then
        Hunt.uiOpen = true
    else
        log:Errorf(str .. " is already looking at the Hunt UI", player.steam_name, player.color)
    end
end

function Hunt.HideUi(player)
    log:Debugf("Hiding Hunt UI for " .. player.steam_name)

    str = Hunt.panel:HideForPlayer(player.color)

    if str == "None" or str == player.color then
        Hunt.uiOpen = false
    else
        log:Errorf(str .. " is already looking at the Hunt UI", player.steam_name, player.color)
    end
end

function Hunt.IsUiOpen()
    return Hunt.uiOpen
end

---------------------------------------------------------------------------------------------------

function Hunt.SelectMonsterInternal(option)
    local monster = option:OptionValue()
    log:Debugf("Selected %s", monster.name)
    Hunt.monster = monster

    for i, level in ipairs(monster.levels) do
        local levelOptionButton = Hunt.levelOptionButtons[i]
        levelOptionButton:Show()
        levelOptionButton:SetOptionValue(level)
        levelOptionButton:SetText(level.name)
    end

    for i = #monster.levels + 1, 7 do
        local levelOptionButton = Hunt.levelOptionButtons[i]
        levelOptionButton:SetText(nil)
        levelOptionButton:SetOptionValue(nil)
        levelOptionButton:Hide()
    end

    option:Select()

    Hunt.level = Hunt.levelOptionButtons[1]:OptionValue()
    Hunt.levelOptionButtons[1]:Select()
end

---------------------------------------------------------------------------------------------------

return {
    Init = Hunt.Init,
    Setup = Hunt.Setup,
    ShowUi = Hunt.ShowUi,
    HideUi = Hunt.HideUi,
    IsUiOpen = Hunt.IsUiOpen,
    Clean = Hunt.Clean,
}

end)
__bundle_register("Kdm/Settlement", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local Expansion = require("Kdm/Expansion")
local log = require("Kdm/Log").ForModule("Settlement")
local Location = require("Kdm/Location")
local NamedObject = require("Kdm/NamedObject")
local Util = require("Kdm/Util/Util")
local Ui = require("Kdm/Ui")

---------------------------------------------------------------------------------------------------

local Settlement = {}

---------------------------------------------------------------------------------------------------

function Settlement.Init()
    Settlement.gearbySettlementLocation = {}

    for _, expansion in ipairs(Expansion.All()) do
        for settlementLocation, gear in pairs(expansion.settlementLocationGear or {}) do
            assert(Check(Settlement.gearbySettlementLocation[settlementLocation] == nil, "Settlement location %s already registered", settlementLocation))
            log:Debugf("Adding %s -> %s", settlementLocation, gear)
            Settlement.gearbySettlementLocation[settlementLocation] = gear
        end
    end

    local ui = Ui.Create3d("SettlementBoard", NamedObject.Get("Settlement Board"), 0.61)

    local width = -0.21765
    local height = 0.644982
    local createButton = function(name, x, y, onClick)
        local topLeft = { x =  x, y = y }
        local bottomRight = { x = topLeft.x + width, y = topLeft.y + height }
        ui:Button({ id = name, topLeft = topLeft, bottomRight = bottomRight, onClick = onClick })
    end

    local x = 7.031489
    local y1 = 3.920273
    local y3 = 5.323954
    local dy = (y3 - y1) / 2
    local names = { "Starting Gear", "Rare Gear", "Promo Gear" }
    for i, name in ipairs(names) do
        createButton("Reset "..name, x, y1 + (i - 1) * dy, function() Settlement.ResetGear(name, name) end)
    end

    local x1 = 5.764139
    local x10 = -7.409930
    local dx = (x10 - x1) / 9
    local y1 = 1.971291
    local y2 = 7.274027
    local dy = y2 - y1
    for col = 1, 10 do
        for row = 1, 2 do
            local i = (row - 1) * 10 + col
            local name = string.format("Reset Settlement Location Gear %d", i)
            createButton(name, x1 + (col - 1) * dx, y1 + (row - 1)* dy, function() Settlement.ResetSettlementLocationGear(i) end)
        end
    end

    ui:ApplyToObject()

    for i = 1, 20 do
        local location = Location.Get("Settlement Location "..i)
        location:AddDropHandler(function(object) Settlement.OnDrop(i, object) end)
        location:AddPickUpHandler(function(object) Settlement.OnPickUp(i, object) end)
    end
end

---------------------------------------------------------------------------------------------------

function Settlement.ResetGear(gear, locationName)
    assert(Check.Str(gear))
    local location = Location.Get(locationName)

    log:Debugf("Resetting gear %s at %s", gear, locationName)

    local blocking = location:RayClean({ types = { "Gear" } })
    if #blocking > 0 then
        log:Broadcastf("Something is blocking the gear slot. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    Archive.Take({
        name = gear,
        type = "Gear",
        location = location,
        rotation = { x = 0, y = 180, z = 180 },
    })
    Archive.Clean()
end

---------------------------------------------------------------------------------------------------

function Settlement.ResetSettlementLocationGear(index)
    assert(Check.Num(index))

    local location = Location.Get(string.format("Settlement Location %d", index))

    local object = location:FirstObject({ types = { "Settlement Locations" } })
    if object == nil then
        return log:Debugf("No settlement location in slot %d to reset gear for.", index)
    end

    log:Debugf("Found candidate settlement location [%s]%s", object.getGUID(), object.getName())

    local gear = Settlement.gearbySettlementLocation[object.getName()]
    if not gear then
        return log:Broadcastf("%s doesn't have any gear. Maybe the gear you're looking for is in the 'Rare Gear' deck?", object.getName())
    end

    Settlement.ResetGear(gear, "Settlement Location Gear "..index)
end

---------------------------------------------------------------------------------------------------

function Settlement.OnDrop(index, object)
    if object.getGMNotes() != "Settlement Locations" then
        return
    end

    local gear = Settlement.gearbySettlementLocation[object.getName()]
    if not gear then
        return
    end

    log:Debugf("[%s]%s was dropped on settlement location %d to spawn gear %s", object.getGUID(), object.getName(), index, gear)

    Settlement.ResetGear(gear, "Settlement Location Gear "..index)
end

---------------------------------------------------------------------------------------------------

function Settlement.OnPickUp(index, object)
    if object.getGMNotes() != "Settlement Locations" then
        return
    end

    if not Settlement.gearbySettlementLocation[object.getName()] then
        return
    end

    log:Debugf("Settlement location [%s]%s removed from settlement location %d", object.getGUID(), object.getName(), index)

    Location.Get("Settlement Location Gear "..index):RayClean({ types = { "Gear" } })
end

---------------------------------------------------------------------------------------------------

return {
    Init = Settlement.Init,
}

end)
__bundle_register("Kdm/MilestoneBoard", function(require, _LOADED, __bundle_register, __bundle_modules)
local Campaign = require("Kdm/Campaign")
local Location = require("Kdm/Location")
local NamedObject = require("Kdm/NamedObject")
local Rules = require("Kdm/Rules")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local MilestoneBoard = {}

---------------------------------------------------------------------------------------------------

function MilestoneBoard.Init()
    local ui = Ui.Create3d("Milestone", NamedObject.Get("Milestone Board"), 0.15)
    local left1 = 2.039594
    local top1 = -0.208177
    local right1 = 1.055075
    local bottom1 = 0.021354
    local left5 = -2.188159
    local top4 = 0.703237
    local width = right1 - left1
    local height = bottom1 - top1
    local dx = (left5 - left1) / 4
    local dy = (top4 - top1) / 3

    for _, button in ipairs({
        { row = 1, col = 1, stat = "huntXp", milestone = 1 },
        { row = 1, col = 2, stat = "huntXp", milestone = 2 },
        { row = 1, col = 3, stat = "huntXp", milestone = 3 },
        { row = 1, col = 4, stat = "huntXp", milestone = 4 },
        { row = 1, col = 5, stat = "huntXp", milestone = 5 },
        { row = 2, col = 1, stat = "courage", milestone = 1 },
        { row = 2, col = 2, stat = "courage", milestone = 2 },
        { row = 3, col = 1, stat = "understanding", milestone = 1 },
        { row = 3, col = 2, stat = "understanding", milestone = 2 },
        { row = 4, col = 1, stat = "weaponProficiency", milestone = 1 },
        { row = 4, col = 2, stat = "weaponProficiency", milestone = 2 },
    }) do
        local tl = { x = left1 + ((button.col - 1) * dx), y = top1 + ((button.row - 1) * dy) }
        local br = { x = tl.x + width, y = tl.y + height}
        ui:Button({ id = button.row.."_"..button.col, topLeft = tl, bottomRight = br, onClick = function()
            MilestoneBoard.Event(button.stat, button.milestone)
        end })
    end

    ui:ApplyToObject()
end

---------------------------------------------------------------------------------------------------

function MilestoneBoard.Event(stat, milestone)
    local campaign = Campaign.Campaign()
    local milestoneEvents = campaign.milestoneEvents[stat]
    assert(milestoneEvents, Util.SafeFormat("Unrecognized milestone stat %s for campaign %s", stat, campaign.name))
    local event = milestoneEvents[milestone]
    assert(event, Util.SafeFormat("Unrecognized %s milestone # %d for campaign %s", stat, milestone, campaign.name))
    Rules.SpawnRules(event.rules, event.state)
    --Location.Get("Rules Board"):LookAt({ pitch = 90 })
end

---------------------------------------------------------------------------------------------------

return {
    Init = MilestoneBoard.Init
}

end)
__bundle_register("Kdm/Campaign", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local EventManager = require("Kdm/Util/EventManager")
local Expansion = require("Kdm/Expansion")
local Hunt = require("Kdm/Hunt")
local log = require("Kdm/Log").ForModule("Campaign")
local Location = require("Kdm/Location")
local MessageBox = require("Kdm/MessageBox")
local NamedObject = require("Kdm/NamedObject")
local Player = require("Kdm/Player")
local Showdown = require("Kdm/Showdown")
local Survivor = require("Kdm/Survivor")
local Timeline = require("Kdm/Timeline")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

-------------------------------------------------------------------------------------------------

local Campaign = {}

Campaign.EXPORT_VERSION = 2

---------------------------------------------------------------------------------------------------

function Campaign.Init(saveState)
    Campaign.InitExpansions()
    Campaign.campaign = Campaign.campaignsByName[saveState.campaign] or Campaign.campaignsByName["People of the Lantern"]
    Campaign.unlockedMode = saveState.unlockedMode
    if Campaign.unlockedMode == nil then 
        Campaign.unlockedMode = false
    end
    assert(Campaign.campaign)
    Campaign.InitCampaignUi()
    Campaign.InitExportImportBoardUi()
end

---------------------------------------------------------------------------------------------------

function Campaign.InitExpansions()
    Campaign.expansionsByName = {}
    Campaign.expansionsByCampaignName = {}
    Campaign.campaigns = {}
    Campaign.campaignsByName = {}
    for _, expansion in ipairs(Expansion.All()) do
        Campaign.expansionsByName[expansion.name] = expansion
        for _, campaign in ipairs(expansion.campaigns or {}) do
            Campaign.expansionsByCampaignName[campaign.name] = expansion
            table.insert(Campaign.campaigns, campaign)
            Campaign.campaignsByName[campaign.name] = campaign
        end
    end

    for _, expansion in ipairs(Expansion.All()) do
        if Expansion.IsEnabled(expansion.name) then
            local overrides = expansion.archiveOverrides
            if overrides then
                log:Debugf("Overriding archive entries for %s", expansion.name)
                Archive.RegisterEntries({ archive = overrides.newArchive, entries = overrides.entries, allowOverrides = true })
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.InitCampaignUi()
    local panel = Ui.Get2d():Panel({ id = "Campaign", rectAlignment = "MiddleCenter", x = 0, y = 0, width = 885, height = 723, active = false })
    Campaign.panel = panel
    panel:Image({ id = "Campaign", image = "Campaign", x = 0, y = 0, width = 885, height = 723 })
    panel:Button({ id = "Close", x = 845, y = -10, width = 30, height = 30, onClick = function(mouseButton, player) Campaign.HideUi(player) end })
    Campaign.selectedCampaign = Campaign.campaigns[1]
    local x = 20
    local y = -30
    Campaign.unlockedButton = panel:CheckButton({ id = "Unlocked", x = x, y = y, width = 130, height = 30, text = "Unlocked Mode", fontSize = 14, onClick = function()
        local checked = not Campaign.unlockedMode
        log:Debugf("Unlocked Mode %s", checked and "Activated" or "Disabled")
        Campaign.unlockedMode = checked
        Campaign.unlockedButton:Check(checked)
    end })
    local x = 20 --128
    local y = -125
    Campaign.campaignOptionGroup = panel:OptionButtonGroup({ id = "Campaign", unselectedColors = Ui.MID_BROWN_COLORS, fontSize = 14, onClick = function(option)
        local campaign = option:OptionValue()
        Campaign.selectedCampaign = campaign
        option:Select()
    end })
    for _, campaign in ipairs(Campaign.campaigns) do
        local selected = (campaign == Campaign.selectedCampaign)
        Campaign.campaignOptionGroup:OptionButton({ x = x, y = y, width = 200, height = 30, text = campaign.name, selected = selected, optionValue = campaign })
        x = x + 200 + 15
        if x > 665 then
            x = 20
            y = y - 30 - 15
        end
    end
    Campaign.selectedExpansionsNyName = {}
    local x = 20
    local y = -268
    Campaign.expansionButtons = {}
    for i, expansion in ipairs(Expansion:All()) do
        if expansion.name != "Core" then
            Campaign.expansionButtons[expansion.name] = panel:CheckButton({ id = expansion.name, x = x, y = y, width = 200, height = 30, fontSize = 14, text = expansion.name, onClick = function()
                local checked = not Campaign.selectedExpansionsNyName[expansion.name]
                log:Debugf("%s expansion %s", value and "Selecting" or "Deselecting", expansion.name)
                Campaign.selectedExpansionsNyName[expansion.name] = checked
                Campaign.expansionButtons[expansion.name]:Check(checked)
            end })
            x = x + 200 + 15
            if x > 665 then
                x = 20
                y = y - 30 - 15
            end
        end
    end
    panel:Button({ id = "Begin", x = 117, y = -643, width = 300, height = 60, onClick = function()
        MessageBox.Show("Are you sure you want to start a new campaign?", Campaign.ImportFromCampaign)
    end })
    panel:Button({ id = "Cancel", x = 468, y = -643, width = 300, height = 60, onClick = Campaign.HideUiForAll })
end

---------------------------------------------------------------------------------------------------

function Campaign.InitExportImportBoardUi()
    local ui = Ui.Create3d("ExportImport", NamedObject.Get("Export/Import Board"), 0.11)
    ui:Button({ id = "Export", topLeft = { x = 1.061903, y = 0.651955 }, bottomRight = { x = 0.067542, y = 0.849967 }, onClick = Campaign.ExportToOrb })
    ui:Button({ id = "Import", topLeft = { x = -0.071813, y = 0.652758 }, bottomRight = { x = -1.065097, y = 0.848203 }, onClick = Campaign.ImportFromOrb })
    ui:ApplyToObject()
end

---------------------------------------------------------------------------------------------------

function Campaign.Save()
    return {
        campaign = Campaign.campaign.name,
        unlockedMode = Campaign.unlockedMode
    }
end

---------------------------------------------------------------------------------------------------

Campaign.MAX_INNOVATIONS = 36
Campaign.MAX_WEAPON_PROFICIENCIES = 12
Campaign.MAX_SETTLEMENT_GEAR = 36
Campaign.MAX_SETTLEMENT_RESOURCES = 45
Campaign.MAX_SETTLEMENT_LOCATIONS = 20

function Campaign.ExportToOrb()
    local campaignOrbLocation = Location.Get("Campaign Orb")

    local blockingObjects = campaignOrbLocation:AllObjects()
    if #blockingObjects > 0 then
        log:Broadcastf("Please move the highlighted objects.")
        Util.HighlightAll(blockingObjects)
        return
    end

    function Campaign.Clean()
        for i = 1, 4 do
            Location.Get("Player "..i.." Board"):BoxClean({ tags = { "Card", "Deck" }, types = { "Tokens", "Survival Tokens", "Figurine" }})
        end
        Location.Get("Deck Board"):BoxClean({ tags = { "Card", "Deck" }, ignoreTypes = { "Monster Resources" }, })
        Location.Get("Terrain"):BoxClean({ tags = { "Card", "Deck" } })
        Location.Get("Settlement Events"):BoxClean({ tags = { "Card", "Deck" } })
        Location.Get("Settlement Board"):BoxClean({ tags = { "Card", "Deck" } })
        Location.Get("Settlement Locations"):BoxClean({ tags = { "Card", "Deck" } })
        for i = 1, 5 do
            Location.Get("Reference "..i):BoxClean({ tags = { "Tile", "Card" }, types = { "References", "Abilities" } })   -- concession for DK constellations
        end
        Location.Get("Hunt Events"):BoxClean({ tags = { "Card", "Deck" } })
    end

    local expansions = {}
    for _, expansion in ipairs(Expansion.All()) do
        if Expansion.IsEnabled(expansion.name) then
            table.insert(expansions, expansion.name)
        end
    end

    local scanTypesByLocation = {}
    scanTypesByLocation["Innovation Deck"] = { "Innovations" }
    for _, principle in ipairs({
        "Principle: Death",
        "Principle: New Life",
        "Principle: Society",
        "Principle: Conviction",
    }) do
        scanTypesByLocation[principle] = { "Innovations" }
    end
    for i = 1, Campaign.MAX_INNOVATIONS do
        scanTypesByLocation["Innovation "..i] = { "Innovations" }
    end
    for i = 1, Campaign.MAX_WEAPON_PROFICIENCIES do
        scanTypesByLocation["Weapon Mastery "..i] = { "Weapon Proficiencies" }
    end
    for i = 1, Campaign.MAX_SETTLEMENT_GEAR do
        scanTypesByLocation["Settlement Gear "..i] = { "Gear" }
    end
    for i = 1, Campaign.MAX_SETTLEMENT_RESOURCES do
        scanTypesByLocation["Settlement Resource "..i] = { "Basic Resources", "Monster Resources", "Strange Resources", "Vermin" }
    end
    for i = 1, Campaign.MAX_SETTLEMENT_LOCATIONS do
        scanTypesByLocation["Settlement Location "..i] = { "Settlement Locations" }
    end
    for ordinal, _ in ipairs(Player.Players()) do
        local playerPrefix = "Player "..ordinal
        scanTypesByLocation[playerPrefix.." Armor Set"] = { "Armor Sets" }
        scanTypesByLocation[playerPrefix.." Fist & Tooth"] = { "Gear" }
        for i = 1, 9 do
            scanTypesByLocation[playerPrefix.." Gear "..i] = { "Gear" }
        end
    end

    local objectsByLocation = {}
    for location, types in pairs(scanTypesByLocation) do
        local object, success = Campaign.Scan(location, types)
        if not success then
            return
        end
        objectsByLocation[location] = object
    end

    local data = {
        version = Campaign.EXPORT_VERSION,
        expansions = expansions,
        campaign = Campaign.campaign.name,
        unlockedMode = Campaign.unlockedMode,
        objectsByLocation = objectsByLocation,
        timeline = Timeline.Export(),
        survivor = Survivor.Export(),
    }

    local campaignOrb = spawnObject({
        type = "Metal Ball",
        position = campaignOrbLocation:Center(),
        scale = { x = 5, y = 5, z = 5 },
    })
    campaignOrb.setLuaScript("--")
    campaignOrb.script_state = JSON.encode(data)
    campaignOrb.setName("Campaign Orb")
    campaignOrb.setGMNotes("Campaign Orb")

    log:Broadcastf("Campaign export complete. Instructions are in the chat window.")
    log:Printf("1. Save your game.")
    log:Printf("2. Copy your campaign orb (right click on the orb -> Copy).")
    log:Printf("3. Load the latest version of the mod ('Games' button on the top bar).")
    log:Printf("4. Paste (right click anywhere -> Paste) the orb and drop it onto the same spot in the new version.")
    log:Printf("5. Click the 'Import Campaign' button.")
end

---------------------------------------------------------------------------------------------------

function Campaign.Scan(location, types)
    log:Debugf("Scanning %s for %s", location, Util.TabStr(types))

    local objects = Location.Get(location):AllObjects()
    if #objects > 1 then
        log:Errorf("Found multiple objects at %s: please make sure there's only one object in each card slot.", location)
        Util.HighlightAll(objects)
        return nil, false
    elseif #objects == 0 then
        return nil, true
    end

    local object = objects[1]
    if object.tag == "Card" then
        if not Util.Find(types, object.getGMNotes()) then
            log:Errorf("Found %s '%s' at '%s'. Export only records %s at this slot, so please move this card to it's correct location.", object.getGMNotes(), object.getName(), location, Util.TabStr(types))
            Util.Highlight(object)
            return nil, false
        end
        log:Debugf("Recording %s '%s' at '%s'", object.getGMNotes(), object.getName(), location)
        return { tag = "Card", name = object.getName(), type = object.getGMNotes(), location = location, faceDown = Util.IsFaceDown(object) or nil }, true

    elseif object.tag == "Deck" then
        local deck  = { tag = "Deck", name = object.getName(), type = object.getGMNotes(), location = location, faceDown = Util.IsFaceDown(object) or nil, cards = {} }
        for _, card in ipairs(Container(object):Objects()) do
            if not Util.Find(types, card.gm_notes) then
                log:Errorf("Found %s '%s' in deck at '%s'. Export only records %s at this slot, so please move this card to it's correct location.", card.gm_notes, card.name, location, Util.TabStr(types))
                Util.Highlight(object)
                return {}, false
            end

            log:Debugf("Recording %s '%s' at '%s'", card.gm_notes, card.name, location)
            table.insert(deck.cards, { name = card.name, type = card.gm_notes })
        end
        return deck, true
    end

    log:Errorf("Found %s '%s' at '%s'. Export only records cards and decks (not other objects). Please move this object out of the way.", object.tag, object.getName(), location)
    Util.Highlight(object)
    return nil, false
end

---------------------------------------------------------------------------------------------------

function Campaign.ImportFromOrb()
    local location = Location.Get("Campaign Orb")
    local object = location:FirstObject({ types = { "Campaign Orb" } })
    if not object then
        log:Broadcastf("Place your exported campaign orb in the highlighted area, then click 'Import Campaign'.")
        location:BoxCast({ debug = true })
        return
    end

    if object.getGMNotes() != "Campaign Orb" then
        log:Errorf("This object is not a campaign orb.")
        Util.Highlight(object)
        return
    end

    local state = JSON.decode(object.script_state)

    local campaign = Campaign.campaignsByName[state.campaign]
    if not campaign then
        log:Errorf("This campaign orb has an unknown campaign: %s", state.campaign)
        return
    end

    local expansions = { Campaign.expansionsByName["Core"] }
    for _, expansionName in ipairs(state.expansions) do
        if expansionName != "Core" then
            local expansion = Campaign.expansionsByName[expansionName]
            if not expansion then
                log:Errorf("This campaign orb has an unrecognized expansion: %s; ignoring", expansionName)
            else
                table.insert(expansions, expansion)
            end
        end
    end

    state.campaign = campaign
    state.expansions = expansions
    Campaign.Import(state)

    Wait.frames(function() log:Broadcastf("You can now delete the campaign orb.") end, 1)
end

---------------------------------------------------------------------------------------------------

function Campaign.ImportFromCampaign()
    local campaign = Campaign.selectedCampaign
    local requiredExpansion = Campaign.expansionsByCampaignName[campaign.name]
    if Campaign.unlockedMode != true then
        if requiredExpansion.name != "Core" and not Campaign.selectedExpansionsNyName[requiredExpansion.name] then
            log:Broadcastf("%s requires %s expansion", campaign.name, requiredExpansion.name)
            return
        end
    end

    Campaign.HideUiForAll()

    local expansions = { Campaign.expansionsByName["Core"] }
    for expansionName, enabled in pairs(Campaign.selectedExpansionsNyName) do
        if expansionName != "Core" and enabled then
            table.insert(expansions, Campaign.expansionsByName[expansionName])
        end
    end

    local objectsByLocation = {}
    for location, object in pairs(campaign.objectsByLocation) do
        objectsByLocation[location] = object
    end
    for ordinal, _ in ipairs(Player.Players()) do
        local playerPrefix = "Player "..ordinal
        objectsByLocation[playerPrefix.." Fist & Tooth"] = { tag = "Card", name = "Fist & Tooth", type = "Gear" }
        objectsByLocation[playerPrefix.." Gear 1"] = { tag = "Card", name = "Founding Stone", type = "Gear" }
        objectsByLocation[playerPrefix.." Gear 2"] = { tag = "Card", name = "Cloth",  type = "Gear" }
    end

    Campaign.Import({
        version = Campaign.EXPORT_VERSION,
        campaign = campaign,
        expansions = expansions,
        unlockedMode = Campaign.unlockedMode,
        objectsByLocation = objectsByLocation,
        remove = campaign.remove,
        references = campaign.references,
        misc = campaign.misc,
        survivor = {
            survivors = {
                -- everything default
                { id = 1 },
                { id = 2 },
                { id = 3 },
                { id = 4 },
            }
        },
        timeline = Campaign.BuildImportTimeline(expansions, campaign),
        spawnInitialSurvivorSheets = true,
    })
end

---------------------------------------------------------------------------------------------------

function Campaign.BuildImportTimeline(expansions, campaign)
    -- first aggregate remove/replace
    local removeEvents = {}
    for i = 1, 30 do removeEvents[i] = {} end
    local replaceNemeses = {}
    for _, expansion in ipairs(expansions) do
        local removeEvent = expansion.removeTimelineEvent
        if removeEvent then
            log:Debugf("Setting up removed event: [%d] %s", removeEvent.year, removeEvent.name)
            removeEvents[removeEvent.year][removeEvent.name] = true
        end

        local replaceNemesis = expansion.replaceNemesis
        if replaceNemesis then
            log:Debugf("Setting up replacement nemesis: %s -> %s", replaceNemesis.nemesis, replaceNemesis.replacement)
            replaceNemeses[replaceNemesis.nemesis] = replaceNemesis.replacement
        end
    end

    local events = {}
    Util.AppendArray(events, campaign.timeline)
    for _, expansion in ipairs(expansions) do
        Util.AppendArray(events, expansion.timelineEvents or {})
    end

    local years = {}
    for i = 1, Timeline.MAX_YEARS do
        years[i] = { events = {} }
    end

    local function FindFreeEvent(year)
        for i = 1, Timeline.MAX_YEAR_EVENTS do
            if not year.events[i] then
                return i
            end
        end
        return nil
    end

    for _, event in ipairs(events) do
        local yearIndex, name, type = event.year, event.name, event.type

        if removeEvents[yearIndex][name] then
            log:Debugf("Skipping removed event [%d] %s", yearIndex, name)

        elseif event.notCampaign == campaign.name then
            log:Debugf("Skipping timeline event %s for campaign %s", name, campaign.name)

        elseif type == "RulebookEvent" then
            local year = years[yearIndex]
            local eventIndex = FindFreeEvent(year)
            if eventIndex then
                year.events[eventIndex] = { name = name, type = "RulebookEvent" }
            else
                log:Errorf("Couldn't add event '%s' to timeline year %d; no more space. Please mark it on the settlement notes.", name, yearIndex)
            end

        elseif type == "ShowdownEvent" then
            local monster, level = event.monster, event.level
            if monster and replaceNemeses[monster] then
                monster = replaceNemeses[monster]
                log:Debugf("Adding replacement showdown [%d] %s", year, name)
            end
            if not years[yearIndex].events[Timeline.MAX_YEAR_EVENTS] then
                years[yearIndex].events[Timeline.MAX_YEAR_EVENTS] = { type = "ShowdownEvent", monster = monster, level = level, nemesis = true }
            else
                log:Errorf("Couldn't add showdown event %s/%s to timeline year %d; another event is already in the last slot. Please mark it on the settlement notes.", monster, level, yearIndex)
            end

        else
            assert(Check.Fail("Unrecognized event type %s for event %s", type, event))
        end
    end

    return {
        survivalActions = campaign.survivalActions,
        milestones = campaign.milestones,
        years = years,
    }
end

---------------------------------------------------------------------------------------------------

function Campaign.Import(data)
    if not Campaign.ConvertToLatestVersion(data) then
        return
    end

    Showdown:Clean()
    Hunt:Clean()
    Campaign.Clean()
    log:Printf("Cleaned up Campaign")
    Archive.Clean()

    local enabledByExpansionName = {}
    for _, expansion in ipairs(data.expansions) do
        enabledByExpansionName[expansion.name] = true
    end
    Expansion.SetEnabled(enabledByExpansionName)
    --log:Printf("Setting Unlocked Mode in Campaign.Import()")
    Expansion.SetUnlockedMode(data.unlockedMode)
    --log:Printf("Setting Unlocked Mode in Campaign.Import() done")

    Campaign.SetupArchiveOverrides(data.expansions)

    Campaign.SetupDeckFromExpansionComponents("Abilities", data)
    Campaign.SetupDeckFromExpansionComponents("Fighting Arts", data, { shuffle = true })
    Campaign.SetupDeckFromExpansionComponents("Secret Fighting Arts", data)
    Campaign.SetupDeckFromExpansionComponents("Disorders", data, { shuffle = true })
    Campaign.SetupDeckFromExpansionComponents("Severe Injuries", data)
    Campaign.SetupDeckFromExpansionComponents("Tactics", data, { shuffle = true })
    Campaign.SetupDeckFromExpansionComponents("Weapon Proficiencies", data)
    Campaign.SetupDeckFromExpansionComponents("Armor Sets", data)
    Campaign.SetupDeckFromExpansionComponents("Vermin", data, { shuffle = true })
    Campaign.SetupDeckFromExpansionComponents("Strange Resources", data)
    Campaign.SetupDeckFromExpansionComponents("Basic Resources", data, { shuffle = true })
    Campaign.SetupDeckFromExpansionComponents("Terrain", data, { shuffle = true })
    local settlementEventsDeck = Campaign.SetupDeckFromExpansionComponents("Settlement Events", data, { shuffle = true })
    settlementEventsDeck:Take({ name = "First Day", type = "Settlement Events", location = "Drawn Settlement Events" })
    Campaign.SetupDeckFromExpansionComponents("Rare Gear", data, { type = "Gear" })
    Campaign.SetupDeckFromExpansionComponents("Hunt Events", data)
    Campaign.SetupDeckFromExpansionComponents("Patterns", data, { type = "Patterns"})
    log:Printf("Reached Bernard")
    local context = {
        cache = {},
    }
    context.innovationArchive = Campaign.SetupDeckFromExpansionComponents("Innovation Archive", data, { component = "Innovations", type = "Innovations", noArchive = true })
    context.bookmarkArchive = Campaign.SetupDeckFromExpansionComponents("Bookmark Archive", data, { component = "Bookmarks", type = "Bookmarks", noArchive = true, faceUp = true})
    context.settlementLocationDeck = Campaign.SetupDeckFromExpansionComponents("Settlement Locations", data, { faceUp = true, noArchive = true })

    Archive.Take({ name = "Starting Gear", type = "Gear", location = "Starting Gear", rotation = { x = 0, y = 180, z = 180 } })
    Archive.Take({ name = "Promo Gear", type = "Gear", location = "Promo Gear", rotation = { x = 0, y = 180, z = 180 } })

    for location, object in pairs(data.objectsByLocation) do
        Campaign.SetupObject(location, object, context)
    end

    Campaign.SetupSurvivalTokens(data.timeline.survivalActions)
    Campaign.SetupReferences(data.campaign.references)
    Campaign.SetupMisc(data.campaign.misc)

    Archive.Take({ name = "Allister", type = "Player Figurine", location = "Player 1 Marker" })
    Archive.Take({ name = "Ezra", type = "Player Figurine", location = "Player 2 Marker" })
    Archive.Take({ name = "Lucy", type = "Player Figurine", location = "Player 3 Marker" })
    Archive.Take({ name = "Zachary", type = "Player Figurine", location = "Player 4 Marker" })

    Archive.Clean()

    Survivor.Import(data.survivor)
    Timeline.Import(data.timeline)

    if data.spawnInitialSurvivorSheets then
        for i = 1, 4 do
            local survivor = Survivor.Survivors()[i]
            local player = Player.Players()[i]
            Archive.Take({ name = "Survivor Sheet", type = "Survivor Sheet", location = "Player "..i.." Survivor Sheet", height = 0, spawnFunc = function(survivorSheetObject)
                -- We have to wait a single frame when taking from an infinite container or the objects will have the same equality/identity value as any other objects taken that frame
                Wait.frames(function()
                    log:Debugf("Created survivor sheet for object %s and %s", survivorSheetObject.getGUID(), survivor)
                    local survivorSheet = Survivor.CreateSurvivorSheet(survivor, survivorSheetObject)
                    survivorSheetObject.setLock(true)
                    player:LinkSurvivorSheet(survivorSheet)
                end, 1)
            end })
        end
    end

    Campaign.campaign = data.campaign

    log:Broadcastf("Campaign setup complete.")
end

---------------------------------------------------------------------------------------------------

function Campaign.ConvertToLatestVersion(data)
    if data.version == Campaign.EXPORT_VERSION then
        return true
    end

    if data.version == 1 then
        data.objectsByLocation = {
            ["Principle: Death"] = { tag = "Deck", name = "Principle: Death", type = "Innovations", faceDown = true, cards = {
                { name = "Cannibalize - Death Principle", type = "Innovations" },
                { name = "Graves - Death Principle", type = "Innovations" },
            } },
            ["Principle: New Life"] = { tag = "Deck", name = "Principle: New Life", type = "Innovations", faceDown = true, cards = {
                { name = "Protect the Young - New Life Principle", type = "Innovations" },
                { name = "Survival of the Fittest - New Life Principle", type = "Innovations" },
            } },
            ["Principle: Society"] = { tag = "Deck", name = "Principle: Society", type = "Innovations", faceDown = true, cards = {
                { name = "Accept Darkness - Society Principle", type = "Innovations" },
                { name = "Collective Toil - Society Principle", type = "Innovations" },
            } },
            ["Principle: Conviction"] = { tag = "Deck", name = "Principle: Conviction", type = "Innovations", faceDown = true, cards = {
                { name = "Barbaric - Conviction Principle", type = "Innovations" },
                { name = "Romantic - Conviction Principle", type = "Innovations" },
            } },
        }

        if data.innovationDeck then
            if #data.innovationDeck > 1 then
                local cards = {}
                for _, card in ipairs(data.innovationDeck or {}) do
                    table.insert(cards, { name = card, type = "Innovations" })
                end
                data.objectsByLocation["Innovation Deck"] = { tag = "Deck", name = "Innovation Deck", type = "Innovations", faceDown = true, cards = cards }
            elseif #data.innovationDeck == 1 then
                data.objectsByLocation["Innovation Deck"] = { tag = "Card", name = data.innovationDeck[1], type = "Innovations" }
            end
        end

        for _, cardList in ipairs({
            data.innovations or {},
            data.principles or {},
            data.settlementLocations or {},
            data.settlementGear or {},
            data.settlementResources or {},
            data.weaponMasteries or {},
        }) do
            for _, card in ipairs(cardList) do
                data.objectsByLocation[card.location] = { tag = "Card", name = card.name, type = card.type }
            end
        end

        for _, playerGear in ipairs(data.playerGear or {}) do
            if playerGear.armorSet then
                data.objectsByLocation[playerGear.armorSet.location] = { tag = "Card", name = playerGear.armorSet.name, type = playerGear.armorSet.type }
            end
            for _, card in ipairs(playerGear.gear or {}) do
                data.objectsByLocation[card.location] = { tag = "Card", name = card.name, type = card.type }
            end
        end

        data.survivor = data.population
        for _, survivor in ipairs(data.survivor.survivors) do
            local newCards = {}
            for type, cards in pairs(survivor.cards or {}) do
                for _, card in ipairs(cards or {}) do
                    table.insert(newCards, { name = card, type = type })
                end
            end
            survivor.cards = newCards
        end

        data.timeline.years = data.timeline.timeline

        data.version = Campaign.EXPORT_VERSION

        return true
    end

    log:Errorf("Exported campaign has unrecognized version %s", tostring(data.version))
    return false
end

---------------------------------------------------------------------------------------------------

function Campaign.Clean()
    for i = 1, 4 do
        Location.Get("Player "..i.." Board"):BoxClean({ tags = { "Card", "Deck" }, types = { "Tokens", "Survival Tokens", "Player Figurine" }})
    end
    Location.Get("Showdown Board"):BoxClean({ types = { "Player Figurine" } })
    Location.Get("Deck Board"):BoxClean({ tags = { "Card", "Deck" }, ignoreTypes = { "Monster Resources" }, })
    Location.Get("Terrain"):BoxClean({ tags = { "Card", "Deck" } })
    Location.Get("Settlement Events"):BoxClean({ tags = { "Card", "Deck" } })
    Location.Get("Drawn Settlement Events"):BoxClean({ tags = { "Card", "Deck" } })
    Location.Get("Settlement Board"):BoxClean({ tags = { "Card", "Deck" } })
    Location.Get("Settlement Locations"):BoxClean({ tags = { "Card", "Deck" } })
    for i = 1, 5 do
        Location.Get("Reference "..i):BoxClean({ tags = { "Tile", "Card" }, types = { "References", "Abilities" } })   -- concession for DK constellations
    end
    Location.Get("Hunt Events"):BoxClean({ tags = { "Card", "Deck" } })
end

---------------------------------------------------------------------------------------------------

function Campaign.SetupArchiveOverrides(expansions)
    -- revert everything
    for _, expansion in ipairs(Expansion.All()) do
        local overrides = expansion.archiveOverrides
        if overrides then
            log:Debugf("Reverting archive entry overrides for %s", expansion.name)
            Archive.RegisterEntries({ archive = overrides.oldArchive, entries = overrides.entries, allowOverrides = true })
        end
    end

    -- apply selected expansions
    for _, expansion in ipairs(expansions) do
        local overrides = expansion.archiveOverrides
        if overrides then
            log:Debugf("Overriding archive entries for %s", expansion.name)
            Archive.RegisterEntries({ archive = overrides.newArchive, entries = overrides.entries, allowOverrides = true })
        end
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.SetupDeckFromExpansionComponents(name, data, params)
    local params = params or {}
    local location = Location.Get(name)
    local component = params.component or name
    local type = params.type or name

    log:Debugf("Setting up %s deck", name)

    local sources = {}
    for _, expansion in ipairs(data.expansions) do
        if expansion.components and expansion.components[component] then
            log:Debugf("  Adding %s/%s", expansion.components[component], type)
            table.insert(sources, Archive.ArchiveSource(expansion.components[component], type))
        end
    end

    if #sources == 0 then
    log:Debugf("No expansions have %s, skipping", name)
        return
    end

    local rotation = { x = 0, y = 180, z = params.faceUp and 0 or 180 }
    local deckContainer = Archive.CreateDeckFromSources({
        sources = sources,
        name = name,
        type = type,
        location = location,
        rotation = rotation,
    })

    if data.remove and data.remove[name] then
        deckContainer:Delete(data.remove[name])
    end

    if not params.noArchive then
        local archive = NamedObject.Get(name.." Archive")
        archive.reset()
        archive.putObject(deckContainer.object)

        deckContainer = Container(archive.takeObject({
            position = location:Center(),
            rotation = rotation,
            smooth   = false,
        }))
    end

    if params.shuffle then
        deckContainer:Shuffle()
    end

    return deckContainer
end

---------------------------------------------------------------------------------------------------

function Campaign.Spawn(name, type, position, context)
    local key = name..":"..type
    local object = context.cache[key]
    if not object then
        if type == "Innovations" then
            object = context.innovationArchive:Take({ name = name, type = type, position = position })
        elseif type == "Settlement Locations" then
            object = context.settlementLocationDeck:Take({ name = name, type = type, position = position })
        else
            object = Archive.Take({ archive = type.." Archive", name = name, type = type, position = position })
        end
        if not object then
            return
        end
        context.cache[key] = object
        return object
    else
        return object.clone({ position = position })
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.SetupObject(locationName, objectData, context)
    local location = Location.Get(locationName)
    if not location then
        return log:Errorf("Object '%s' (%s) was recorded at unrecognized location '%s'; spawning in the middle of the showdown board.", name, type, location)
    end

    local finalObject = nil
    local position = location:Center()
    position.y = position.y + 2
    log:Debugf("Adding %s '%s' (%s) at %s", objectData.tag, objectData.name, objectData.type, locationName)
    if objectData.tag == "Card" then
        finalObject = Campaign.Spawn(objectData.name, objectData.type, position, context)
        if not finalObject then
            return log:Errorf("Couldn't find card '%s' (%s) for location %s", objectData.name, objectData.type, locationName)
        end

    elseif objectData.tag == "Deck" then
        local objects = {}
        for _, card in ipairs(objectData.cards) do
            log:Debugf("  Adding '%s' (%s)", card.name, card.type)
            local object = Campaign.Spawn(card.name, card.type, position, context)
            if not object then
                return log:Errorf("  Couldn't find card '%s' (%s) for location %s", card.name, card.type, locationName)
            end
            table.insert(objects, object)
            position.y = position.y + 0.3
        end
        finalObject = group(objects)[1]
        assert(Check(finalObject))
        assert(Check(finalObject.tag == "Deck" or finalObject.tag == "Card"))
        finalObject.setName(objectData.name)
        finalObject.setGMNotes(objectData.type)

    else
        return log:Errof("Unrecognized object tag '%s' at location '%s'", tag, location)
    end

    if objectData.faceDown then
        assert(finalObject)
        --Wait.frames(function() finalObject.setRotation({ x = 0, y = 180, z = 180 }) end, 2)
        finalObject.setRotation({ x = 0, y = 180, z = 180 })
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.SetupSurvivalTokens(survivalActions)
    for ordinal, player in ipairs(Player.Players()) do
        for i, survivalAction in ipairs(survivalActions or {}) do
            if survivalAction.checked then
                log:Debugf("Adding survival token '%s' for player %d", survivalAction, i)
                local survivalToken = Archive.Take({ archive = survivalAction.name.." Tokens", name = survivalAction.name, type = "Survival Tokens", location = "Player "..ordinal.." Survival Token "..i })
                if not survivalToken then
                    log:Errorf("Couldn't find survival token '%s'", survivalAction)
                else
                    survivalToken.setLock(false) -- for some reason these sometimes spawn locked
                end
            end
        end
        Archive.Clean()
    end
end

-------------------------------------------------------------------------------------------------

function Campaign.SetupReferences(references)
    for _, reference in ipairs(references or {}) do
        local name, location = reference.name, reference.location
        -- height 0 because we lock these immediately after spawning
        if not Archive.Take({ name = name, type = "References", location = location, height = 0, spawnFunc = function(spawnedObject)
            spawnedObject.setLock(true)
        end }) then
            log:Errorf("Couldn't find '%s'", name)
        else
            log:Debugf("Added reference '%s'", name)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.SetupMisc(misc)
    for _, m in ipairs(misc or {}) do
        if not Archive.Take(m) then
            log:Errorf("Couldn't find '%s' (%s)", m.name, m.type)
        else
            log:Debugf("Added misc item '%s' (%s)", m.name, m.type)
        end
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.ShowUi(player)
    log:Debugf("Showing Campaign UI for " .. player.steam_name)

    str = Campaign.panel:ShowForPlayer(player.color)

    if str == player.color then
        Campaign.uiOpen = true
    else
        log:Errorf(str .. " is already looking at the Campaign UI", player.steam_name, player.color)
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.HideUi(player)
    log:Debugf("Hiding Campaign UI for " .. player.steam_name)

    str = Campaign.panel:HideForPlayer(player.color)

    if str == "None" or str == player.color then
        Campaign.uiOpen = false
    else
        log:Errorf(str .. " is already looking at the Campaign UI", player.steam_name, player.color)
    end
end

---------------------------------------------------------------------------------------------------

function Campaign.HideUiForAll()
    log:Debugf("Hiding Campaign UI for all")
    Campaign.panel:Hide()
    Campaign.uiOpen = false
end

---------------------------------------------------------------------------------------------------

function Campaign.IsUiOpen()
    return Campaign.uiOpen
end

---------------------------------------------------------------------------------------------------

return {
    Init = Campaign.Init,
    Save = Campaign.Save,
    ShowUi = Campaign.ShowUi,
    HideUi = Campaign.HideUi,
    IsUiOpen = Campaign.IsUiOpen,
    Campaign = function() return Campaign.campaign end,
}

end)
__bundle_register("Kdm/GlobalUi", function(require, _LOADED, __bundle_register, __bundle_modules)
local Hunt = require("Kdm/Hunt")
local Campaign = require("Kdm/Campaign")
local Showdown = require("Kdm/Showdown")
local Timeline = require("Kdm/Timeline")
local Ui = require("Kdm/Ui")

---------------------------------------------------------------------------------------------------

local GlobalUi = {}

---------------------------------------------------------------------------------------------------

function GlobalUi.Init()
    local ui = Ui.Get2d()

    local buttons = {
        { name = "Campaign", module = Campaign, image = "CampaignButton" },
        { name = "Hunt", module = Hunt, image = "HuntButton" },
        { name = "Showdown", module = Showdown, image = "ShowdownButton" },
        { name = "Timeline", module = Timeline, image = "TimelineButton" },
    }

    GlobalUi.buttons = {}
    for i, button in ipairs(buttons) do
        GlobalUi.buttons[button.name] = ui:Button({ id = button.name, rectAlignment = "UpperLeft", x = 70, y = -10 - (i - 1) * 40, width = 100, height = 30, image = button.image, onClick = function(mousteButton, player)
            if button.module.IsUiOpen() then
                if button.name == "Timeline" then
                    button.module.HideUiForAll()
                else
                    button.module.HideUi(player)
                end
            else
                for _, other in ipairs(buttons) do
                    if other.name != button.name then
                        if other.name == "Timeline" then
                            other.module.HideUiForAll()
                        else
                            other.module.HideUi(player)
                        end
                    end
                end
                if button.name == "Timeline" then
                    button.module.ShowUiForAll()
                else
                    button.module.ShowUi(player)
                end
            end
        end })
    end

    GlobalUi.open = true
    GlobalUi.collapseExpandButton = ui:Button({ id = "CollapseExpand", rectAlignment = "UpperLeft", x = 180, y = -10, width = 30, height = 30, image = "CollapseButton", onClick = function()
        if GlobalUi.open then
            GlobalUi.open = false
            GlobalUi.collapseExpandButton:SetImage("ExpandButton")
            for _, button in pairs(GlobalUi.buttons) do
                button:Hide()
            end
        else
            GlobalUi.open = true
            GlobalUi.collapseExpandButton:SetImage("CollapseButton")
            for _, button in pairs(GlobalUi.buttons) do
                button:Show()
            end
        end
    end })
end

---------------------------------------------------------------------------------------------------

return {
    Init = GlobalUi.Init,
}

end)
__bundle_register("Kdm/Deck", function(require, _LOADED, __bundle_register, __bundle_modules)
local Archive = require("Kdm/Archive")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Deck")
local NamedObject = require("Kdm/NamedObject")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Deck = {}

Deck.NEEDS_SHUFFLE = {
    ["Fighting Arts"] = true,
    ["Disorders"] = true,
    ["Tactics"] = true,
    ["Vermin"] = true,
    ["Basic Resources"] = true,
    ["Monster Resources"] = true,
    ["Terrain"] = true,
    ["Patterns"] = true,
}

---------------------------------------------------------------------------------------------------

function Deck.Init()
    local ui = Ui.Create3d("Deck", NamedObject.Get("Showdown Board"), 10.74)

    local deckGrid = {
        { "Patterns" },
        { "Abilities", "Fighting Arts", "Secret Fighting Arts" },
        { "Disorders", "Severe Injuries", "Tactics" },
        { "Weapon Proficiencies", "Armor Sets", "Vermin" },
        { "Strange Resources", "Basic Resources" },
    }
    local x1 = 9.575500
    local x1End = 9.375386
    local width = x1End - x1
    local x3 = 7.538684
    local dx = (x3 - x1) / 2
    local y1 = -1.193880
    local y1End = -0.042474
    local height = y1End - y1
    local y4 = 3.030348
    local dy = (y4 - y1) / 3
    for row, decks in ipairs(deckGrid) do
        for col, deck in ipairs(decks) do
            local x = x1 + (col - 1) * dx
            local y = y1 + (row - 2) * dy
            ui:Button({ id = deck, topLeft = { x = x, y = y }, bottomRight = { x = x + width, y = y + height }, onClick = function()
                Deck.ResetDeck(deck)
            end })
        end
    end

    --ui:ApplyToObject()
end

---------------------------------------------------------------------------------------------------

function Deck.ResetDeck(deck)
    log:Debugf("Resetting deck %s", deck)

    location = Location.Get(deck)
    local blocking = location:BoxClean({ types = { deck } })
    if #blocking > 0 then
        log:Broadcastf("Something is blocking the deck. Please move the highlighted objects out of the way and try again.")
        Util.HighlightAll(blocking)
        return
    end

    local deckObject = Archive.Take({ name = deck, type = deck, location = location, rotation = { x = 0, y = 180, z = 180 } })
    if Deck.NEEDS_SHUFFLE[deck] then
        deckObject.shuffle()
    end
    Archive.Clean()
end

---------------------------------------------------------------------------------------------------

return {
    Init = Deck.Init
}

end)
__bundle_register("Kdm/BattleUi", function(require, _LOADED, __bundle_register, __bundle_modules)
local Check = require("Kdm/Util/Check")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("BattleUi")
local Monster = require("Kdm/Monster")
local NamedObject = require("Kdm/NamedObject")
local Player = require("Kdm/Player")
local Survivor = require("Kdm/Survivor")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local BattleUi = {}

BattleUi.MAX_WEAPONS = 3
BattleUi.PLAYER_SPACING = 0
BattleUi.TEXT_COLOR = "#ffffffdc"
BattleUi.DISABLED_TEXT_COLOR = "#ffffff60"
BattleUi.DARK_COLORS = "#00000000|#ffffff10|#ffffff20|#ffffffff"
BattleUi.DARK_SELECTED_COLORS = "#ffffff20|#ffffff30|#ffffff40|#ffffffff"

---------------------------------------------------------------------------------------------------

function BattleUi.Init(saveState)
    BattleUi.hiddenWeaponsBySurvivor = {}

    for survivorId, hiddenWeapons in pairs(saveState or {}) do
        local survivor = Survivor.SurvivorForId(survivorId)
        if survivor == nil then
            log:Debugf("No survivor with ID %d doesn't exist", survivorId)
        else
            BattleUi.hiddenWeaponsBySurvivor[survivor] = hiddenWeapons
        end
    end

    BattleUi.InitUi(ui)
end

function BattleUi.InitUi(ui)
    local ui = Ui.Get2d()
    BattleUi.ui = ui

    ui:Image({ id = "BattleUi", rectAlignment = "MiddleLeft", x = 10, y = -20, width = 50, height = 50, image = "BattleUi" })
    ui:Button({ id = "BattleUi", rectAlignment = "MiddleLeft", x = 10-1, y = -20+1, width = 50+2, height = 50+2, colors = BattleUi.DARK_COLORS, onClick = function()
        if BattleUi.uiOpen then
            BattleUi.Hide()
        else
            BattleUi.Show()
        end
    end })

    ui:Image({ id = "NextTurn", rectAlignment = "MiddleLeft", x = 10, y = -80, width = 50, height = 50, image = "NextTurn" })
    ui:Button({ id = "NextTurn", rectAlignment = "MiddleLeft", x = 10-1, y = -80+1, width = 50+2, height = 50+2, colors = BattleUi.DARK_COLORS, onClick = BattleUi.NextTurn })

    BattleUi.uiOpen = false
    BattleUi.panel = ui:Panel({ id = "BattleUi", x = 70, y = -210, width = 436, height = 608, color = "#00000000", active = BattleUi.uiOpen })
    BattleUi.panel.attributes.allowDragging = true
    BattleUi.panel.attributes.returnToOriginalPositionWhenReleased = false

    BattleUi.playerUis = {}
    for _, player in ipairs(Player.Players()) do
        local playerUi = { height = 140 }
        local ordinal = player:Ordinal()
        BattleUi.playerUis[ordinal] = playerUi

        playerUi.open = true
        local panel = BattleUi.panel:Panel({ id = "Player"..ordinal, x = 0, y = -(playerUi.height + BattleUi.PLAYER_SPACING) * (ordinal - 1), width = 436, height = playerUi.height, color = "#121212ff" })
        playerUi.panel = panel
        playerUi.playerCircleImage = panel:Image({ id = "PlayerCircle", x = 8, y = -8, width = 25, height = 25, image = "WhiteCircle" })
        playerUi.nameText = panel:Text({ id = "Name", x = 38, y = -8, width = 280, height = 25, fontSize = 16, color = BattleUi.TEXT_COLOR, text = "Survivor with a very long name" })

        playerUi.turnEnded = false
        panel:Image({ id = "EndTurn", x = 324, y = -8, width = 48, height = 25, image = "BR_Sleep" })
        playerUi.endTurnButton = panel:Button({ id = "EndTurn", x = 324-1, y = -8+1, width = 48+2, height = 25+2, colors = BattleUi.DARK_COLORS, onClick = function()
            playerUi.turnEnded = not playerUi.turnEnded
            if playerUi.turnEnded then
                log:Printf("Player %d: %s turn ended", ordinal, player:SurvivorSheet():Survivor():NameOrUnnamed())
                playerUi.playerCircleImage:SetImage("GreyCircle")
                playerUi.nameText:SetColor(BattleUi.DISABLED_TEXT_COLOR)
                playerUi.nameText:SetFontStyle("Italic")
                playerUi.endTurnButton:SetColors(BattleUi.DARK_SELECTED_COLORS)
            else
                log:Printf("Player %d: %s next turn", ordinal, player:SurvivorSheet():Survivor():NameOrUnnamed())
                playerUi.playerCircleImage:SetImage("WhiteCircle")
                playerUi.nameText:SetColor(BattleUi.TEXT_COLOR)
                playerUi.nameText:SetFontStyle("Normal")
                playerUi.endTurnButton:SetColors(BattleUi.DARK_COLORS)
            end
        end})

        playerUi.showWeaponsImage = panel:Image({ id = "ShowWeapons", x = 380, y = -8, width = 48, height = 25, image = "BR_Show" })
        playerUi.showWeaponsButton = panel:Button({ id = "ShowWeapons", x = 380-1, y = -8+1, width = 48+2, height = 25+2, colors = BattleUi.DARK_COLORS, onClick = function()
            local survivor = player:SurvivorSheet():Survivor()
            log:Printf("Showing all weapons for %s", survivor:NameOrUnnamed())
            BattleUi.hiddenWeaponsBySurvivor[survivor] = nil
            BattleUi.UpdatePlayer(player)
        end})

        playerUi.weaponImages = {}
        playerUi.weaponHideWeaponsButtons = {}
        playerUi.weaponNameTexts = {}
        playerUi.weaponSpeedTexts = {}
        playerUi.weaponHitTexts = {}
        playerUi.weaponWoundTexts = {}
        playerUi.weaponCritTexts = {}
        local y = -41
        for i = 1, BattleUi.MAX_WEAPONS do
            playerUi.weaponImages[i] = panel:Image({ id = "Weapon"..i, x = 8, y = y, width = 420, height = 25, image = "BR_Weapon" })
            playerUi.weaponHideWeaponsButtons[i] = panel:Button({ id = "WeaponName"..i, x = 8-1, y = y+1, width = 8+19+8+2, height = 25+2, colors = BattleUi.DARK_COLORS, onClick = function()
                local text = playerUi.weaponNameTexts[i]
                local weaponName = text.object.UI.getAttribute(text.attributes.id, "text")
                local survivor = player:SurvivorSheet():Survivor()
                log:Printf("Hiding %s for %s", weaponName, survivor:NameOrUnnamed())
                if not BattleUi.hiddenWeaponsBySurvivor[survivor] then
                    BattleUi.hiddenWeaponsBySurvivor[survivor] = {}
                end
                BattleUi.hiddenWeaponsBySurvivor[survivor][weaponName] = true
                BattleUi.UpdatePlayer(player)
            end })
            playerUi.weaponNameTexts[i]  = panel:Text({ id = "WeaponName"..i,  x =  43, y = y, width = 172, height = 25, color = BattleUi.TEXT_COLOR, fontSize = 14, text = "Calcified Juggernaut Blade" })
            playerUi.weaponSpeedTexts[i] = panel:Text({ id = "WeaponSpeed"..i, x = 243, y = y, width = 20, height = 25, color = BattleUi.TEXT_COLOR, fontSize = 16, text = "44" })
            playerUi.weaponHitTexts[i]   = panel:Text({ id = "WeaponHit"..i,   x = 288, y = y, width = 20, height = 25, color = BattleUi.TEXT_COLOR, fontSize = 16, text = "44" })
            playerUi.weaponWoundTexts[i] = panel:Text({ id = "WeaponWound"..i, x = 334, y = y, width = 55, height = 25, color = BattleUi.TEXT_COLOR, fontSize = 16, text = "44 (+44)" })
            playerUi.weaponCritTexts[i]  = panel:Text({ id = "WeaponCrit"..i,  x = 407, y = y, width = 20, height = 25, color = BattleUi.TEXT_COLOR, fontSize = 16, text = "44" })
            y = y - 33
        end
    end
end

---------------------------------------------------------------------------------------------------

BattleUi.RELEVANT_SURVIVOR_STATS = {
    ["name"] = true,
    ["modifiedSpeed"] = true,
    ["modifiedAccuracy"] = true,
    ["modifiedStrength"] = true,
    ["modifiedEvasion"] = true,
    ["modifiedLuck"] = true,
}

BattleUi.RELEVANT_MONSTER_STATS = {
    ["toughness"] = true,
    ["evasion"] = true,
    ["luck"] = true,
}

function BattleUi.PostInit()
    -- We specifically delay registering event handlers until PostInit() to avoid redundant UpdatePlayer() calls from
    -- the ON_PLAYER_SURVIVOR_LINKED events emitted from Player.Init()
    EventManager.AddHandler(EventManager.ON_SHOWDOWN_STARTED, BattleUi.Show)
    EventManager.AddHandler(EventManager.ON_SHOWDOWN_ENDED, BattleUi.Hide)
    EventManager.AddHandler(EventManager.ON_PLAYER_SURVIVOR_LINKED, function(player) BattleUi.UpdatePlayer(player) end)
    EventManager.AddHandler(EventManager.ON_PLAYER_SURVIVOR_UNLINKED, function(player) BattleUi.UpdatePlayer(player) end)
    EventManager.AddHandler(EventManager.ON_SURVIVOR_STAT_CHANGED, function(survivor, stat, value)
        if BattleUi.RELEVANT_SURVIVOR_STATS[stat] then
            BattleUi.Update()
        end
    end)
    EventManager.AddHandler(EventManager.ON_MONSTER_STAT_CHANGED, function(stat)
        if BattleUi.RELEVANT_MONSTER_STATS[stat] then
            BattleUi.Update()
        end
    end)
    EventManager.AddHandler(EventManager.ON_PLAYER_WEAPONS_CHANGED, function(player) BattleUi.UpdatePlayer(player) end)
    EventManager.AddHandler(EventManager.ON_SURVIVOR_DESTROYED, function(survivor) BattleUi.hiddenWeaponsBySurvivor[survivor] = nil end)
    EventManager.AddHandler(EventManager.ON_PLAYER_COLOR_CHANGED, function(player, colorTable, colorStr)
        BattleUi.playerUis[player:Ordinal()].playerCircleImage:SetColor(colorStr)
    end)

    BattleUi.Update()
end

---------------------------------------------------------------------------------------------------

function BattleUi.Save()
    local hiddenWeaponsBySurvivorId = {}
    for survivor, hiddenWeapons in pairs(BattleUi.hiddenWeaponsBySurvivor) do
        hiddenWeaponsBySurvivorId[survivor:Id()] = hiddenWeapons
    end
    return hiddenWeaponsBySurvivorId
end

---------------------------------------------------------------------------------------------------

function BattleUi.CalcWeapons(player, survivor)
    -- dedup and consolidate weapons
    local hiddenWeapons = BattleUi.hiddenWeaponsBySurvivor[survivor] or {}
    local weaponsAndModifiers = {}
    local weaponCounts = {}
    for _, weaponAndModifiers in pairs(player:WeaponsAndModifiers()) do
        local weapon = weaponAndModifiers.weapon
        if not hiddenWeapons[weapon.name] then
            local count = weaponCounts[weapon.name] or 0
            weaponCounts[weapon.name] = count + 1
            if count == 0 then
                table.insert(weaponsAndModifiers, weaponAndModifiers)
            end
        end
    end
    table.sort(weaponsAndModifiers, function(wm1, wm2) return wm1.weapon.name < wm2.weapon.name end)

    local survivorSpeed = survivor:ModifiedSpeed()
    local survivorAccuracy = survivor:ModifiedAccuracy()
    local survivorStrength = survivor:ModifiedStrength()
    local survivorLuck = survivor:ModifiedLuck()

    local monsterEvasion = Monster.Evasion()
    local monsterToughness = Monster.Toughness()
    local monsterLuck = Monster.Luck()

    local results = {}
    for _, weaponAndModifiers in ipairs(weaponsAndModifiers) do
        local weapon = weaponAndModifiers.weapon

        local speed = Util.Max(1, weapon.speed + survivorSpeed + (weaponAndModifiers.modifiers["speed"] or 0))
        -- accuracy goes the opposite way
        local accuracy = weapon.accuracy - survivorAccuracy - (weaponAndModifiers.modifiers["accuracy"] or 0)  -- accuracy goes the opposite way
        local strength = weapon.strength + survivorStrength + (weaponAndModifiers.modifiers["strength"] or 0)
        local luck = (weapon.deadly or 0) + survivorLuck + (weaponAndModifiers.modifiers["luck"] or 0)

        local hit = Util.Clamp(accuracy + monsterEvasion, 2, 10)
        local wound = Util.Max(monsterToughness - strength, 2)    -- sharp weapons means we need to show the target roll if it's past 10
        local crit = Util.Clamp(10 - luck + monsterLuck, 2, 11)
        if crit == 11 then
            crit = 'X'
        end

        if weapon.paired and weaponCounts[weapon.name] > 1 then
            speed = speed + weapon.speed
        end
        if weapon.slow and (weaponAndModifiers.modifiers["frenzy"] or 0) == 0 then
            speed = 1
        end

        table.insert(results, {
            name = weapon.name,
            speed = speed,
            hit = hit,
            wound = wound,
            strength = strength,
            crit = crit,
        })
    end

    return results
end

---------------------------------------------------------------------------------------------------

function BattleUi.UpdatePositions()
    local y = 0
    for ordinal, _ in ipairs(Player.Players()) do
        local playerUi = BattleUi.playerUis[ordinal]
        playerUi.panel:SetOffsetXY("0 "..y)
        if playerUi.open then
            y = y - BattleUi.playerUis[ordinal].height - BattleUi.PLAYER_SPACING
        end
    end
    BattleUi.panel:SetHeight(-y - 16)
end

---------------------------------------------------------------------------------------------------

function BattleUi.UpdatePlayerInternal(player)
    local playerUi = BattleUi.playerUis[player:Ordinal()]

    if not player:SurvivorSheet() then
        log:Debugf("Hiding %s", player)
        playerUi.open = false
        playerUi.height = 0
        playerUi.panel:Hide()
        return
    end

    local survivor = player:SurvivorSheet():Survivor()

    log:Debugf("Updating %s", player)

    playerUi.open = true
    playerUi.panel:Show()

    playerUi.nameText:SetText(survivor:NameOrUnnamed())
    playerUi.showWeaponsButton:Show()
    local weapons = BattleUi.CalcWeapons(player, survivor)
    local numShownWeapons = Util.Min(#weapons, BattleUi.MAX_WEAPONS)
    for i = 1, numShownWeapons do
        local weapon = weapons[i]
        playerUi.weaponImages[i]:Show()
        playerUi.weaponHideWeaponsButtons[i]:Show()
        playerUi.weaponNameTexts[i]:Show()
        playerUi.weaponNameTexts[i]:SetText(weapon.name)
        playerUi.weaponSpeedTexts[i]:Show()
        playerUi.weaponSpeedTexts[i]:SetText(weapon.speed)
        playerUi.weaponHitTexts[i]:Show()
        playerUi.weaponHitTexts[i]:SetText(weapon.hit)
        playerUi.weaponWoundTexts[i]:Show()
        playerUi.weaponWoundTexts[i]:SetText(string.format("%d (%s%d)", weapon.wound, weapon.strength > 0 and "+" or "", weapon.strength))
        playerUi.weaponCritTexts[i]:Show()
        playerUi.weaponCritTexts[i]:SetText(weapon.crit)
    end
    for i = numShownWeapons + 1, BattleUi.MAX_WEAPONS do
        playerUi.weaponImages[i]:Hide()
        playerUi.weaponHideWeaponsButtons[i]:Hide()
        playerUi.weaponNameTexts[i]:Hide()
        playerUi.weaponSpeedTexts[i]:Hide()
        playerUi.weaponHitTexts[i]:Hide()
        playerUi.weaponWoundTexts[i]:Hide()
        playerUi.weaponCritTexts[i]:Hide()
    end
    playerUi.height = 8 + (numShownWeapons + 1) * 33
    playerUi.panel:SetHeight(playerUi.height)
end

---------------------------------------------------------------------------------------------------

function BattleUi.UpdatePlayer(player)
    BattleUi.UpdatePlayerInternal(player)
    BattleUi.UpdatePositions()
end

---------------------------------------------------------------------------------------------------

function BattleUi.Update()
    for _, player in ipairs(Player.Players()) do
        BattleUi.UpdatePlayerInternal(player)
    end
    BattleUi.UpdatePositions()
end

---------------------------------------------------------------------------------------------------

function BattleUi.NextTurn()
    log:Printf("Starting next turn")

    local monsterControllerObject = nil
    local monsterControllerPlayer = nil

    local players = Player.Players()
    for i, _ in ipairs(players) do
        local playerPrefix = "Player "..i
        local survivalTokens = Location.Get(playerPrefix.." Survival Tokens"):AllObjects("Survival Tokens")
        for _, token in ipairs(survivalTokens) do
            rot = token.getRotation()
            if rot.z >= 15 and rot.z <= 345    then
                token.flip()
            end
        end

        local playerUi = BattleUi.playerUis[i]
        playerUi.turnEnded = false
        playerUi.playerCircleImage:SetImage("WhiteCircle")
        local color = NamedObject.Get(playerPrefix.." Marker").getColorTint()
        playerUi.playerCircleImage:SetColor("#"..Color(color):toHex())
        playerUi.nameText:SetColor(BattleUi.TEXT_COLOR)
        playerUi.nameText:SetFontStyle("Normal")
        playerUi.endTurnButton:SetColors(BattleUi.DARK_COLORS)

        if not monsterControllerObject then
            for _, hit in ipairs(Location.Get(playerPrefix.." Upper"):BoxCast()) do
                local object = hit.hit_object
                if object.getGMNotes() == "Monster Controller" then
                    log:Debugf("Found monster controller %s at player %d", object.getGUID(), i)
                    monsterControllerObject = object
                    monsterControllerPlayer = i
                    break
                end
            end
        end
    end

    if monsterControllerObject then
        monsterControllerPlayer = monsterControllerPlayer + 1
        if monsterControllerPlayer > #players then
            monsterControllerPlayer = 1
        end
        local survivorSheet = players[monsterControllerPlayer]:SurvivorSheet()
        if survivorSheet then
            log:Printf("%s is now the monster controller.", survivorSheet:Survivor():NameOrUnnamed())
        else
            log:Printf("Player %d is now the monster controller.", monsterControllerPlayer)
        end
        local newPosition = Location.Get("Player "..monsterControllerPlayer.." Monster Controller"):Center()
        monsterControllerObject.setPositionSmooth(newPosition, false, false)
        monsterControllerObject.setLock(true) -- It doesn't need to move, does it ?
    else
        log:Debugf("No monster controller found")
    end
end

---------------------------------------------------------------------------------------------------

function BattleUi.Show()
    BattleUi.panel:Show()
    BattleUi.uiOpen = true
end

---------------------------------------------------------------------------------------------------

function BattleUi.Hide()
    BattleUi.panel:Hide()
    BattleUi.uiOpen = false
end

---------------------------------------------------------------------------------------------------

return {
    Init = BattleUi.Init,
    PostInit = BattleUi.PostInit,
    Save = BattleUi.Save,
}

end)
return __bundle_require("__root")